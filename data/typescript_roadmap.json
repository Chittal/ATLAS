{
  "nodes": [
    {
      "id": "KDd40JOAvZ8O1mfhTYB3K",
      "name": "Introduction to TypeScript",
      "resources": {
        "description": "# TypeScript\n\nTypeScript is a statically-typed programming language that is a superset of JavaScript. It was developed and is maintained by Microsoft. TypeScript was created to address the challenges of building large-scale JavaScript applications and adds optional type annotations, classes, interfaces, and other features to the language.\n\nThe main benefits of using TypeScript include:\n\n- Type Safety\n- Improved Tooling\n- Improved Maintainability\n- Backwards Compatibility\n\nLearn more from the following links:\n\n- [@official@Overview of TypeScript](https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html)\n- [@official@TypeScript Official Handbook](https://www.typescriptlang.org/docs/handbook/intro.html)\n- [@article@What Is TypeScript?](https://thenewstack.io/what-is-typescript/)\n- [@video@Video: Where TypeScript Excels](https://youtu.be/BUo7B6UuoJ4)\n- [@feed@Explore top posts about TypeScript](https://app.daily.dev/tags/typescript?ref=roadmapsh)",
        "resources": [
          {
            "type": "course",
            "title": "Overview of TypeScript",
            "url": "https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html"
          },
          {
            "type": "course",
            "title": "TypeScript Official Handbook",
            "url": "https://www.typescriptlang.org/docs/handbook/intro.html"
          },
          {
            "type": "article",
            "title": "What Is TypeScript?",
            "url": "https://thenewstack.io/what-is-typescript/"
          },
          {
            "type": "video",
            "title": "Video: Where TypeScript Excels",
            "url": "https://youtu.be/BUo7B6UuoJ4"
          },
          {
            "type": "article",
            "title": "Explore top posts about TypeScript",
            "url": "https://app.daily.dev/tags/typescript?ref=roadmapsh"
          }
        ]
      }
    },
    {
      "id": "MQWzN_kXxVJMOYbRXSGJc",
      "name": "TypeScript vs JavaScript",
      "resources": {
        "description": "# TypeScript vs JavaScript\n\nTypeScript is a superset of JavaScript that adds optional type annotations and other features such as interfaces, classes, and namespaces. JavaScript is a dynamically-typed language that is primarily used for client-side web development and can also be used for server-side development.\n\nHere are a few key differences between TypeScript and JavaScript:\n\n- **Types**: TypeScript has optional type annotations while JavaScript is dynamically-typed. This means that in TypeScript, you can specify the data type of variables, parameters, and return values, which can help catch type-related errors at compile-time.\n- **Syntax**: TypeScript extends JavaScript syntax with features like interfaces, classes, and namespaces. This provides a more robust and organized structure for large-scale projects.\n- **Tooling**: TypeScript has better tooling support, such as better editor integration, type checking, and code refactoring.\n- **Backwards Compatibility**: TypeScript is fully compatible with existing JavaScript code, which means you can use TypeScript in any JavaScript environment.\n\nLearn more from the following links:\n\n- [@official@Learning JavaScript and TypeScript](https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html#learning-javascript-and-typescript)\n- [@article@TypeScript vs. JavaScript](https://thenewstack.io/typescript-vs-javascript/)\n- [@feed@Explore top posts about JavaScript](https://app.daily.dev/tags/javascript?ref=roadmapsh)",
        "resources": [
          {
            "type": "course",
            "title": "Learning JavaScript and TypeScript",
            "url": "https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html#learning-javascript-and-typescript"
          },
          {
            "type": "article",
            "title": "TypeScript vs. JavaScript",
            "url": "https://thenewstack.io/typescript-vs-javascript/"
          },
          {
            "type": "article",
            "title": "Explore top posts about JavaScript",
            "url": "https://app.daily.dev/tags/javascript?ref=roadmapsh"
          }
        ]
      }
    },
    {
      "id": "dcLaEU_lb0z_QypL1ZhpX",
      "name": "TS and JS Interoperability",
      "resources": {
        "description": "# TS/JS Interoperability\n\nTypeScript and JavaScript have full interoperability, meaning you can use TypeScript code in JavaScript projects and vice versa. TypeScript is a superset of JavaScript, which means that any valid JavaScript code is also valid TypeScript code.\n\nYou can use JavaScript libraries in TypeScript projects by either including the JavaScript files directly or using type definitions for the library. Type definitions provide type information for JavaScript libraries, making it easier to use them in TypeScript.\n\nOn the other hand, you can use TypeScript code in JavaScript projects by simply compiling the TypeScript code into JavaScript. The generated JavaScript code can be used in any JavaScript environment, and it will work the same way as regular JavaScript code.\n\nTypeScript's compiler also supports type checking for plain JavaScript code by adding the `// @ts-check` comment at the top of a file. This allows the compiler to validate types by inspecting the JSDoc comments:\n\n```typescript\n// @ts-check\n\n/**\n * Adds two numbers together.\n * @param {number} a - The first number.\n * @param {number} b - The second number.\n * @returns {number} The sum of the two numbers.\n */\nfunction add(a, b) {\n  return a + b;\n}\n```\n\nLearn more from the following links:\n\n- [@official@Type Checking JavaScript Files](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html)\n- [@video@Using JavaScript in TypeScript](https://youtu.be/AZhZlEbBaB4)",
        "resources": [
          {
            "type": "course",
            "title": "Type Checking JavaScript Files",
            "url": "https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html"
          },
          {
            "type": "video",
            "title": "Using JavaScript in TypeScript",
            "url": "https://youtu.be/AZhZlEbBaB4"
          }
        ]
      }
    },
    {
      "id": "dA8CNQOgJRDa0T7rmyS7f",
      "name": "Installation and Configuration",
      "resources": {
        "description": "# Install and Configure\n\nTo install and configure TypeScript in your project, you need to perform the following steps:\n\n- Initialize npm in your project directory by running the following command:\n\n```bash\nnpm init\n```\n\n- Install TypeScript as a project dependency by running the following command:\n\n```bash\nnpm install --save-dev typescript\n```\n\n- Create a `tsconfig.json` file in your project directory to specify the compiler options for building your project. For example:\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"es5\",\n    \"module\": \"commonjs\",\n    \"strict\": true,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\"\n  },\n  \"exclude\": [\"node_modules\"]\n}\n```\n\n- Compile your TypeScript code using the following command:\n\n```bash\nnpx tsc\n```\n\nNote: You can also compile individual TypeScript files by specifying the file path after the tsc command. For example:\n\n```bash\nnpx tsc ./src/index.ts\n```\n\nAnd you're all set! You can now start writing TypeScript code in your project.\n\nLearn more from the following links:\n\n- [@official@Install and Configure TypeScript](https://www.typescriptlang.org/download)\n- [@article@TypeScript Getting Started](https://thenewstack.io/typescript-tutorial-a-guide-to-using-the-programming-language/)",
        "resources": [
          {
            "type": "course",
            "title": "Install and Configure TypeScript",
            "url": "https://www.typescriptlang.org/download"
          },
          {
            "type": "article",
            "title": "TypeScript Getting Started",
            "url": "https://thenewstack.io/typescript-tutorial-a-guide-to-using-the-programming-language/"
          }
        ]
      }
    },
    {
      "id": "DmqrX56d9KnBcOSwlJR2q",
      "name": "tsconfig.json",
      "resources": {
        "description": "# tsconfig.json\n\ntsconfig.json is a configuration file in TypeScript that specifies the compiler options for building your project. It helps the TypeScript compiler understand the structure of your project and how it should be compiled to JavaScript. Some common options include:\n\n- `target`: the version of JavaScript to compile to.\n- `module`: the module system to use.\n- `strict`: enables/disables strict type checking.\n- `outDir`: the directory to output the compiled JavaScript files.\n- `rootDir`: the root directory of the TypeScript files.\n- `include`: an array of file/directory patterns to include in the compilation.\n- `exclude`: an array of file/directory patterns to exclude from the compilation.\n\nGiven below is the sample `tsconfig.json` file:\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"es5\",\n    \"module\": \"commonjs\",\n    \"strict\": true,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n  },\n  \"exclude\": [\"node_modules\"],\n  \"include\": [\"src\"]\n}\n```\n\nLearn more from the following links:\n\n- [@official@What is a tsconfig.json](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#handbook-content)",
        "resources": [
          {
            "type": "course",
            "title": "What is a tsconfig.json",
            "url": "https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#handbook-content"
          }
        ]
      }
    },
    {
      "id": "RrExVb7l2gd0s_TlNdLeD",
      "name": "Compiler Options",
      "resources": {
        "description": "# Compiler Options\n\nTypeScript compiler accepts a number of command line options that allow you to customize the compilation process. These options can be passed to the compiler using the `--` prefix, for example:\n\n```bash\ntsc --target ES5 --module commonjs\n```\n\nLearn more from the following links:\n\n- [@official@Compiler Options](https://www.typescriptlang.org/docs/handbook/compiler-options.html)",
        "resources": [
          {
            "type": "course",
            "title": "Compiler Options",
            "url": "https://www.typescriptlang.org/docs/handbook/compiler-options.html"
          }
        ]
      }
    },
    {
      "id": "qdy4ZIY2EKgmPNdu_ndcg",
      "name": "Running TypeScript",
      "resources": {
        "description": "# Running TypeScript\n\nTo run TypeScript code, you'll need to have a TypeScript compiler installed. Here's a general process to run TypeScript code:\n\n- Write TypeScript code in a `.ts` file (e.g. `app.ts`)\n- Compile the TypeScript code into JavaScript using the TypeScript compiler:\n\n```bash\ntsc app.ts\n```\n\n- Run the generated JavaScript code using a JavaScript runtime environment such as Node.js:\n\n```bash\nnode app.js\n```\n\nLearn more from the following link:\n\n- [@official@Running your TypeScript](https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html)\n- [@feed@Explore top posts about TypeScript](https://app.daily.dev/tags/typescript?ref=roadmapsh)",
        "resources": [
          {
            "type": "course",
            "title": "Running your TypeScript",
            "url": "https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html"
          },
          {
            "type": "article",
            "title": "Explore top posts about TypeScript",
            "url": "https://app.daily.dev/tags/typescript?ref=roadmapsh"
          }
        ]
      }
    },
    {
      "id": "Iv_t13PSVzet5VPKFtAp1",
      "name": "tsc",
      "resources": {
        "description": "# tsc\n\n`tsc` is the command line tool for the TypeScript compiler. It compiles TypeScript code into JavaScript code, making it compatible with the browser or any JavaScript runtime environment.\n\nYou can use the `tsc` command to compile your TypeScript code by running the following command in your terminal or command prompt:\n\n```bash\ntsc\n```\n\nThis command will compile all TypeScript files in your project that are specified in your `tsconfig.json` file. If you want to compile a specific TypeScript file, you can specify the file name after the `tsc` command, like this:\n\n```bash\ntsc index.ts\n```\n\nThe `tsc` command has several options and flags that you can use to customize the compilation process. For example, you can use the `--target` option to specify the version of JavaScript to compile to, or the `--outDir` option to specify the output directory for the compiled JavaScript files.\n\nYou can run `tsc --help` to see a list of all the available options and flags.\n\nLearn more from the following links:\n\n- [@official@tsc CLI Options](https://www.typescriptlang.org/docs/handbook/compiler-options.html#using-the-cli)\n- [@feed@Explore top posts about TypeScript](https://app.daily.dev/tags/typescript?ref=roadmapsh)",
        "resources": [
          {
            "type": "course",
            "title": "tsc CLI Options",
            "url": "https://www.typescriptlang.org/docs/handbook/compiler-options.html#using-the-cli"
          },
          {
            "type": "article",
            "title": "Explore top posts about TypeScript",
            "url": "https://app.daily.dev/tags/typescript?ref=roadmapsh"
          }
        ]
      }
    },
    {
      "id": "ZCM2_X4BiKh5FTCizrr-E",
      "name": "ts-node",
      "resources": {
        "description": "# ts-node\n\nts-node is a TypeScript execution and REPL for node.js, with source map and native ESM support. Learn more from the following links:\n\n- [@opensource@ts-node - GitHub Project](https://github.com/TypeStrong/ts-node)\n- [@article@How To Run TypeScript Scripts with ts-node](https://www.digitalocean.com/community/tutorials/typescript-running-typescript-ts-node)\n- [@feed@Explore top posts about TypeScript](https://app.daily.dev/tags/typescript?ref=roadmapsh)",
        "resources": [
          {
            "type": "tutorial",
            "title": "ts-node - GitHub Project",
            "url": "https://github.com/TypeStrong/ts-node"
          },
          {
            "type": "article",
            "title": "How To Run TypeScript Scripts with ts-node",
            "url": "https://www.digitalocean.com/community/tutorials/typescript-running-typescript-ts-node"
          },
          {
            "type": "article",
            "title": "Explore top posts about TypeScript",
            "url": "https://app.daily.dev/tags/typescript?ref=roadmapsh"
          }
        ]
      }
    },
    {
      "id": "_bZ71i36haWgHQTY0yMOx",
      "name": "TS Playground",
      "resources": {
        "description": "# TS Playground\n\nThe TypeScript Playground is a great tool to learn TypeScript. It allows you to write TypeScript code and see the JavaScript output. It also allows you to share your code with others.\n\nLearn more from the following links:\n\n- [@official@TypeScript Official - Playground](https://www.typescriptlang.org/play)\n- [@feed@Explore top posts about TypeScript](https://app.daily.dev/tags/typescript?ref=roadmapsh)",
        "resources": [
          {
            "type": "course",
            "title": "TypeScript Official - Playground",
            "url": "https://www.typescriptlang.org/play"
          },
          {
            "type": "article",
            "title": "Explore top posts about TypeScript",
            "url": "https://app.daily.dev/tags/typescript?ref=roadmapsh"
          }
        ]
      }
    },
    {
      "id": "qcrGApxNzkGYxgcd7o45d",
      "name": "TypeScript Types",
      "resources": {
        "description": "# Typescript Types\n\nTypeScript has several built-in types, including:\n\n- number\n- string\n- boolean\n- any\n- void\n- null and undefined\n- never\n- object\n- symbol\n- Enumerated types (enum)\n- Tuple types\n- Array types\n- Union types\n- Intersection types\n- Type aliases\n- Type assertions\n\nYou can also create custom types in TypeScript using interfaces, classes, and type aliases.\n\nLearn more from the following links:\n\n- [@official@TypeScript - Everyday Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html)\n- [@feed@Explore top posts about TypeScript](https://app.daily.dev/tags/typescript?ref=roadmapsh)",
        "resources": [
          {
            "type": "course",
            "title": "TypeScript - Everyday Types",
            "url": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html"
          },
          {
            "type": "article",
            "title": "Explore top posts about TypeScript",
            "url": "https://app.daily.dev/tags/typescript?ref=roadmapsh"
          }
        ]
      }
    },
    {
      "id": "hfIHxa5i_5rEpjtzqEsic",
      "name": "boolean",
      "resources": {
        "description": "# boolean\n\n`boolean` is a primitive data type in TypeScript that represents a boolean value i.e. either true or false. Given below is an example of a boolean variable declaration:\n\n```typescript\nlet isTrue: boolean = true;\nlet isFalse: boolean = false;\n```\n\nLearn more from the following links:\n\n- [@article@Number, String, Boolean, Symbol and Object](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#the-primitives-string-number-and-boolean)",
        "resources": [
          {
            "type": "article",
            "title": "Number, String, Boolean, Symbol and Object",
            "url": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#the-primitives-string-number-and-boolean"
          }
        ]
      }
    },
    {
      "id": "UH9d3cvGy_e67WFNFwCyf",
      "name": "number",
      "resources": {
        "description": "# number\n\nIt is a primitive data type in TypeScript that represents numeric values. It includes both integer and floating-point values.\n\n```typescript\nlet intValue: number = 42;\nlet floatValue: number = 3.14;\n```\n\nLearn more from the following links:\n\n- [@official@Number, String, Boolean, Symbol and Object](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#the-primitives-string-number-and-boolean)",
        "resources": [
          {
            "type": "course",
            "title": "Number, String, Boolean, Symbol and Object",
            "url": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#the-primitives-string-number-and-boolean"
          }
        ]
      }
    },
    {
      "id": "d8iV-IBZ6cSnH8Z5_HRmc",
      "name": "string",
      "resources": {
        "description": "# string\n\nIt is a primitive data type in TypeScript that represents textual data. It is a set of elements of the 16-bit Unicode character set.\n\n```typescript\nlet name: string = 'John Doe';\n```\n\nLearn more from the following link\n\n- [@official@Number, String, Boolean, Symbol and Object](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#the-primitives-string-number-and-boolean)",
        "resources": [
          {
            "type": "course",
            "title": "Number, String, Boolean, Symbol and Object",
            "url": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#the-primitives-string-number-and-boolean"
          }
        ]
      }
    },
    {
      "id": "yLlQg7BF--ZwRHbXBWfOi",
      "name": "void",
      "resources": {
        "description": "# void\n\n`void` represents the return value of functions which don’t return a value. It’s the inferred type any time a function doesn’t have any `return` statements, or doesn’t return any explicit value from those return statements:\n\n```typescript\n// The inferred return type is void\nfunction noop() {\n  return;\n}\n```\n\nIn JavaScript, a function that doesn’t return any value will implicitly return the value `undefined`. However, `void` and `undefined` are not the same thing in TypeScript. There are further details at the end of this chapter.\n\nLearn more from the following links:\n\n- [@official@void - TypeScript Docs](https://www.typescriptlang.org/docs/handbook/2/functions.html#void)",
        "resources": [
          {
            "type": "course",
            "title": "void - TypeScript Docs",
            "url": "https://www.typescriptlang.org/docs/handbook/2/functions.html#void"
          }
        ]
      }
    },
    {
      "id": "Sa6IZtM4XJstultz-pbh0",
      "name": "undefined",
      "resources": {
        "description": "# undefined\n\nJavaScript has two primitive values used to signal absent or uninitialized value: `null` (absent) and `undefined` (uninitialized).\n\nTypeScript has two corresponding _types_ by the same names. How these types behave depends on whether you have the `strictNullChecks` option on.\n\nWith `strictNullChecks` off, values that might be `null` or `undefined` can still be accessed normally, and the values `null` and `undefined` can be assigned to a property of any type. This is similar to how languages without `null` checks (e.g. C#, Java) behave. The lack of checking for these values tends to be a major source of bugs; TypeScript always recommend people turn `strictNullChecks` on if it’s practical to do so in the codebase.\n\nWith `strictNullChecks` on, when a value is `null` or `undefined`, you will need to test for those values before using methods or properties on that value. Just like checking for `undefined` before using an optional property, we can use narrowing to check for values that might be `null`:\n\n```typescript\nfunction doSomething(x: string | null) {\n  if (x === null) {\n    // do nothing\n  } else {\n    console.log('Hello, ' + x.toUpperCase());\n  }\n}\n```\n\nLearn more from the following links:\n\n- [@official@null and undefined](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#null-and-undefined)",
        "resources": [
          {
            "type": "course",
            "title": "null and undefined",
            "url": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#null-and-undefined"
          }
        ]
      }
    },
    {
      "id": "cjAwawhZLo1qVQ93XIdm2",
      "name": "null",
      "resources": {
        "description": "# null\n\nJavaScript has two primitive values used to signal absent or uninitialized value: `null` (absent) and `undefined` (unintialized).\n\nTypeScript has two corresponding _types_ by the same names. How these types behave depends on whether you have the `strictNullChecks` option on.\n\nWith `strictNullChecks` off, values that might be `null` or `undefined` can still be accessed normally, and the values `null` and `undefined` can be assigned to a property of any type. This is similar to how languages without `null` checks (e.g. C#, Java) behave. The lack of checking for these values tends to be a major source of bugs; TypeScript always recommend people turn `strictNullChecks` on if it’s practical to do so in the codebase.\n\nWith `strictNullChecks` on, when a value is `null` or `undefined`, you will need to test for those values before using methods or properties on that value. Just like checking for `undefined` before using an optional property, we can use narrowing to check for values that might be `null`:\n\n```typescript\nfunction doSomething(x: string | null) {\n  if (x === null) {\n    // do nothing\n  } else {\n    console.log('Hello, ' + x.toUpperCase());\n  }\n}\n```\n\nLearn more from the following links:\n\n- [@official@null and undefined](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#null-and-undefined)",
        "resources": [
          {
            "type": "course",
            "title": "null and undefined",
            "url": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#null-and-undefined"
          }
        ]
      }
    },
    {
      "id": "mVKsM7R4Ivpdhnbwt1aRb",
      "name": "Interface",
      "resources": {
        "description": "# Interface\n\nTypeScript allows you to specifically type an object using an interface that can be reused by multiple objects.\n\n```typescript\ninterface Person {\n  name: string;\n  age: number;\n}\n\nfunction greet(person: Person) {\n  return 'Hello ' + person.name;\n}\n```\n\nLearn more from the following links:\n\n- [@official@Object Types - Interfaces](https://www.typescriptlang.org/docs/handbook/2/objects.html)",
        "resources": [
          {
            "type": "course",
            "title": "Object Types - Interfaces",
            "url": "https://www.typescriptlang.org/docs/handbook/2/objects.html"
          }
        ]
      }
    },
    {
      "id": "tTSITP1W1ymS-njbFb8Ts",
      "name": "Class",
      "resources": {
        "description": "# Class\n\nIn TypeScript, a class is a blueprint for creating objects with specific properties and methods. Classes are a fundamental concept in object-oriented programming. Here is an example of a simple class in TypeScript:\n\n```typescript\nclass Car {\n  make: string;\n  model: string;\n  year: number;\n\n  constructor(make: string, model: string, year: number) {\n    this.make = make;\n    this.model = model;\n    this.year = year;\n  }\n\n  drive() {\n    console.log(`Driving my ${this.year} ${this.make} ${this.model}`);\n  }\n}\n```\n\nLearn more from the following links:\n\n- [@official@TypeScript Classes](https://www.typescriptlang.org/docs/handbook/2/classes.html)",
        "resources": [
          {
            "type": "course",
            "title": "TypeScript Classes",
            "url": "https://www.typescriptlang.org/docs/handbook/2/classes.html"
          }
        ]
      }
    },
    {
      "id": "bfZIXHceDKDGQl-24kQpT",
      "name": "Enum",
      "resources": {
        "description": "# Enum\n\nEnums is not a type-level extension of JavaScript. It allows a developer to define a set of named constants. Using enums can make it easier to document intent, or create a set of distinct cases. TypeScript provides both numeric and string-based enums.\n\nHere is an example of a numeric enum in TypeScript:\n\n```typescript\nenum Direction {\n  Up = 1,\n  Down,\n  Left,\n  Right,\n}\n```\n\nAbove, we have a numeric enum where `Up` is initialized with `1`. All of the following members are auto-incremented from that point on. In other words, `Direction.Up` has the value `1`, `Down` has `2`, `Left` has `3`, and `Right` has `4`.\n\nIf we left off the initializer for `Up`, it would have the value `0` and the rest of the members would be auto-incremented from there.\n\nLearn more from the following links:\n\n- [@official@TypeScript - Enums](https://www.typescriptlang.org/docs/handbook/enums.html)",
        "resources": [
          {
            "type": "course",
            "title": "TypeScript - Enums",
            "url": "https://www.typescriptlang.org/docs/handbook/enums.html"
          }
        ]
      }
    },
    {
      "id": "YbDuIo1BbZKEAZwmXlCdZ",
      "name": "Array",
      "resources": {
        "description": "# Array\n\nTo specify the type of an array like `[1, 2, 3]`, you can use the syntax `number[]`; this syntax works for any type (e.g. `string[]` is an array of strings, and so on). You may also see this written as `Array<number>`, which means the same thing.\n\n```typescript\nconst numbers: number[] = [1, 2, 3];\n```\n\nLearn more from the following links:\n\n- [@official@Arrays](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#arrays)",
        "resources": [
          {
            "type": "course",
            "title": "Arrays",
            "url": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#arrays"
          }
        ]
      }
    },
    {
      "id": "jq-GD0DLyzrEXQKUmt5kv",
      "name": "Tuple",
      "resources": {
        "description": "# Tuple\n\nA tuple type is another sort of Array type that knows exactly how many elements it contains, and exactly which types it contains at specific positions.\n\n```typescript\ntype StringNumberPair = [string, number];\n\nconst pair: StringNumberPair = ['hello', 42];\n\nconst first = pair[0];\nconst second = pair[1];\n\n// Error: Index out of bounds\nconst third = pair[2];\n```\n\nLearn more from the following links:\n\n- [@official@Tuple Types](https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types)",
        "resources": [
          {
            "type": "course",
            "title": "Tuple Types",
            "url": "https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types"
          }
        ]
      }
    },
    {
      "id": "vnqvm_WiaKqpdxrW4wRGa",
      "name": "Object",
      "resources": {
        "description": "# Object\n\nTo define an `object` type, we simply list its properties and their types.\n\nFor example, here’s a function that takes a point-like object:\n\n```typescript\n// The parameter's type annotation is an object type\nfunction printCoord(pt: { x: number; y: number }) {\n  console.log(\"The coordinate's x value is \" + pt.x);\n  console.log(\"The coordinate's y value is \" + pt.y);\n}\n\nprintCoord({ x: 3, y: 7 });\n```\n\nLearn more from the following links:\n\n- [@official@Object Types in TypeScript](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#object-types)",
        "resources": [
          {
            "type": "course",
            "title": "Object Types in TypeScript",
            "url": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#object-types"
          }
        ]
      }
    },
    {
      "id": "O2TYbd9i_OQwQk2dKh-ly",
      "name": "unknown",
      "resources": {
        "description": "# Unknown\n\n`unknown` is the type-safe counterpart of any. Anything is assignable to `unknown`, but `unknown` isn’t assignable to anything but itself and `any` without a type assertion or a control flow based narrowing. Likewise, no operations are permitted on an `unknown` without first asserting or narrowing to a more specific type.\n\n```typescript\nfunction f1(a: any) {\n  a.b(); // OK\n}\n\nfunction f2(a: unknown) {\n  // Error: Property 'b' does not exist on type 'unknown'.\n  a.b();\n}\n```\n\nLearn more from the following links:\n\n- [@official@Unknown Type in TypeScript](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type)",
        "resources": [
          {
            "type": "course",
            "title": "Unknown Type in TypeScript",
            "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type"
          }
        ]
      }
    },
    {
      "id": "yXiLegSlL7SveU8rBGj8U",
      "name": "any",
      "resources": {
        "description": "# Any\n\nTypeScript has a special type, `any`, that you can use whenever you don’t want a particular value to cause typechecking errors.\n\nWhen a value is of type `any`, you can access any properties of it (which will in turn be of type `any`), call it like a function, assign it to (or from) a value of any type, or pretty much anything else that’s syntactically legal:\n\n```typescript\nlet obj: any = { x: 0 };\n// None of the following lines of code will throw compiler errors.\n// Using `any` disables all further type checking, and it is assumed\n// you know the environment better than TypeScript.\nobj.foo();\nobj();\nobj.bar = 100;\nobj = 'hello';\nconst n: number = obj;\n```\n\nLearn more from the following links:\n\n- [@official@any type in TypeScript](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#any)",
        "resources": [
          {
            "type": "course",
            "title": "any type in TypeScript",
            "url": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#any"
          }
        ]
      }
    },
    {
      "id": "0pi9VTbngcAIswuu5LIYg",
      "name": "never",
      "resources": {
        "description": "# Never\n\nThe `never` type represents the type of values that never occur. For instance, `never` is the return type for a function expression or an arrow function expression that always throws an exception or one that never returns. Variables also acquire the type never when narrowed by any type guards that can never be `true`.\n\nThe never type is a subtype of, and assignable to, every type; however, no type is a subtype of, or assignable to, `never` (except `never` itself). Even any isn’t assignable to `never`.\n\nExamples of functions returning never:\n\n```typescript\n// Function returning never must not have a reachable end point\nfunction error(message: string): never {\n  throw new Error(message);\n}\n\n// Inferred return type is never\nfunction fail() {\n  return error('Something failed');\n}\n\n// Function returning never must not have a reachable end point\nfunction infiniteLoop(): never {\n  while (true) {}\n}\n```\n\nLearn more from the following links:\n\n- [@official@Never Type](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#the-never-type)",
        "resources": [
          {
            "type": "course",
            "title": "Never Type",
            "url": "https://www.typescriptlang.org/docs/handbook/2/narrowing.html#the-never-type"
          }
        ]
      }
    },
    {
      "id": "pGFnTqi0-RSj0YRmNA5iy",
      "name": "as const",
      "resources": {
        "description": "# As Const\n\n`as const` is a type assertion in TypeScript that allows you to assert that an expression has a specific type, and that its value should be treated as a read-only value.\n\nFor example:\n\n```typescript\nconst colors = ['red', 'green', 'blue'] as const;\n\n// colors is now of type readonly ['red', 'green', 'blue']\n```\n\nUsing as const allows TypeScript to infer more accurate types for constants, which can lead to improved type checking and better type inference in your code.\n\nLearn more from the following links:\n\n- [@official@const assertions](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions)",
        "resources": [
          {
            "type": "course",
            "title": "const assertions",
            "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions"
          }
        ]
      }
    },
    {
      "id": "Ba0baUbomrW9td_K8U-5L",
      "name": "as [type]",
      "resources": {
        "description": "# As Type\n\nIn TypeScript, the as keyword is used for type assertions, allowing you to explicitly inform the compiler about the type of a value when it cannot be inferred automatically. Type assertions are a way to override the default static type-checking behavior and tell the compiler that you know more about the type of a particular expression than it does.\n\nHere's a simple example:\n\n```typescript\nlet someValue: any = \"Hello, TypeScript!\";\nlet strLength: number = (someValue as string).length;\n\nconsole.log(strLength); // Outputs: 18\n```\n\nIn this example, someValue is initially of type any, and we use the as operator to assert that it is of type string before accessing its length property.\n\nIt's important to note that type assertions do not change the runtime type of a value, and do not cause any type of conversion. They are a compile-time construct used for static type checking in TypeScript.\n\n- [@official@Type assertions](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-assertions)",
        "resources": [
          {
            "type": "course",
            "title": "Type assertions",
            "url": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-assertions"
          }
        ]
      }
    },
    {
      "id": "afTNr36VqeXoJpHxm2IoS",
      "name": "as any",
      "resources": {
        "description": "# As Any\n\n`any` is a special type in TypeScript that represents a value of any type. When a value is declared with the any type, the compiler will not perform any type checks or type inference on that value.\n\nFor example:\n\n```typescript\nlet anyValue: any = 42;\n\n// we can assign any value to anyValue, regardless of its type\nanyValue = 'Hello, world!';\nanyValue = true;\n```\n\nLearn more from the following links:\n\n- [@official@any](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#any)",
        "resources": [
          {
            "type": "course",
            "title": "any",
            "url": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#any"
          }
        ]
      }
    },
    {
      "id": "mjaL5ocLnM8VQlhUxW6KU",
      "name": "Non-null Assertion",
      "resources": {
        "description": "# Non Null Assertion\n\nThe non-null assertion operator (!) is a type assertion in TypeScript that allows you to tell the compiler that a value will never be null or undefined.\n\n```typescript\nlet name: string | null = null;\n\n// we use the non-null assertion operator to tell the compiler that name will never be null\nlet nameLength = name!.length;\n```\n\nThe non-null assertion operator is used to assert that a value is not null or undefined, and to tell the compiler to treat the value as non-nullable. However, it's important to be careful when using the non-null assertion operator, as it can lead to runtime errors if the value is actually `null` or `undefined`.\n\nLearn more from the following links:\n\n- [@official@Non-null assertion operator](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-assertion-operator)",
        "resources": [
          {
            "type": "course",
            "title": "Non-null assertion operator",
            "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-assertion-operator"
          }
        ]
      }
    },
    {
      "id": "HD1UGOidp7JGKdW6CEdQ_",
      "name": "satisfies keyword",
      "resources": {
        "description": "# satisfies Keyword\n\nThe `satisfies` operator lets us validate that the type of an expression matches some type, without changing the resulting type of that expression.",
        "resources": [
          {
            "type": "course",
            "title": "satisfies Keyword",
            "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html#the-satisfies-operator"
          }
        ]
      }
    },
    {
      "id": "KUur-gfOBQodTS-irFet7",
      "name": "Type Inference",
      "resources": {
        "description": "# Type Inference\n\nType inference in TypeScript refers to the process of automatically determining the type of a variable based on the value assigned to it. This allows you to write code that is more concise and easier to understand, as the TypeScript compiler can deduce the types of variables without you having to explicitly specify them.\n\nHere's an example of type inference in TypeScript:\n\n```typescript\nlet name = 'John Doe';\n```\n\nIn this example, the TypeScript compiler automatically infers that the type of the name variable is string. This means that you can use the name variable just like any other string in your code, and the TypeScript compiler will ensure that you don't perform any invalid operations on it.\n\nLearn more from the following links:\n\n- [@official@Type Inference](https://www.typescriptlang.org/docs/handbook/type-inference.html#handbook-content)",
        "resources": [
          {
            "type": "course",
            "title": "Type Inference",
            "url": "https://www.typescriptlang.org/docs/handbook/type-inference.html#handbook-content"
          }
        ]
      }
    },
    {
      "id": "alMJCEyUZ90xz-2_g3YRj",
      "name": "Type Compatibility",
      "resources": {
        "description": "# Type Compatibility\n\nTypeScript uses structural typing to determine type compatibility. This means that two types are considered compatible if they have the same structure, regardless of their names.\n\nHere's an example of type compatibility in TypeScript:\n\n```typescript\ninterface Point {\n  x: number;\n  y: number;\n}\n\nlet p1: Point = { x: 10, y: 20 };\nlet p2: { x: number; y: number } = p1;\n\nconsole.log(p2.x); // Output: 10\n```\n\nIn this example, `p1` has the type `Point`, while `p2` has the type `{ x: number; y: number }`. Despite the fact that the two types have different names, they are considered compatible because they have the same structure. This means that you can assign a value of type `Point` to a variable of type `{ x: number; y: number }`, as we do with `p1` and `p2` in this example.\n\nLearn more from the following links:\n\n- [@official@Type Compatibility](https://www.typescriptlang.org/docs/handbook/type-compatibility.html)",
        "resources": [
          {
            "type": "course",
            "title": "Type Compatibility",
            "url": "https://www.typescriptlang.org/docs/handbook/type-compatibility.html"
          }
        ]
      }
    },
    {
      "id": "qefnsugcveizVq2TORRgn",
      "name": "Combining Types",
      "resources": {
        "description": "# Combining Types\n\nIn TypeScript, you can combine types using type union and type intersection.\n\n## Type Union\n\nThe union operator `|` is used to combine two or more types into a single type that represents all the possible types. For example:\n\n```typescript\ntype stringOrNumber = string | number;\nlet value: stringOrNumber = 'hello';\n\nvalue = 42;\n```\n\n## Type Intersection\n\nThe intersection operator `&` is used to intersect two or more types into a single type that represents the properties of all the types. For example:\n\n```typescript\ninterface A {\n  a: string;\n}\n\ninterface B {\n  b: number;\n}\n\ntype AB = A & B;\nlet value: AB = { a: 'hello', b: 42 };\n```\n\nLearn more from the following links:\n\n- [@official@Union Types in TypeScript](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)\n- [@article@Intersection Types in TypeScript](https://www.typescripttutorial.net/typescript-tutorial/typescript-intersection-types/)\n- [@article@Type Aliases](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases)\n- [@article@Keyof Type Operator](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html#handbook-content)",
        "resources": [
          {
            "type": "course",
            "title": "Union Types in TypeScript",
            "url": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types"
          },
          {
            "type": "article",
            "title": "Intersection Types in TypeScript",
            "url": "https://www.typescripttutorial.net/typescript-tutorial/typescript-intersection-types/"
          },
          {
            "type": "article",
            "title": "Type Aliases",
            "url": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases"
          },
          {
            "type": "article",
            "title": "Keyof Type Operator",
            "url": "https://www.typescriptlang.org/docs/handbook/2/keyof-types.html#handbook-content"
          }
        ]
      }
    },
    {
      "id": "5z5w3yv1HbOpMlzEd4Iot",
      "name": "Union Types",
      "resources": {
        "description": "# Union Types\n\nUnion Types in TypeScript allow you to specify multiple possible types for a single variable or parameter. A union type is written as a vertical bar `|` separated list of types.\n\nFor example, consider a function that takes either a string or a number as an argument:\n\n```typescript\nfunction combine(input1: string | number, input2: string | number) {\n  return input1 + input2;\n}\n```\n\nLearn more from the following links:\n\n- [@official@Union Types in TypeScript](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)",
        "resources": [
          {
            "type": "course",
            "title": "Union Types in TypeScript",
            "url": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types"
          }
        ]
      }
    },
    {
      "id": "RWYXEZMODUrqwRWf_Lqi9",
      "name": "Intersection Types",
      "resources": {
        "description": "# Intersection Types\n\nAn intersection type creates a new type by combining multiple existing types. The new type has all features of the existing types.\n\nTo combine types, you use the `&` operator as follows:\n\n```typescript\ntype typeAB = typeA & typeB;\n```\n\nThe `typeAB` will have all properties from both typeA and typeB.\n\nNote that the union type uses the `|` operator that defines a variable which can hold `typeA` value, or `typeB` value, or both altogether.\n\nLearn more from the following links:\n\n- [@article@Intersection Types in TypeScript](https://www.typescripttutorial.net/typescript-tutorial/typescript-intersection-types/)",
        "resources": [
          {
            "type": "article",
            "title": "Intersection Types in TypeScript",
            "url": "https://www.typescripttutorial.net/typescript-tutorial/typescript-intersection-types/"
          }
        ]
      }
    },
    {
      "id": "M_3O21zjppgWptIT5dtu8",
      "name": "Type Aliases",
      "resources": {
        "description": "# Type Aliases\n\nA Type Alias in TypeScript allows you to create a new name for a type.\n\nHere's an example:\n\n```typescript\ntype Name = string;\ntype Age = number;\ntype User = { name: Name; age: Age };\n\nconst user: User = { name: 'John', age: 30 };\n```\n\nIn the example above, `Name` and `Age` are type aliases for `string` and `number` respectively. And `User` is a type alias for an object with properties `name` of type `Name` and `age` of type `Age`.\n\nLearn more from the following links:\n\n- [@official@Type Aliases](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases)",
        "resources": [
          {
            "type": "course",
            "title": "Type Aliases",
            "url": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases"
          }
        ]
      }
    },
    {
      "id": "t1Tcesfq7bV2TkHcfD6lU",
      "name": "keyof Operator",
      "resources": {
        "description": "# keyof Operator\n\nThe `keyof` operator in TypeScript is used to get the union of keys from an object type. Here's an example of how it can be used:\n\n```typescript\ninterface User {\n  name: string;\n  age: number;\n  location: string;\n}\n\ntype UserKeys = keyof User; // \"name\" | \"age\" | \"location\"\nconst key: UserKeys = 'name';\n```\n\nIn this example, `UserKeys` is a type that represents the union of keys from the `User` interface, which is `\"name\"` | `\"age\"` | `\"location\"`. And a constant named `key` with the type `UserKeys` is declared with the value `\"name\"`.\n\nLearn more from the following links:\n\n- [@official@keyof Type Operator](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html#handbook-content)",
        "resources": [
          {
            "type": "course",
            "title": "keyof Type Operator",
            "url": "https://www.typescriptlang.org/docs/handbook/2/keyof-types.html#handbook-content"
          }
        ]
      }
    },
    {
      "id": "cFZsxpYHDxm7IWwergb3r",
      "name": "Type Guards / Narrowing",
      "resources": {
        "description": "# Type Guards\n\nType guards are a way to narrow down the type of a variable. This is useful when you want to do something different depending on the type of a variable.",
        "resources": [
          {
            "type": "course",
            "title": "Type Guards - TypeScript Docs",
            "url": "https://www.typescriptlang.org/docs/handbook/2/narrowing.html#typeof-type-guards"
          }
        ]
      }
    },
    {
      "id": "EDOU5a7UK17yp3PdFBJMc",
      "name": "instanceof",
      "resources": {
        "description": "# instanceof operator\n\nThe `instanceof` operator is a way to narrow down the type of a variable. It is used to check if an object is an instance of a class.\n\n```typescript\nclass Bird {\n  fly() {\n    console.log('flying...');\n  }\n  layEggs() {\n    console.log('laying eggs...');\n  }\n}\n\nconst pet = new Bird();\n\n// instanceof\nif (pet instanceof Bird) {\n  pet.fly();\n} else {\n  console.log('pet is not a bird');\n}\n```\n\nLearn more from the following links:\n\n- [@official@instanceOf Operator](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#instanceof-narrowing)",
        "resources": [
          {
            "type": "course",
            "title": "instanceOf Operator",
            "url": "https://www.typescriptlang.org/docs/handbook/2/narrowing.html#instanceof-narrowing"
          }
        ]
      }
    },
    {
      "id": "ZiOcFZy85p7tLzUkyKDei",
      "name": "typeof",
      "resources": {
        "description": "# typeof Operator\n\nThe `typeof` operator is used to check the type of a variable. It returns a string value representing the type of the variable.\n\n```typescript\nlet value: string | number = 'hello';\n\nif (typeof value === 'string') {\n  console.log('value is a string');\n} else {\n  console.log('value is a number');\n}\n```\n\nLearn more from the following links:\n\n- [@official@Type Guards and Differentiating Types](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#typeof-type-guards)",
        "resources": [
          {
            "type": "course",
            "title": "Type Guards and Differentiating Types",
            "url": "https://www.typescriptlang.org/docs/handbook/2/narrowing.html#typeof-type-guards"
          }
        ]
      }
    },
    {
      "id": "Wy2yIK5vgLjEcc9VjuQK5",
      "name": "Equality",
      "resources": {
        "description": "# Equality\n\nTypeScript also uses switch statements and equality checks like `===`, `!==`, `==`, and `!=` to narrow types. For example:\n\n```typescript\nfunction example(x: string | number, y: string | boolean) {\n  if (x === y) {\n    // We can now call any 'string' method on 'x' or 'y'.\n    x.toUpperCase();\n    y.toLowerCase();\n  } else {\n    console.log(x);\n    console.log(y);\n  }\n}\n```\n\nWhen we checked that `x` and `y` are both equal in the above example, TypeScript knew their types also had to be equal. Since string is the only common type that both `x` and `y` could take on, TypeScript knows that `x` and `y` must be a string in the first branch.\n\nLearn more from the following links:\n\n- [@official@Equality Narrowing](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#equality-narrowing)",
        "resources": [
          {
            "type": "course",
            "title": "Equality Narrowing",
            "url": "https://www.typescriptlang.org/docs/handbook/2/narrowing.html#equality-narrowing"
          }
        ]
      }
    },
    {
      "id": "Xonbxc7MvMEonKBvbkCAH",
      "name": "Truthiness",
      "resources": {
        "description": "# Truthiness\n\nTruthiness might not be a word you’ll find in the dictionary, but it’s very much something you’ll hear about in JavaScript.\n\nIn JavaScript, we can use any expression in conditionals, `&&`s, `||`s, `if` statements, Boolean negations (`!`), and more. As an example, if statements don’t expect their condition to always have the type boolean.\n\n```typescript\nfunction getUsersOnlineMessage(numUsersOnline: number) {\n  if (numUsersOnline) {\n    return `There are ${numUsersOnline} online now!`;\n  }\n\n  return \"Nobody's here. :(\";\n}\n```\n\nLearn more from the following links:\n\n- [@official@Truthiness Narrowing](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#truthiness-narrowing)",
        "resources": [
          {
            "type": "course",
            "title": "Truthiness Narrowing",
            "url": "https://www.typescriptlang.org/docs/handbook/2/narrowing.html#truthiness-narrowing"
          }
        ]
      }
    },
    {
      "id": "1DOSAieOmWUNNsQQrqf2m",
      "name": "Type Predicates",
      "resources": {
        "description": "# Type Predicates\n\nType predicates are functions that return a boolean value. They are used to narrow the type of a variable. Type predicates are used in type guards.\n\n```typescript\nfunction isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\nfunction example(x: unknown) {\n  if (isString(x)) {\n    // We can now call any 'string' method on 'x'.\n    x.toUpperCase();\n  } else {\n    console.log(x);\n  }\n}\n```\n\nLearn more from the following links:\n\n- [@official@Type Guards and Differentiating Types](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates)",
        "resources": [
          {
            "type": "course",
            "title": "Type Guards and Differentiating Types",
            "url": "https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates"
          }
        ]
      }
    },
    {
      "id": "qOynVkDi1gFz0mxyJHjfJ",
      "name": "TypeScript Functions",
      "resources": {
        "description": "# Functions\n\nFunctions are a core building block in TypeScript. Functions allow you to wrap a piece of code and reuse it multiple times. Functions in TypeScript can be either declared using function declaration syntax or function expression syntax.\n\n> Function Declaration Syntax:\n\n```typescript\nfunction name(param1: type1, param2: type2, ...): returnType {\n  return value;\n}\n```\n\n> Function Expression Syntax:\n\n```typescript\nlet name = function(param1: type1, param2: type2, ...): returnType {\n  return value;\n};\n```\n\nLearn more from the following links:\n\n- [@official@Functions in TypeScript](https://www.typescriptlang.org/docs/handbook/2/functions.html)",
        "resources": [
          {
            "type": "course",
            "title": "Functions in TypeScript",
            "url": "https://www.typescriptlang.org/docs/handbook/2/functions.html"
          }
        ]
      }
    },
    {
      "id": "9FIhHwDNzyKpb42NmSv3K",
      "name": "Typing Functions",
      "resources": {
        "description": "# Typing Functions\n\nIn TypeScript, functions can be typed in a few different ways to indicate the input parameters and return type of the function.\n\nFunction declaration with types:\n\n```typescript\nfunction add(a: number, b: number): number {\n  return a + b;\n}\n```\n\nArrow function with types:\n\n```typescript\nconst multiply = (a: number, b: number): number => {\n  return a * b;\n};\n```\n\nFunction type:\n\n```typescript\nlet divide: (a: number, b: number) => number;\n\ndivide = (a, b) => {\n  return a / b;\n};\n```\n\nLearn more from the following links:\n\n- [@official@TypeScript Functions](https://www.typescriptlang.org/docs/handbook/2/functions.html)",
        "resources": [
          {
            "type": "course",
            "title": "TypeScript Functions",
            "url": "https://www.typescriptlang.org/docs/handbook/2/functions.html"
          }
        ]
      }
    },
    {
      "id": "-0Zp6b8NjDyz9MAQE3HfS",
      "name": "Function Overloading",
      "resources": {
        "description": "# Function Overloading\n\nFunction Overloading in TypeScript allows multiple functions with the same name but with different parameters to be defined. The correct function to call is determined based on the number, type, and order of the arguments passed to the function at runtime.\n\n```typescript\nfunction add(a: number, b: number): number;\nfunction add(a: string, b: string): string;\n\nfunction add(a: any, b: any): any {\n  return a + b;\n}\n\nconsole.log(add(1, 2)); // 3\nconsole.log(add('Hello', ' World')); // \"Hello World\"\n```\n\nLearn more from the following links:\n\n- [@official@Function Overloads](https://www.typescriptlang.org/docs/handbook/2/functions.html#function-overloads)",
        "resources": [
          {
            "type": "course",
            "title": "Function Overloads",
            "url": "https://www.typescriptlang.org/docs/handbook/2/functions.html#function-overloads"
          }
        ]
      }
    },
    {
      "id": "aH1DxiG5xrdNlKutJ_gTz",
      "name": "TypeScript Interfaces",
      "resources": {
        "description": "# Interfaces\n\nInterfaces in TypeScript provide a way to define a contract for a type, which includes a set of properties, methods, and events. It's used to enforce a structure for an object, class, or function argument. Interfaces are not transpiled to JavaScript and are only used by TypeScript at compile-time for type-checking purposes.\n\nHere's an example of defining and using an interface in TypeScript:\n\n```typescript\ninterface User {\n  name: string;\n  age: number;\n}\n\nconst user: User = {\n  name: 'John Doe',\n  age: 30,\n};\n```\n\nIn this example, the `User` interface defines the structure of the `user` object with two properties, `name` and `age`. The object is then typed as User using a type-assertion: `User`.\n\nLearn more from the following links:\n\n- [@official@TypeScript - Interfaces](https://www.typescriptlang.org/docs/handbook/2/objects.html)",
        "resources": [
          {
            "type": "course",
            "title": "TypeScript - Interfaces",
            "url": "https://www.typescriptlang.org/docs/handbook/2/objects.html"
          }
        ]
      }
    },
    {
      "id": "TxkEpoOiuUm-fXJuFVKcH",
      "name": "Types vs Interfaces",
      "resources": {
        "description": "# Types vs Interfaces\n\nIn TypeScript, both types and interfaces can be used to define the structure of objects and enforce type checks. However, there are some differences between the two.\n\nTypes are used to create a new named type based on an existing type or to combine existing types into a new type. They can be created using the type keyword. For example:\n\n```typescript\ntype Person = {\n  name: string;\n  age: number;\n};\n\nconst person: Person = {\n  name: 'John Doe',\n  age: 30,\n};\n```\n\nInterfaces, on the other hand, are used to describe the structure of objects and classes. They can be created using the interface keyword. For example:\n\n```typescript\ninterface Person {\n  name: string;\n  age: number;\n}\n\nconst person: Person = {\n  name: 'John Doe',\n  age: 30,\n};\n```\n\nLearn more from the following links:\n\n- [@official@Interfaces vs. Type Aliases](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces)\n- [@article@Interfaces vs Types in TypeScript](https://stackoverflow.com/questions/37233735/interfaces-vs-types-in-typescript)",
        "resources": [
          {
            "type": "course",
            "title": "Interfaces vs. Type Aliases",
            "url": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces"
          },
          {
            "type": "article",
            "title": "Interfaces vs Types in TypeScript",
            "url": "https://stackoverflow.com/questions/37233735/interfaces-vs-types-in-typescript"
          }
        ]
      }
    },
    {
      "id": "O-9WQqidujLIEOTcOfy4n",
      "name": "Extending Interfaces",
      "resources": {
        "description": "# Extending Interfaces\n\nIn TypeScript, you can extend an interface by creating a new interface that inherits from the original interface using the \"extends\" keyword. The new interface can include additional properties, methods, or redefine the members of the original interface.\n\n```typescript\ninterface Shape {\n  width: number;\n  height: number;\n}\n\ninterface Square extends Shape {\n  sideLength: number;\n}\n\nlet square: Square = {\n  width: 10,\n  height: 10,\n  sideLength: 10,\n};\n```\n\nIn this example, the `Square` interface extends the `Shape` interface and adds an additional property `sideLength`. A variable of type `Square` must have all the properties defined in both `Shape` and `Square` interfaces.\n\nLearn more from the following links:\n\n- [@official@Extending Interfaces](https://www.typescriptlang.org/docs/handbook/2/objects.html)",
        "resources": [
          {
            "type": "course",
            "title": "Extending Interfaces",
            "url": "https://www.typescriptlang.org/docs/handbook/2/objects.html"
          }
        ]
      }
    },
    {
      "id": "fY40W8prpgiNqRL50w7ub",
      "name": "Interface Declaration",
      "resources": {
        "description": "# Interface Declaration\n\nAn `interface` in TypeScript is a blueprint for creating objects with specific structure. An `interface` defines a set of properties, methods, and events that a class or object must implement. The interface is a contract between objects and classes and can be used to enforce a specific structure for objects in your code.\n\nHere is an example of an interface declaration in TypeScript:\n\n```typescript\ninterface Person {\n  firstName: string;\n  lastName: string;\n  age?: number;\n\n  getFullName(): string;\n}\n```\n\nIn this example, the Person interface defines four properties: `firstName`, `lastName`, `age`, and a method `getFullName()`. The age property is optional, indicated by the `?` symbol. Any class or object that implements the `Person` interface must have these properties and method.\n\nLearn more from the following links:\n\n- [@official@Extending Interfaces](https://www.typescriptlang.org/docs/handbook/2/objects.html)",
        "resources": [
          {
            "type": "course",
            "title": "Extending Interfaces",
            "url": "https://www.typescriptlang.org/docs/handbook/2/objects.html"
          }
        ]
      }
    },
    {
      "id": "lvtTSHH9yBTCiLng8btnI",
      "name": "Hybrid Types",
      "resources": {
        "description": "# Hybrid Types\n\nIn TypeScript, a hybrid type is a type that combines multiple types into a single type. The resulting type is considered a union of those types. This allows you to specify that a value can have multiple types, rather than just one.\n\nFor example, you can create a hybrid type that can accept either a string or a number:\n\n```typescript\ntype StringOrNumber = string | number;\n```\n\nYou can also use hybrid types to create more complex types that can represent a combination of several different types of values. For example:\n\n```typescript\ntype Education = {\n  degree: string;\n  school: string;\n  year: number;\n};\n\ntype User = {\n  name: string;\n  age: number;\n  email: string;\n  education: Education;\n};\n```",
        "resources": []
      }
    },
    {
      "id": "ib0jfZzukYOZ42AdJqt_W",
      "name": "Classes",
      "resources": {
        "description": "# Classes\n\nClasses in TypeScript are a blueprint for creating objects (instances of a class), providing a way to structure objects and encapsulate data and behavior. Classes in TypeScript have a similar syntax to classes in other object-oriented programming languages, such as Java and C#.\n\nA class in TypeScript is defined using the class keyword, followed by the name of the class. The class definition can include fields (also known as properties or attributes), methods (functions), and a constructor.\n\n```typescript\nclass Animal {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n\n  makeSound(): void {\n    console.log(`${this.name} is making a sound`);\n  }\n}\n\nconst dog = new Animal('Dog');\ndog.makeSound(); // Output: Dog is making a sound\n```\n\nIn this example, the `Animal` class has a name field, a constructor that sets the value of the `name` field, and a `makeSound` method. An instance of the `Animal` class can be created using the `new` keyword, and its methods and properties can be accessed using dot notation.",
        "resources": [
          {
            "type": "course",
            "title": "Tutorial - Classes",
            "url": "https://www.typescriptlang.org/docs/handbook/2/classes.html"
          }
        ]
      }
    },
    {
      "id": "3XrKbK5Od2eoM0BLaS4kU",
      "name": "Constructor Params",
      "resources": {
        "description": "# Constructor Params\n\nIn TypeScript, constructor parameters can be declared with access modifiers (e.g. `public`, `private`, `protected`) and/or type annotations. The parameters are then automatically assigned to properties of the same name within the constructor, and can be accessed within the class. For example:\n\n```typescript\nclass Example {\n  constructor(private name: string, public age: number) {}\n}\n```\n\nIn this example, the constructor has two parameters: name and age. name has a private access modifier, so it can only be accessed within the Example class. age has a public access modifier, so it can be accessed from outside the class as well.\n\nLearn more from the following links:\n\n- [@official@TypeScript - Construct](https://www.typescriptlang.org/docs/handbook/2/classes.html#constructors)",
        "resources": [
          {
            "type": "course",
            "title": "TypeScript - Construct",
            "url": "https://www.typescriptlang.org/docs/handbook/2/classes.html#constructors"
          }
        ]
      }
    },
    {
      "id": "oxzcYXxy2I7GI7nbvFYVa",
      "name": "Constructor Overloading",
      "resources": {
        "description": "# Constructor Overloading\n\nIn TypeScript, you can achieve constructor overloading by using multiple constructor definitions with different parameter lists in a single class. Given below is the example where we have multiple definitions for the constructor:\n\n```typescript\nclass Point {\n  // Overloads\n  constructor(x: number, y: string);\n  constructor(s: string);\n  constructor(xs: any, y?: any) {\n    // TBD\n  }\n}\n```\n\nNote that, similar to function overloading, we only have one implementation of the constructor and it's the only the signature that is overloaded.",
        "resources": [
          {
            "type": "course",
            "title": "Constructors - TypeScript",
            "url": "https://www.typescriptlang.org/docs/handbook/2/classes.html#constructors"
          }
        ]
      }
    },
    {
      "id": "RJ7on8WoxrKcXrR3qY5Rs",
      "name": "Access Modifiers",
      "resources": {
        "description": "# Access Modifiers\n\nIn TypeScript, access modifiers are keywords used to control the visibility and accessibility of class properties and methods. There are three access modifiers in TypeScript:\n\n- `public:` This is the default access modifier. Properties and methods declared as public can be accessed from anywhere, both inside and outside the class.\n- `private:` Properties and methods declared as private can only be accessed within the same class. They are not accessible from outside the class.\n- `protected:` Properties and methods declared as protected can be accessed within the class and its subclasses. They are not accessible from outside the class and its subclasses.\n\nAccess modifiers in TypeScript allow you to define the level of visibility and accessibility of properties and methods in your class, making your code more maintainable and secure.",
        "resources": [
          {
            "type": "course",
            "title": "TypeScript Access Modifiers",
            "url": "https://www.typescripttutorial.net/typescript-tutorial/typescript-access-modifiers/"
          }
        ]
      }
    },
    {
      "id": "tZFWeWHdOUJcCEtHfXH9p",
      "name": "Abstract Classes",
      "resources": {
        "description": "# Abstract Classes\n\nAbstract classes in TypeScript are classes that cannot be instantiated on their own and must be subclassed by other classes. Abstract classes provide a blueprint for other classes and can have abstract methods, which are methods without a body and must be overridden by the subclass. These classes are useful for defining a common interface or basic functionality that other classes can inherit and build upon.\n\n```typescript\nabstract class Animal {\n  abstract makeSound(): void;\n\n  move(): void {\n    console.log('moving...');\n  }\n}\n\nclass Dog extends Animal {\n  makeSound(): void {\n    console.log('bark');\n  }\n}\n```",
        "resources": [
          {
            "type": "course",
            "title": "Abstract Classes",
            "url": "https://www.typescriptlang.org/docs/handbook/2/classes.html#abstract-classes-and-members"
          }
        ]
      }
    },
    {
      "id": "8P0-vb9nlnmz7iC4UvyJZ",
      "name": "Inheritance vs Polymorphism",
      "resources": {
        "description": "# Inheritance vs Polymorphism\n\nInheritance and polymorphism are two fundamental concepts in object-oriented programming, and they are supported in TypeScript as well.\n\nInheritance refers to a mechanism where a subclass inherits properties and methods from its parent class. This allows a subclass to reuse the code and behavior of its parent class while also adding or modifying its own behavior. In TypeScript, inheritance is achieved using the extends keyword.\n\nPolymorphism refers to the ability of an object to take on many forms. This allows objects of different classes to be treated as objects of a common class, as long as they share a common interface or inheritance hierarchy. In TypeScript, polymorphism is achieved through method overriding and method overloading.\n\n```typescript\nclass Animal {\n  makeSound(): void {\n    console.log('Making animal sound');\n  }\n}\n\nclass Dog extends Animal {\n  makeSound(): void {\n    console.log('Bark');\n  }\n}\n\nclass Cat extends Animal {\n  makeSound(): void {\n    console.log('Meow');\n  }\n}\n\nlet animal: Animal;\n\nanimal = new Dog();\nanimal.makeSound(); // Output: Bark\n\nanimal = new Cat();\nanimal.makeSound(); // Output: Meow\n```",
        "resources": [
          {
            "type": "article",
            "title": "Dev.to - Mastering OOP in TypeScript",
            "url": "https://dev.to/rajrathod/mastering-object-oriented-programming-with-typescript-encapsulation-abstraction-inheritance-and-polymorphism-explained-c6p"
          },
          {
            "type": "video",
            "title": "Inheritance and Polymorphism In TypeScript",
            "url": "https://www.youtube.com/watch?v=Sn6K57YSuwU"
          }
        ]
      }
    },
    {
      "id": "aknqutxN2WDQ4RFcT-szM",
      "name": "Method Overriding",
      "resources": {
        "description": "# Method Overriding\n\nIn TypeScript, method overriding is a mechanism where a subclass provides a new implementation for a method that is already defined in its parent class. This allows the subclass to inherit the behavior of the parent class, but change its behavior to fit its own needs.\n\nTo override a method in TypeScript the signature of the method in the subclass must match exactly with the signature of the method in the parent class.\n\n```typescript\nclass Animal {\n  makeSound(): void {\n    console.log('Making animal sound');\n  }\n}\n\nclass Dog extends Animal {\n  makeSound(): void {\n    console.log('Bark');\n  }\n}\n\nlet animal: Animal;\n\nanimal = new Dog();\nanimal.makeSound(); // Output: Bark\n```\n\nIn this example, the `Dog` class overrides the makeSound method defined in the Animal class and provides its own implementation. When the `makeSound` method is called on an instance of the `Dog` class, it will use the implementation in the `Dog` class rather than the implementation in the `Animal` class.",
        "resources": [
          {
            "type": "course",
            "title": "TypeScript - Overriding Methods",
            "url": "https://www.typescriptlang.org/docs/handbook/2/classes.html#overriding-methods"
          }
        ]
      }
    },
    {
      "id": "4gaKqNtGLFqpk9WVKZl0v",
      "name": "Generics",
      "resources": {
        "description": "# Generics\n\nGenerics in TypeScript are a way to write code that can work with multiple data types, instead of being limited to a single data type. Generics allow you to write functions, classes, and interfaces that take one or more type parameters, which act as placeholders for the actual data types that will be used when the function, class, or interface is used.\n\nFor example, the following is a generic function that takes a single argument of any data type and returns the same data type:\n\n```typescript\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n\nlet output = identity<string>('Hello'); // type of output will be 'string'\n```\n\nIn this example, the `identity` function takes a single argument of any data type and returns the same data type. The actual data type is specified when the function is called by using `<string>` before the argument `\"Hello\"`.",
        "resources": [
          {
            "type": "course",
            "title": "Hello World of Generics",
            "url": "https://www.typescriptlang.org/docs/handbook/2/generics.html#hello-world-of-generics"
          }
        ]
      }
    },
    {
      "id": "T2-VAVfntouJOoWHpHZ3n",
      "name": "Generic Types",
      "resources": {
        "description": "# Generic Types\n\nGeneric types in TypeScript allow you to write objects, functions and classes that work with multiple data types, instead of being limited to a single data type. A generic type is defined using angle brackets `<T>` and can be used as a placeholder for a specific data type. The actual data type is specified when the function or class is used.\n\nFor example, the following is a generic function that takes a single argument of any data type and returns the same data type:\n\n```typescript\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n\nlet output = identity<string>('Hello'); // type of output will be 'string'\n```\n\nIn this example, the `identity` function takes a single argument of any data type and returns the same data type. The actual data type is specified when the function is called by using `<string>` before the argument `Hello`.\n\nGenerics can also be used with classes, interfaces, and object types, allowing them to work with multiple data types as well.\n\nFor example:\n\n```typescript\nclass GenericNumber<T> {\n  zeroValue: T;\n  add: (x: T, y: T) => T;\n}\n\nlet myGenericNumber = new GenericNumber<number>();\nmyGenericNumber.zeroValue = 0;\nmyGenericNumber.add = function (x, y) {\n  return x + y;\n};\n```",
        "resources": [
          {
            "type": "course",
            "title": "Hello World of Generics",
            "url": "https://www.typescriptlang.org/docs/handbook/2/generics.html#hello-world-of-generics"
          }
        ]
      }
    },
    {
      "id": "0NXHAOUYGIwuPwlN7r_B3",
      "name": "Generic Constraints",
      "resources": {
        "description": "# Generic Constraints\n\nGeneric constraints in TypeScript allow you to specify the requirements for the type parameters used in a generic type. These constraints ensure that the type parameter used in a generic type meets certain requirements.\n\nConstraints are specified using the `extends` keyword, followed by the type that the type parameter must extend or implement.\n\n```typescript\ninterface Lengthwise {\n  length: number;\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n  // Now we know it has a .length property, so no more error\n  console.log(arg.length);\n\n  return arg;\n}\n\nloggingIdentity(3); // Error, number doesn't have a .length property\nloggingIdentity({ length: 10, value: 3 }); // OK\n```\n\nIn this example, the `Lengthwise` interface defines a `length` property. The `loggingIdentity` function uses a generic type parameter `T` that is constrained by the `Lengthwise` interface, meaning that the type parameter must extend or implement the `Lengthwise` interface. This constraint ensures that the length property is available on the argument passed to the `loggingIdentity` function.",
        "resources": [
          {
            "type": "course",
            "title": "Generic Constraints - TypeScript",
            "url": "https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints"
          }
        ]
      }
    },
    {
      "id": "TRx3wvWnRdJJf5eL-GBG4",
      "name": "Decorators",
      "resources": {
        "description": "# Decorators\n\nDecorators are a feature of TypeScript that allow you to modify the behavior of a class, property, method, or parameter. They are a way to add additional functionality to existing code, and they can be used for a wide range of tasks, including logging, performance optimization, and validation.\n\nHere's an example of how you might use a decorator in TypeScript:\n\n```typescript\nfunction log(\n  target: Object,\n  propertyKey: string | symbol,\n  descriptor: PropertyDescriptor\n) {\n  const originalMethod = descriptor.value;\n\n  descriptor.value = function (...args: any[]) {\n    console.log(`Calling ${propertyKey} with arguments: ${args}`);\n    return originalMethod.apply(this, args);\n  };\n\n  return descriptor;\n}\n\nclass Calculator {\n  @log\n  add(a: number, b: number): number {\n    return a + b;\n  }\n}\n\nconst calculator = new Calculator();\ncalculator.add(1, 2);\n// Output: Calling add with arguments: 1,2\n// Output: 3\n```\n\nIn this example, we use the `@log` decorator to modify the behavior of the `add` method in the `Calculator` class. The `log` decorator logs the arguments passed to the method before calling the original method. This allows us to see what arguments are being passed to the method, without having to modify the method's code.\n\nLearn more from the following links:\n\n- [@official@Decorators](https://www.typescriptlang.org/docs/handbook/decorators.html#handbook-content)",
        "resources": [
          {
            "type": "course",
            "title": "Decorators",
            "url": "https://www.typescriptlang.org/docs/handbook/decorators.html#handbook-content"
          }
        ]
      }
    },
    {
      "id": "LSwUHfalnk5MgHt21PANb",
      "name": "Utility Types",
      "resources": {
        "description": "# Utility Types\n\nTypeScript provides several utility types that can be used to manipulate and transform existing types. Here are some of the most common ones:\n\n- `Partial`: makes all properties of a type optional.\n- `Readonly`: makes all properties of a type read-only.\n- `Pick`: allows you to pick specific properties from a type.\n- `Omit`: allows you to omit specific properties from a type.\n- `Exclude`: creates a type that is the set difference of A and B.\n- ..and more.\n\nLearn more from the following links:\n\n- [@official@TypeScript - Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)\n- [@article@TypeScript Utility Types Guide](https://camchenry.com/blog/typescript-utility-types)",
        "resources": [
          {
            "type": "course",
            "title": "TypeScript - Utility Types",
            "url": "https://www.typescriptlang.org/docs/handbook/utility-types.html"
          },
          {
            "type": "article",
            "title": "TypeScript Utility Types Guide",
            "url": "https://camchenry.com/blog/typescript-utility-types"
          }
        ]
      }
    },
    {
      "id": "gBTem9Dp3IQLAkqGX4fOF",
      "name": "Partial",
      "resources": {
        "description": "# Partial\n\nThe Partial type in TypeScript allows you to make all properties of a type optional. This is useful when you need to create an object with only a subset of the properties of an existing type.\n\nHere's an example of using the Partial type in TypeScript:\n\n```typescript\ninterface User {\n  name: string;\n  age: number;\n  email: string;\n}\n\nfunction createUser(user: Partial<User>): User {\n  return {\n    name: 'John Doe',\n    age: 30,\n    email: 'john.doe@example.com',\n    ...user,\n  };\n}\n\nconst newUser = createUser({ name: 'Jane Doe' });\n\nconsole.log(newUser);\n// Output: { name: 'Jane Doe', age: 30, email: 'john.doe@example.com' }\n```\n\nLearn more from the following links:\n\n- [@official@Partial<Type>](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype)",
        "resources": [
          {
            "type": "course",
            "title": "Partial<Type>",
            "url": "https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype"
          }
        ]
      }
    },
    {
      "id": "E88tHQvARkHURZwGaO02l",
      "name": "Pick",
      "resources": {
        "description": "# Pick\n\nPick constructs a type by picking the set of properties Keys (string literal or union of string literals) from Type.\n\n```typescript\ninterface Todo {\n  title: string;\n  description: string;\n  completed: boolean;\n}\n\ntype TodoPreview = Pick<Todo, 'title' | 'completed'>;\n\nconst todo: TodoPreview = {\n  title: 'Clean room',\n  completed: false,\n};\n```\n\nLearn more from the following links:\n\n- [@official@Pick<Type, Keys>](https://www.typescriptlang.org/docs/handbook/utility-types.html#picktype-keys)",
        "resources": [
          {
            "type": "course",
            "title": "Pick<Type, Keys>",
            "url": "https://www.typescriptlang.org/docs/handbook/utility-types.html#picktype-keys"
          }
        ]
      }
    },
    {
      "id": "yjlxygHl8QONNUrdx-Q0A",
      "name": "Omit",
      "resources": {
        "description": "# Omit\n\nOmit constructs a type by picking all properties from Type and then removing Keys (string literal or union of string literals).\n\n```typescript\ninterface Todo {\n  title: string;\n  description: string;\n  completed: boolean;\n  createdAt: number;\n}\n\ntype TodoPreview = Omit<Todo, 'description'>;\n\nconst todo: TodoPreview = {\n  title: 'Clean room',\n  completed: false,\n  createdAt: 1615544252770,\n};\n\ntype TodoInfo = Omit<Todo, 'completed' | 'createdAt'>;\n\nconst todoInfo: TodoInfo = {\n  title: 'Pick up kids',\n  description: 'Kindergarten closes at 5pm',\n};\n```\n\nLearn more from the following links:\n\n- [@official@Omit<Type, Keys>](https://www.typescriptlang.org/docs/handbook/utility-types.html#omittype-keys)",
        "resources": [
          {
            "type": "course",
            "title": "Omit<Type, Keys>",
            "url": "https://www.typescriptlang.org/docs/handbook/utility-types.html#omittype-keys"
          }
        ]
      }
    },
    {
      "id": "IuO9-O_DQdDYuAbdGWdgb",
      "name": "Readonly",
      "resources": {
        "description": "# Readonly\n\nReadonly constructs a type with all properties of Type set to readonly, meaning the properties of the constructed type cannot be reassigned.\n\n```typescript\ninterface Todo {\n  title: string;\n}\n\nconst todo: Readonly<Todo> = {\n  title: 'Delete inactive users',\n};\n\n// Cannot assign to 'title' because it is a read-only property.\ntodo.title = 'Hello';\n```\n\nLearn more from the following links:\n\n- [@official@Readonly<Type>](https://www.typescriptlang.org/docs/handbook/utility-types.html#readonlytype)",
        "resources": [
          {
            "type": "course",
            "title": "Readonly<Type>",
            "url": "https://www.typescriptlang.org/docs/handbook/utility-types.html#readonlytype"
          }
        ]
      }
    },
    {
      "id": "DRdBmF5Dt_r09LoPOxOuq",
      "name": "Record",
      "resources": {
        "description": "# Record\n\nRecord constructs an object type whose property keys are Keys and whose property values are Type. This utility can be used to map the properties of a type to another type.\n\n```typescript\ninterface CatInfo {\n  age: number;\n  breed: string;\n}\n\ntype CatName = 'miffy' | 'boris' | 'mordred';\n\nconst cats: Record<CatName, CatInfo> = {\n  miffy: { age: 10, breed: 'Persian' },\n  boris: { age: 5, breed: 'Maine Coon' },\n  mordred: { age: 16, breed: 'British Shorthair' },\n};\n```\n\nLearn more from the following links:\n\n- [@official@Record<Keys, Type>](https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type)",
        "resources": [
          {
            "type": "course",
            "title": "Record<Keys, Type>",
            "url": "https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type"
          }
        ]
      }
    },
    {
      "id": "0fvOXi9gJbEc7etqTggNE",
      "name": "Exclude",
      "resources": {
        "description": "# Exclude\n\nExclude constructs a type by excluding from UnionType all union members that are assignable to ExcludedMembers.\n\n```typescript\ntype T0 = Exclude<'a' | 'b' | 'c', 'a'>; // \"b\" | \"c\"\ntype T1 = Exclude<'a' | 'b' | 'c', 'a' | 'b'>; // \"c\"\ntype T2 = Exclude<string | number | (() => void), Function>; // string | number\n```\n\nLearn more from the following links:\n\n- [@official@Exclude<UnionType, ExcludedMembers>](https://www.typescriptlang.org/docs/handbook/utility-types.html#excludeuniontype-excludedmembers)",
        "resources": [
          {
            "type": "course",
            "title": "Exclude<UnionType, ExcludedMembers>",
            "url": "https://www.typescriptlang.org/docs/handbook/utility-types.html#excludeuniontype-excludedmembers"
          }
        ]
      }
    },
    {
      "id": "IIAbAzXiVQm1JEi2MTMZN",
      "name": "Extract",
      "resources": {
        "description": "# Extract\n\nExtract constructs a type by extracting from Type all union members that are assignable to Union.\n\n```typescript\ntype T0 = Extract<'a' | 'b' | 'c', 'a' | 'f'>;\n//    ^ = type T0 = \"a\"\n```\n\nLearn more from the following links:\n\n- [@official@Extract<Type, Union>](https://www.typescriptlang.org/docs/handbook/utility-types.html#extracttype-union)",
        "resources": [
          {
            "type": "course",
            "title": "Extract<Type, Union>",
            "url": "https://www.typescriptlang.org/docs/handbook/utility-types.html#extracttype-union"
          }
        ]
      }
    },
    {
      "id": "_BAZlBEzE7ddr315OeHvl",
      "name": "NonNullable",
      "resources": {
        "description": "# Non Nullable\n\nNon-Nullable constructs a type by excluding `null` and `undefined` from Type.\n\n```typescript\ntype T0 = NonNullable<string | number | undefined>;\n// type T0 = string | number\n\ntype T1 = NonNullable<string[] | null | undefined>;\n// type T1 = string[]\n```\n\nLearn more from the following links:\n\n- [@official@NonNullable<Type>](https://www.typescriptlang.org/docs/handbook/utility-types.html#nonnullabletype)",
        "resources": [
          {
            "type": "course",
            "title": "NonNullable<Type>",
            "url": "https://www.typescriptlang.org/docs/handbook/utility-types.html#nonnullabletype"
          }
        ]
      }
    },
    {
      "id": "a7hl0iMZ-jcUACxqIYVqv",
      "name": "Parameters",
      "resources": {
        "description": "# Parameters\n\nParameters constructs a tuple type from the types used in the parameters of a function type Type.\n\n```typescript\ntype T0 = Parameters<() => string>;\n// type T0 = []\n\ntype T1 = Parameters<(s: string) => void>;\n// type T1 = [s: string]\n\ntype T2 = Parameters<<T>(arg: T) => T>;\n// type T2 = [arg: unknown]\n\ndeclare function f1(arg: { a: number; b: string }): void;\ntype T3 = Parameters<typeof f1>;\n// type T3 = [arg: {\n//     a: number;\n//     b: string;\n// }]\n\ntype T4 = Parameters<any>;\n// type T4 = unknown[]\n\ntype T5 = Parameters<never>;\n// type T5 = never\n\ntype T6 = Parameters<string>;\n// ^ Type 'string' does not satisfy the constraint '(...args: any) => any'.\n\ntype T7 = Parameters<Function>;\n// ^ Type 'Function' does not satisfy the constraint '(...args: any) => any'.\n```\n\nLearn more from the following links:\n\n- [@official@Parameters<Type>](https://www.typescriptlang.org/docs/handbook/utility-types.html#parameterstype)",
        "resources": [
          {
            "type": "course",
            "title": "Parameters<Type>",
            "url": "https://www.typescriptlang.org/docs/handbook/utility-types.html#parameterstype"
          }
        ]
      }
    },
    {
      "id": "On75JR_UkiIlha0_qaSeu",
      "name": "ReturnType",
      "resources": {
        "description": "# ReturnType\n\nReturn type constructs a type consisting of the return type of function Type.\n\n```typescript\ntype T0 = ReturnType<() => string>;\n// type T0 = string\n\ntype T1 = ReturnType<(s: string) => void>;\n// type T1 = void\n\ntype T2 = ReturnType<<T>() => T>;\n// type T2 = unknown\n\ntype T3 = ReturnType<<T extends U, U extends number[]>() => T>;\n// type T3 = number[]\n\ndeclare function f1(): { a: number; b: string };\ntype T4 = ReturnType<typeof f1>;\n// type T4 = {\n//     a: number;\n//     b: string;\n// }\n\ntype T5 = ReturnType<any>;\n// type T5 = any\n\ntype T6 = ReturnType<never>;\n// type T6 = never\n\ntype T7 = ReturnType<string>;\n// ^ Type 'string' does not satisfy the constraint '(...args: any) => any'.\n\ntype T8 = ReturnType<Function>;\n// ^ Type 'Function' does not satisfy the constraint '(...args: any) => any'.\n```\n\nLearn more from the following links:\n\n- [@official@ReturnType<Type>](https://www.typescriptlang.org/docs/handbook/utility-types.html#returntypetype)",
        "resources": [
          {
            "type": "course",
            "title": "ReturnType<Type>",
            "url": "https://www.typescriptlang.org/docs/handbook/utility-types.html#returntypetype"
          }
        ]
      }
    },
    {
      "id": "izGAjNtrh3BzQt3KiZX0W",
      "name": "InstanceType",
      "resources": {
        "description": "# InstanceType\n\nThis type constructs a type consisting of the instance type of a constructor function in Type.\n\n```typescript\nclass C {\n  x = 0;\n  y = 0;\n}\n\ntype T0 = InstanceType<typeof C>;\n// type T0 = C\n\ntype T1 = InstanceType<any>;\n// type T1 = any\n\ntype T2 = InstanceType<never>;\n// type T2 = never\n\ntype T3 = InstanceType<string>;\n// ^ Type 'string' does not satisfy the constraint 'abstract new (...args: any) => any'.\n\ntype T4 = InstanceType<Function>;\n// ^ Type 'Function' does not satisfy the constraint 'abstract new (...args: any) => any'.\n```\n\nLearn more from the following links:\n\n- [@official@InstanceType`<Type>`](https://www.typescriptlang.org/docs/handbook/utility-types.html#instancetypetype)",
        "resources": [
          {
            "type": "course",
            "title": "InstanceType`<Type>`",
            "url": "https://www.typescriptlang.org/docs/handbook/utility-types.html#instancetypetype"
          }
        ]
      }
    },
    {
      "id": "aEhI_9mFWXRIZh1ZxTuzu",
      "name": "Awaited",
      "resources": {
        "description": "# Awaited\n\nThis type is meant to model operations like await in async functions, or the `.then()` method on Promises - specifically, the way that they recursively unwrap Promises.\n\n```typescript\ntype A = Awaited<Promise<string>>;\n// type A = string\n\ntype B = Awaited<Promise<Promise<number>>>;\n// type B = number\n\ntype C = Awaited<boolean | Promise<number>>;\n// type C = number | boolean\n```\n\nLearn more from the following links:\n\n- [@official@Awaited`<Type>`](https://www.typescriptlang.org/docs/handbook/utility-types.html#awaitedtype)",
        "resources": [
          {
            "type": "course",
            "title": "Awaited`<Type>`",
            "url": "https://www.typescriptlang.org/docs/handbook/utility-types.html#awaitedtype"
          }
        ]
      }
    },
    {
      "id": "2F7vOL__v9dLBohA263aj",
      "name": "Advanced Types",
      "resources": {
        "description": "# Advanced Types\n\nAdvanced types in TypeScript are a set of advanced type constructs that allow for more complex and expressive type systems. Some of the most commonly used advanced types in TypeScript include:\n\n- Intersection Types\n- Union Types\n- Type Aliases\n- Conditional Types\n- Index Types\n- Mapped Types\n- Type Guards\n\nThese advanced types allow for more complex and expressive type systems, and enable you to write code that is safer, more maintainable, and easier to understand. By leveraging these advanced types, you can write code that is more robust, less prone to errors, and easier to maintain.\n\nLearn more from the following links:\n\n- [@official@Advanced Topics](https://www.typescriptlang.org/docs/handbook/type-compatibility.html#advanced-topics)\n- [@video@Tutorial of Typescript - Advanced Types](https://www.youtube.com/playlist?list=PLw5h0DiJ-9PBIgIyd2ZA1CVnJf0BLFJg2)",
        "resources": [
          {
            "type": "course",
            "title": "Advanced Topics",
            "url": "https://www.typescriptlang.org/docs/handbook/type-compatibility.html#advanced-topics"
          },
          {
            "type": "video",
            "title": "Tutorial of Typescript - Advanced Types",
            "url": "https://www.youtube.com/playlist?list=PLw5h0DiJ-9PBIgIyd2ZA1CVnJf0BLFJg2"
          }
        ]
      }
    },
    {
      "id": "VQ-V9qIdKgnpSJg2UnpuB",
      "name": "Mapped Types",
      "resources": {
        "description": "# Mapped Types\n\nMapped types in TypeScript are a way to create a new type based on an existing type, where each property of the existing type is transformed in some way. Mapped types are declared using a combination of the `keyof` operator and a type that maps each property of the existing type to a new property type.\n\nFor example, the following is a mapped type that takes an object type and creates a new type with all properties of the original type but with their type changed to `readonly`:\n\n```typescript\ntype Readonly<T> = {\n  readonly [P in keyof T]: T[P];\n};\n\nlet obj = { x: 10, y: 20 };\nlet readonlyObj: Readonly<typeof obj> = obj;\n```\n\nIn this example, the `Readonly` mapped type takes an object type `T` and creates a new type with all properties of `T` but with their type changed to `readonly`. The keyof `T` operator is used to extract the names of the properties of `T`, and the `T[P]` syntax is used to access the type of each property of `T`. The `readonly` keyword is used to make the properties of the new type `readonly`.\n\nLearn more from the following links:\n\n- [@official@Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#handbook-content)",
        "resources": [
          {
            "type": "course",
            "title": "Mapped Types",
            "url": "https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#handbook-content"
          }
        ]
      }
    },
    {
      "id": "ubGIhi-WLE0EopTYXzmPL",
      "name": "Conditional Types",
      "resources": {
        "description": "# Conditional Types\n\nConditional types in TypeScript are a way to select a type based on a condition. They allow you to write a type that dynamically chooses a type based on the types of its inputs. Conditional types are declared using a combination of the `infer` keyword and a type that tests a condition and selects a type based on the result of the test.\n\nFor example, the following is a conditional type that takes two types and returns the type of the first argument if it extends the second argument, and the type of the second argument otherwise:\n\n```typescript\ntype Extends<T, U> = T extends U ? T : U;\n\ntype A = Extends<string, any>; // type A is 'string'\ntype B = Extends<any, string>; // type B is 'string'\n```\n\nIn this example, the Extends conditional type takes two types T and U and returns the type of the first argument `T` if it extends the second argument `U`, and the type of the second argument `U` otherwise. The T extends `U` syntax is used to test whether `T extends U`, and the `? T : U` syntax is used to select the type `T` if the test passes and the type `U` otherwise.\n\nLearn more from the following links:\n\n- [@official@Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#handbook-content)\n- [@video@Conditional Types - Advanced TypeScript](https://www.youtube.com/watch?v=QFWrbNehKk0)",
        "resources": [
          {
            "type": "course",
            "title": "Conditional Types",
            "url": "https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#handbook-content"
          },
          {
            "type": "video",
            "title": "Conditional Types - Advanced TypeScript",
            "url": "https://www.youtube.com/watch?v=QFWrbNehKk0"
          }
        ]
      }
    },
    {
      "id": "CWzGwvl6NwYCaLYSLIjqQ",
      "name": "Literal Types",
      "resources": {
        "description": "# Literal Types\n\nLiteral types in TypeScript are a way to specify a value exactly, rather than just a type. Literal types can be used to enforce that a value must be of a specific type and a specific value. Literal types are created by using a literal value, such as a string, number, or boolean, as a type.\n\nFor example, the following is a literal type that represents a value of 42:\n\n```typescript\ntype Age = 42;\n\nlet age: Age = 42; // ok\nlet age: Age = 43; // error\n```\n\nIn this example, the `Age` literal type is created by using the number `42` as a type. This type can then be used to enforce that a value must be of type `number` and have the value `42`.\n\nLearn more from the following links:\n\n- [@official@Literal Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types)",
        "resources": [
          {
            "type": "course",
            "title": "Literal Types",
            "url": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types"
          }
        ]
      }
    },
    {
      "id": "xP25nGw42VqdfZ_9pDMXd",
      "name": "Template Literal Types",
      "resources": {
        "description": "# Template Literal Types\n\nTemplate literal types in TypeScript are a way to manipulate string values as types. They allow you to create a type based on the result of string manipulation or concatenation. Template literal types are created using the backtick (``) character and string manipulation expressions within the type.\n\nFor example, the following is a template literal type that concatenates two strings:\n\n```typescript\ntype Name = `Mr. ${string}`;\n\nlet name: Name = `Mr. Smith`;  // ok\nlet name: Name = `Mrs. Smith`;  // error\n```\n\nIn this example, the `Name` template literal type is created by concatenating the string `\"Mr. \"` with the type `string`. This type can then be used to enforce that a value must be a string that starts with `\"Mr. \"`.\n\nLearn more from the following links:\n\n- [@official@Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#handbook-content)",
        "resources": [
          {
            "type": "course",
            "title": "Template Literal Types",
            "url": "https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#handbook-content"
          }
        ]
      }
    },
    {
      "id": "N8xBTJ74xv1E5hSLYZtze",
      "name": "Recursive Types",
      "resources": {
        "description": "# Recursive Types\n\nRecursive types in TypeScript are a way to define a type that references itself. Recursive types are used to define complex data structures, such as trees or linked lists, where a value can contain one or more values of the same type.\n\nFor example, the following is a recursive type that represents a linked list:\n\n```typescript\ntype LinkedList<T> = {\n  value: T;\n  next: LinkedList<T> | null;\n};\n\nlet list: LinkedList<number> = {\n  value: 1,\n  next: { value: 2, next: { value: 3, next: null } },\n};\n```\n\nIn this example, the `LinkedList` type is defined as a type that extends `T` and contains a property `next` of the same type `LinkedList<T>`. This allows us to create a linked list where each node contains a value of type `T` and a reference to the next node in the list.\n\nLearn more from the following links:\n\n- [@official@Recursive Types in TypeScript](https://www.typescriptlang.org/play/3-7/types-and-code-flow/recursive-type-references.ts.html)",
        "resources": [
          {
            "type": "course",
            "title": "Recursive Types in TypeScript",
            "url": "https://www.typescriptlang.org/play/3-7/types-and-code-flow/recursive-type-references.ts.html"
          }
        ]
      }
    },
    {
      "id": "sE9lqkkqwnsVJxTJv37YZ",
      "name": "TypeScript Modules",
      "resources": {
        "description": "# Modules\n\nIn TypeScript, modules are used to organize and reuse code. There are two types of modules in TypeScript:\n\n- Internal\n- External\n\nInternal modules are used to organize code within a file and are also referred to as namespaces. They are defined using the \"namespace\" keyword.\n\nExternal modules are used to organize code across multiple files. They are defined using the \"export\" keyword in one file and the \"import\" keyword in another file. External modules in TypeScript follow the CommonJS or ES modules standards.\n\nHere is an example of how you can use internal modules in TypeScript:\n\n```typescript\n// myModule.ts\nnamespace MyModule {\n  export function doSomething() {\n    console.log('Doing something...');\n  }\n}\n\n// main.ts\n/// <reference path=\"myModule.ts\" />\nMyModule.doSomething(); // Output: \"Doing something...\"\n```\n\nLearn more from the following links:\n\n- [@official@Modules](https://www.typescriptlang.org/docs/handbook/modules.html#handbook-content)\n- [@video@TypeScript - Modules](https://www.youtube.com/watch?v=EpOPR03z4Vw)",
        "resources": [
          {
            "type": "course",
            "title": "Modules",
            "url": "https://www.typescriptlang.org/docs/handbook/modules.html#handbook-content"
          },
          {
            "type": "video",
            "title": "TypeScript - Modules",
            "url": "https://www.youtube.com/watch?v=EpOPR03z4Vw"
          }
        ]
      }
    },
    {
      "id": "EtVwQ4lnWi3IIFHGb2Qib",
      "name": "Namespaces",
      "resources": {
        "description": "# Namespaces\n\nIn TypeScript, namespaces are used to organize and share code across multiple files. Namespaces allow you to group related functionality into a single unit and prevent naming conflicts.\n\nHere's an example of how you can use namespaces in TypeScript:\n\n```typescript\n// myNamespace.ts\nnamespace MyNamespace {\n  export function doSomething() {\n    console.log('Doing something...');\n  }\n}\n\n// main.ts\n/// <reference path=\"myNamespace.ts\" />\nMyNamespace.doSomething(); // Output: \"Doing something...\"\n```\n\nIn this example, we use the `namespace` keyword in the \"myNamespace.ts\" file to define a namespace \"MyNamespace\". Within the namespace, we export a function \"doSomething\".",
        "resources": [
          {
            "type": "course",
            "title": "Overview of Namespaces",
            "url": "https://www.typescriptlang.org/docs/handbook/namespaces.html"
          },
          {
            "type": "course",
            "title": "Namespaces and Modules",
            "url": "https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html"
          },
          {
            "type": "course",
            "title": "TypeScript - Using Namespaces",
            "url": "https://typescriptlang.org/docs/handbook/namespaces-and-modules.html#using-namespaces"
          }
        ]
      }
    },
    {
      "id": "k_5y77k8ZZ9_O2WpWXWTY",
      "name": "Ambient Modules",
      "resources": {
        "description": "# Ambient Modules\n\nAmbient modules in TypeScript are used to declare external modules or third-party libraries in a TypeScript program. Ambient modules provide type information for modules that have no TypeScript declarations, but are available in the global scope.\n\nHere's an example of how you can use ambient modules in TypeScript:\n\n```typescript\n// myModule.d.ts\ndeclare module 'my-module' {\n  export function doSomething(): void;\n}\n\n// main.ts\nimport * as myModule from 'my-module';\nmyModule.doSomething();\n```\n\nIn this example, we declare an ambient module \"my-module\" in the `myModule.d.ts` file. This declaration provides type information for the \"my-module\" module, including the \"doSomething\" function that is exported from the module.\n\nLearn more from the following links:\n\n- [@official@Ambient Modules](https://www.typescriptlang.org/docs/handbook/modules/reference.html#ambient-modules)",
        "resources": [
          {
            "type": "course",
            "title": "Ambient Modules",
            "url": "https://www.typescriptlang.org/docs/handbook/modules/reference.html#ambient-modules"
          }
        ]
      }
    },
    {
      "id": "egQWk1n3p8Pep83yIwCtI",
      "name": "External Modules",
      "resources": {
        "description": "# External Modules\n\nIn TypeScript, external modules allow you to organize and share code across multiple files. External modules in TypeScript follow the CommonJS or ES modules standards.\n\nHere's an example of how you can use external modules in TypeScript:\n\n```typescript\n// myModule.ts\nexport function doSomething() {\n  console.log('Doing something...');\n}\n\n// main.ts\nimport { doSomething } from './myModule';\ndoSomething(); // Output: \"Doing something...\"\n```\n\nIn this example, we use the \"export\" keyword in the \"myModule.ts\" file to export the \"doSomething\" function, making it available for other files to use.\n\nLearn more from the following links:\n\n- [@article@TypeScript - External Module](https://learncodeweb.com/typescript/modules-in-typescript-explain-with-an-example/)",
        "resources": [
          {
            "type": "article",
            "title": "TypeScript - External Module",
            "url": "https://learncodeweb.com/typescript/modules-in-typescript-explain-with-an-example/"
          }
        ]
      }
    },
    {
      "id": "16TT8R4N-9tCfWmPetqMP",
      "name": "Namespace Augmentation",
      "resources": {
        "description": "# Namespace Augmentation\n\nIn TypeScript, namespace augmentation is a way to extend or modify existing namespaces. This is useful when you want to add new functionality to existing namespaces or to fix missing or incorrect declarations in third-party libraries.\n\nHere's an example of how you can use namespace augmentation in TypeScript:\n\n```typescript\n// myModule.d.ts\ndeclare namespace MyModule {\n  export interface MyModule {\n    newFunction(): void;\n  }\n}\n\n// main.ts\n/// <reference path=\"myModule.d.ts\" />\nnamespace MyModule {\n  export class MyModule {\n    public newFunction() {\n      console.log('I am a new function in MyModule!');\n    }\n  }\n}\n\nconst obj = new MyModule.MyModule();\nobj.newFunction(); // Output: \"I am a new function in MyModule!\"\n```\n\nIn this example, we use namespace augmentation to add a new function \"newFunction\" to the \"MyModule\" namespace. This is done in the declaration file `myModule.d.ts` by declaring a new interface \"MyModule\" within the \"MyModule\" namespace and adding the \"newFunction\" function to it.\n\nLearn more from the following links:\n\n- [@official@Module Augmentation](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation)",
        "resources": [
          {
            "type": "course",
            "title": "Module Augmentation",
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation"
          }
        ]
      }
    },
    {
      "id": "JQwWeB1gkANSYfQmH69Bs",
      "name": "Global Augmentation",
      "resources": {
        "description": "# Global Augmentation\n\nIn TypeScript, global augmentation is a way to add declarations to the global scope. This is useful when you want to add new functionality to existing libraries or to augment the built-in types in TypeScript.\n\nHere's an example of how you can use global augmentation in TypeScript:\n\n```typescript\n// myModule.d.ts\ndeclare namespace NodeJS {\n  interface Global {\n    myGlobalFunction(): void;\n  }\n}\n\n// main.ts\nglobal.myGlobalFunction = function () {\n  console.log('I am a global function!');\n};\n\nmyGlobalFunction(); // Output: \"I am a global function!\"\n```\n\nIn this example, we declare a new namespace \"NodeJS\" and add an interface \"Global\" to it. Within the \"Global\" interface, we declare a new function \"myGlobalFunction\".\n\nLearn more from the following links:\n\n- [@official@Global augmentation](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#global-augmentation)",
        "resources": [
          {
            "type": "course",
            "title": "Global augmentation",
            "url": "https://www.typescriptlang.org/docs/handbook/declaration-merging.html#global-augmentation"
          }
        ]
      }
    },
    {
      "id": "RqZaWGxxNRItBhVwWKysc",
      "name": "Ecosystem",
      "resources": {
        "description": "# Ecosystem\n\nHave a look at the linked nodes for different tools and frameworks that you can use to build your projects.",
        "resources": []
      }
    },
    {
      "id": "fU8Vnw1DobM4iXl1Tq6EK",
      "name": "Formatting",
      "resources": {
        "description": "# Formatting\n\nPrettier is an opinionated code formatter with support for JavaScript, HTML, CSS, YAML, Markdown, GraphQL Schemas. By far the biggest reason for adopting Prettier is to stop all the on-going debates over styles. Biome is a faster alternative to Prettier! (It also does linting!)",
        "resources": [
          {
            "type": "article",
            "title": "Prettier Website",
            "url": "https://prettier.io"
          },
          {
            "type": "article",
            "title": "Why Prettier",
            "url": "https://prettier.io/docs/en/why-prettier.html"
          },
          {
            "type": "article",
            "title": "BiomeJS Website",
            "url": "https://biomejs.dev"
          }
        ]
      }
    },
    {
      "id": "8PcAPOrKisKRYPWamz4nV",
      "name": "Linting",
      "resources": {
        "description": "# Linting\n\nWith ESLint you can impose the coding standard using a certain set of standalone rules.",
        "resources": [
          {
            "type": "article",
            "title": "ESLint Official Website",
            "url": "https://eslint.org/"
          },
          {
            "type": "article",
            "title": "Introduction to ESLint",
            "url": "https://dev.to/shivambmgupta/eslint-what-why-when-how-5f1d"
          },
          {
            "type": "video",
            "title": "ESLint Quickstart - find errors automatically",
            "url": "https://www.youtube.com/watch?v=qhuFviJn-es"
          }
        ]
      }
    },
    {
      "id": "PCX3KcvMUW3mmQEepLTXp",
      "name": "Useful Packages",
      "resources": {
        "description": "# Useful Packages\n\nTypeScript has a large ecosystem of packages that can be used to extend the language or to add functionality to your project. Here is the list of some of the most useful packages.\n\n- [@article@zod](https://zod.dev/): A TypeScript-first data validation library\n- [@opensource@ts-morph](https://github.com/dsherret/ts-morph): A TypeScript-first API for manipulating TypeScript code\n- [@article@ts-node](https://typestrong.org/ts-node/): A TypeScript execution and REPL for node.js\n- [@opensource@ts-jest](https://github.com/kulshekhar/ts-jest): A Jest transformer with source map support that lets you use Jest to test projects written in TypeScript.\n- [@opensource@typesync](https://github.com/jeffijoe/typesync): Install missing TypeScript typings for dependencies in your package.json.\n- [@opensource@tsd](https://github.com/SamVerschueren/tsd) - TypeScript Definition Manager\n- [@opensource@type-fest](https://github.com/sindresorhus/type-fest) - A collection of essential TypeScript types",
        "resources": [
          {
            "type": "article",
            "title": "zod",
            "url": "https://zod.dev/"
          },
          {
            "type": "tutorial",
            "title": "ts-morph",
            "url": "https://github.com/dsherret/ts-morph"
          },
          {
            "type": "article",
            "title": "ts-node",
            "url": "https://typestrong.org/ts-node/"
          },
          {
            "type": "tutorial",
            "title": "ts-jest",
            "url": "https://github.com/kulshekhar/ts-jest"
          },
          {
            "type": "tutorial",
            "title": "typesync",
            "url": "https://github.com/jeffijoe/typesync"
          },
          {
            "type": "tutorial",
            "title": "tsd",
            "url": "https://github.com/SamVerschueren/tsd"
          },
          {
            "type": "tutorial",
            "title": "type-fest",
            "url": "https://github.com/sindresorhus/type-fest"
          }
        ]
      }
    },
    {
      "id": "I5uwfej5XMwR2N2gpBILh",
      "name": "Build Tools",
      "resources": {
        "description": "# Build Tools\n\nTask runners automatically execute commands and carry out processes behind the scenes. This helps automate your workflow by performing mundane, repetitive tasks that you would otherwise waste an egregious amount of time repeating yourself.\n\nCommon usages of task runners include numerous development tasks such as: spinning up development servers, compiling code (ex. SCSS to CSS), running linters, serving files up from a local port on your computer, and many more!",
        "resources": [
          {
            "type": "article",
            "title": "webpack is a static module bundler for modern JavaScript applications",
            "url": "https://webpack.js.org/"
          },
          {
            "type": "article",
            "title": "Vite Next Generation Frontend Tooling",
            "url": "https://vitejs.dev"
          },
          {
            "type": "article",
            "title": "Parcel is a zero configuration build tool for the web",
            "url": "https://parceljs.org/"
          },
          {
            "type": "article",
            "title": "esbuild is an extremely fast JavaScript bundler and minifier",
            "url": "https://esbuild.github.io/"
          },
          {
            "type": "article",
            "title": "swc is a super-fast compiler written in Rust",
            "url": "https://swc.rs/"
          },
          {
            "type": "article",
            "title": "tsup is a zero-config TypeScript build tool",
            "url": "https://tsup.egoist.dev/"
          },
          {
            "type": "article",
            "title": "Rollup is a module bundler for JavaScript",
            "url": "https://rollupjs.org/guide/en/"
          },
          {
            "type": "article",
            "title": "tsdx is a zero-config CLI for TypeScript package development",
            "url": "https://tsdx.io/"
          },
          {
            "type": "article",
            "title": "Explore top posts about Tools",
            "url": "https://app.daily.dev/tags/tools?ref=roadmapsh"
          }
        ]
      }
    }
  ],
  "edges": [
    {
      "source": "iogwMmOvub2ZF4zgg6WyF",
      "target": "DAwKHBng7Tytlcd2_8GOR"
    },
    {
      "source": "DAwKHBng7Tytlcd2_8GOR",
      "target": "KDd40JOAvZ8O1mfhTYB3K"
    },
    {
      "source": "KDd40JOAvZ8O1mfhTYB3K",
      "target": "dcLaEU_lb0z_QypL1ZhpX"
    },
    {
      "source": "KDd40JOAvZ8O1mfhTYB3K",
      "target": "MQWzN_kXxVJMOYbRXSGJc"
    },
    {
      "source": "KDd40JOAvZ8O1mfhTYB3K",
      "target": "dA8CNQOgJRDa0T7rmyS7f"
    },
    {
      "source": "KDd40JOAvZ8O1mfhTYB3K",
      "target": "qdy4ZIY2EKgmPNdu_ndcg"
    },
    {
      "source": "KDd40JOAvZ8O1mfhTYB3K",
      "target": "qcrGApxNzkGYxgcd7o45d"
    },
    {
      "source": "qcrGApxNzkGYxgcd7o45d",
      "target": "_4my3Mfk5lxztykcJQ66s"
    },
    {
      "source": "qcrGApxNzkGYxgcd7o45d",
      "target": "KUur-gfOBQodTS-irFet7"
    },
    {
      "source": "alMJCEyUZ90xz-2_g3YRj",
      "target": "qefnsugcveizVq2TORRgn"
    },
    {
      "source": "qefnsugcveizVq2TORRgn",
      "target": "cFZsxpYHDxm7IWwergb3r"
    },
    {
      "source": "cFZsxpYHDxm7IWwergb3r",
      "target": "Wy2yIK5vgLjEcc9VjuQK5"
    },
    {
      "source": "cFZsxpYHDxm7IWwergb3r",
      "target": "EDOU5a7UK17yp3PdFBJMc"
    },
    {
      "source": "cFZsxpYHDxm7IWwergb3r",
      "target": "ZiOcFZy85p7tLzUkyKDei"
    },
    {
      "source": "cFZsxpYHDxm7IWwergb3r",
      "target": "Xonbxc7MvMEonKBvbkCAH"
    },
    {
      "source": "cFZsxpYHDxm7IWwergb3r",
      "target": "1DOSAieOmWUNNsQQrqf2m"
    },
    {
      "source": "cFZsxpYHDxm7IWwergb3r",
      "target": "qOynVkDi1gFz0mxyJHjfJ"
    },
    {
      "source": "qOynVkDi1gFz0mxyJHjfJ",
      "target": "9FIhHwDNzyKpb42NmSv3K"
    },
    {
      "source": "qOynVkDi1gFz0mxyJHjfJ",
      "target": "aH1DxiG5xrdNlKutJ_gTz"
    },
    {
      "source": "aH1DxiG5xrdNlKutJ_gTz",
      "target": "TxkEpoOiuUm-fXJuFVKcH"
    },
    {
      "source": "aH1DxiG5xrdNlKutJ_gTz",
      "target": "O-9WQqidujLIEOTcOfy4n"
    },
    {
      "source": "aH1DxiG5xrdNlKutJ_gTz",
      "target": "fY40W8prpgiNqRL50w7ub"
    },
    {
      "source": "aH1DxiG5xrdNlKutJ_gTz",
      "target": "lvtTSHH9yBTCiLng8btnI"
    },
    {
      "source": "4gaKqNtGLFqpk9WVKZl0v",
      "target": "T2-VAVfntouJOoWHpHZ3n"
    },
    {
      "source": "4gaKqNtGLFqpk9WVKZl0v",
      "target": "0NXHAOUYGIwuPwlN7r_B3"
    },
    {
      "source": "TRx3wvWnRdJJf5eL-GBG4",
      "target": "LSwUHfalnk5MgHt21PANb"
    },
    {
      "source": "LSwUHfalnk5MgHt21PANb",
      "target": "E88tHQvARkHURZwGaO02l"
    },
    {
      "source": "LSwUHfalnk5MgHt21PANb",
      "target": "IuO9-O_DQdDYuAbdGWdgb"
    },
    {
      "source": "LSwUHfalnk5MgHt21PANb",
      "target": "0fvOXi9gJbEc7etqTggNE"
    },
    {
      "source": "LSwUHfalnk5MgHt21PANb",
      "target": "aEhI_9mFWXRIZh1ZxTuzu"
    },
    {
      "source": "LSwUHfalnk5MgHt21PANb",
      "target": "a7hl0iMZ-jcUACxqIYVqv"
    },
    {
      "source": "LSwUHfalnk5MgHt21PANb",
      "target": "_BAZlBEzE7ddr315OeHvl"
    },
    {
      "source": "LSwUHfalnk5MgHt21PANb",
      "target": "On75JR_UkiIlha0_qaSeu"
    },
    {
      "source": "LSwUHfalnk5MgHt21PANb",
      "target": "izGAjNtrh3BzQt3KiZX0W"
    },
    {
      "source": "LSwUHfalnk5MgHt21PANb",
      "target": "2F7vOL__v9dLBohA263aj"
    },
    {
      "source": "2F7vOL__v9dLBohA263aj",
      "target": "VQ-V9qIdKgnpSJg2UnpuB"
    },
    {
      "source": "2F7vOL__v9dLBohA263aj",
      "target": "sE9lqkkqwnsVJxTJv37YZ"
    },
    {
      "source": "sE9lqkkqwnsVJxTJv37YZ",
      "target": "JQwWeB1gkANSYfQmH69Bs"
    },
    {
      "source": "",
      "target": "GV_zWF6rSWg5bqgiXhOEf"
    },
    {
      "source": "",
      "target": "GV_zWF6rSWg5bqgiXhOEf"
    },
    {
      "source": "",
      "target": "GV_zWF6rSWg5bqgiXhOEf"
    },
    {
      "source": "sE9lqkkqwnsVJxTJv37YZ",
      "target": "RqZaWGxxNRItBhVwWKysc"
    },
    {
      "source": "RqZaWGxxNRItBhVwWKysc",
      "target": "fU8Vnw1DobM4iXl1Tq6EK"
    },
    {
      "source": "RqZaWGxxNRItBhVwWKysc",
      "target": "8PcAPOrKisKRYPWamz4nV"
    },
    {
      "source": "RqZaWGxxNRItBhVwWKysc",
      "target": "PCX3KcvMUW3mmQEepLTXp"
    },
    {
      "source": "RqZaWGxxNRItBhVwWKysc",
      "target": "I5uwfej5XMwR2N2gpBILh"
    },
    {
      "source": "RqZaWGxxNRItBhVwWKysc",
      "target": "GV_zWF6rSWg5bqgiXhOEf"
    }
  ]
}