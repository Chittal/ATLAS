{
  "nodes": [
    {
      "id": "y7KjVfSI6CAduyHd4mBFT",
      "name": "Navigation Basics",
      "resources": {
        "description": "# Navigation Basics\n\nIn Linux, navigation between directories and files is a fundamental, yet essential function that allows you to exploit the power of the command-line interface (CLI). Mastering the basic Linux navigation commands such as `cd`, `pwd`, `ls`, and `tree` enables you to flawlessly move from one point to another within the filesystem, display the list of files & directories, and understand your position relative to other system components.",
        "resources": [
          {
            "type": "article",
            "title": "Linux Filesystem Navigation Basics",
            "url": "https://linuxconfig.org/filesystem-basics"
          },
          {
            "type": "article",
            "title": "Basic Navigation Commands: `cd`, `ls`, and `pwd`",
            "url": "https://www.linuxbash.sh/post/basic-navigation-commands-cd-ls-and-pwd"
          },
          {
            "type": "article",
            "title": "Practice on Linux Fundamentals",
            "url": "https://linuxjourney.com/"
          },
          {
            "type": "video",
            "title": "Linux fundamentals",
            "url": "https://www.youtube.com/watch?v=kPylihJRG70&t=1381s&ab_channel=TryHackMe"
          },
          {
            "type": "course",
            "title": "Linux for Noobs (Hands-on)",
            "url": "https://labex.io/courses/linux-for-noobs"
          }
        ]
      }
    },
    {
      "id": "qLeEEwBvlGt1fP5Qcreah",
      "name": "Basic Commands",
      "resources": {
        "description": "# Linux Navigation Basics: Basic Commands\n\nLinux Navigation Basics is about using simple commands to move around and manage files on your computer. For example, `cd` lets you go into different folders, `ls` shows you what files and folders are inside, and `pwd` tells you where you are currently. These commands help you easily find and organize your files.",
        "resources": [
          {
            "type": "article",
            "title": "Linux Filesystem Navigation Basics",
            "url": "https://linuxconfig.org/filesystem-basics"
          },
          {
            "type": "article",
            "title": "Linux Navigation and File Management",
            "url": "https://www.digitalocean.com/community/tutorials/basic-linux-navigation-and-file-management"
          },
          {
            "type": "article",
            "title": "Basic Navigation Commands: `cd`, `ls`, and `pwd` ",
            "url": "https://www.linuxbash.sh/post/basic-navigation-commands-cd-ls-and-pwd"
          }
        ]
      }
    },
    {
      "id": "q-Ky0ietZGpyUcBQfh-BJ",
      "name": "Moving Files / Directories",
      "resources": {
        "description": "# Moving Files\n\nIn Linux, moving files is an essential task that you will need to perform quite frequently. The `mv` command, short for move, is used to move files and directories from one location to another. The `mv` command can also be used for renaming files in Linux.",
        "resources": [
          {
            "type": "article",
            "title": "mv command",
            "url": "https://linuxhandbook.com/mv-command/"
          },
          {
            "type": "article",
            "title": "mv Cheat Sheet",
            "url": "https://www.commandinline.com/cheat-sheet/mv/"
          },
          {
            "type": "article",
            "title": "Linux mv Command: File Moving and Renaming",
            "url": "https://labex.io/tutorials/linux-linux-mv-command-file-moving-and-renaming-209743"
          }
        ]
      }
    },
    {
      "id": "9oo2fxTM2_p0VYPBroqxa",
      "name": "Creating & Deleting Files / Dirs",
      "resources": {
        "description": "# Creating Files\n\nLinux file creation uses `touch` for empty files, `echo \"text\" > filename` for text files, or `cat > filename` for interactive input. Commands like `mkdir` create directories. File creation is immediate and permanent. Essential for organizing data, scripts, and configuration files in Linux systems.",
        "resources": [
          {
            "type": "article",
            "title": "What is the Difference Between Cat and Touch Command",
            "url": "https://linuxways.net/centos/what-is-the-difference-between-cat-and-touch-command/"
          },
          {
            "type": "article",
            "title": "Creating and Deleting Files / Directories in Linux",
            "url": "https://useful.codes/creating-and-deleting-files-directories-in-linux/"
          },
          {
            "type": "article",
            "title": "Creating, Moving, and Deleting Files and Folders",
            "url": "https://dev.to/alkesh009/linux-basics-part-4-creating-moving-and-deleting-files-and-folders-5hip"
          }
        ]
      }
    },
    {
      "id": "3fzuXKH7az_LVnmnoXB1p",
      "name": "Directory Hierarchy Overview",
      "resources": {
        "description": "# Understanding Directory Hierarchy\n\nIn Linux, understanding the directory hierarchy is crucial for efficient navigation and file management. A Linux system's directory structure, also known as the Filesystem Hierarchy Standard (FHS), is a defined tree structure that helps to prevent files from being scattered all over the system and instead organise them in a logical and easy-to-navigate manner.\n\n- `/`: Root directory, the top level of the file system.\n- `/home`: User home directories.\n- `/bin`: Essential binary executables.\n- `/sbin`: System administration binaries.\n- `/etc`: Configuration files.\n- `/var`: Variable data (logs, spool files).\n- `/usr`: User programs and data.\n- `/lib`: Shared libraries.\n- `/tmp`: Temporary files.\n- `/opt`: Third-party applications.",
        "resources": [
          {
            "type": "article",
            "title": "Linux Directory Structure Explained for Beginners",
            "url": "https://linuxhandbook.com/linux-directory-structure/"
          },
          {
            "type": "article",
            "title": "Overview of File System Hierarchy Standard (FHS)",
            "url": "https://access.redhat.com/documentation/ru-ru/red_hat_enterprise_linux/4/html/reference_guide/s1-filesystem-fhs#s3-filesystem-usr"
          },
          {
            "type": "video",
            "title": "The Linux File System Explained in 1,233 Seconds",
            "url": "https://youtu.be/A3G-3hp88mo?si=sTJTSzubdb0Vizjr"
          }
        ]
      }
    },
    {
      "id": "HGmeYvRf7_XusZl_K4x9k",
      "name": "Editing Files",
      "resources": {
        "description": "# Editing Files\n\nLinux, like other operating systems, allows file editing for numerous purposes, whether you need to configure some system functionality or writing scripts. There's a variety of text editors available in Linux by default, these include: `nano`, `vi/vim`, `emacs`, and `gedit`. Each of these has its own learning curve and set of commands.",
        "resources": [
          {
            "type": "article",
            "title": "Editing Files in Linux Command Line",
            "url": "https://itsfoss.com/edit-files-linux/"
          },
          {
            "type": "article",
            "title": "The Complete Guide to Text Editing in Linux with Nano and Vim",
            "url": "https://thelinuxcode.com/how-to-edit-file-in-linux/"
          },
          {
            "type": "article",
            "title": "Vim Tutorial for Beginners",
            "url": "https://linuxconfig.org/vim-tutorial"
          }
        ]
      }
    },
    {
      "id": "8QBMyL8D5jPovxN8jyZW9",
      "name": "Shell and Other Basics",
      "resources": {
        "description": "# Shell Basics\n\nThe Linux shell is a command-line interface that acts as an intermediary between users and the system kernel. Common shells include Bash, sh, and csh. Basic operations involve navigating directories, creating/deleting files, and executing commands. Shell knowledge is fundamental for Linux administration, scripting, and automation tasks.",
        "resources": [
          {
            "type": "article",
            "title": "Learning The Shell",
            "url": "https://www.linuxcommand.org/lc3_lts0010.php"
          },
          {
            "type": "article",
            "title": "What is a Shell in Linux",
            "url": "https://linuxsimply.com/what-is-a-shell-linux/"
          },
          {
            "type": "article",
            "title": "Learn Linux Easily",
            "url": "https://linuxjourney.com"
          }
        ]
      }
    },
    {
      "id": "XiZz7EFIey1XKS292GN4t",
      "name": "Vim",
      "resources": {
        "description": "# Vim: An Essential Tool for Editing Files\n\nVim (Vi Improved) is a powerful and flexible text editor used in Unix-like systems. It builds on the original Vi editor with additional features and improvements, including multi-level undo, syntax highlighting, and an extensive set of commands for text manipulation.\n\nVim operates primarily in three modes:\n\n- Normal (for navigation and manipulation).\n- Insert (for editing text).\n- Command (for executing commands).",
        "resources": [
          {
            "type": "article",
            "title": "Vim Cheat Sheet",
            "url": "https://vim.rtorr.com/"
          },
          {
            "type": "article",
            "title": "Learn Vim Progressively",
            "url": "https://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/"
          },
          {
            "type": "article",
            "title": "Platform to practice Vim",
            "url": "https://vim-adventures.com/"
          },
          {
            "type": "video",
            "title": "Vim Basics",
            "url": "https://www.youtube.com/watch?v=wACD8WEnImo&list=PLT98CRl2KxKHy4A5N70jMRYAROzzC2a6x&ab_channel=LearnLinuxTV"
          },
          {
            "type": "course",
            "title": "Learn Vimscript The Hard Way",
            "url": "https://learnvimscriptthehardway.stevelosh.com/"
          }
        ]
      }
    },
    {
      "id": "yqRwmcZThjQuqh2ao0dWK",
      "name": "Nano",
      "resources": {
        "description": "# Nano: A File Editing Tool\n\nNano is a popular, user-friendly text editor used for creating and editing files directly within the Linux command line interface (CLI). It is an alternative to editors like `Vi` and `Emacs` and is considered more straightforward for beginners due to its simple and intuitive interface.",
        "resources": [
          {
            "type": "course",
            "title": "nano - Text editor",
            "url": "https://www.nano-editor.org/"
          },
          {
            "type": "article",
            "title": "Editing Files With Nano in Linux",
            "url": "https://itsfoss.com/nano-editor-guide/"
          },
          {
            "type": "article",
            "title": "Nano in Linux",
            "url": "https://ioflood.com/blog/nano-linux-command/"
          },
          {
            "type": "video",
            "title": "Nano editor fundamentals",
            "url": "https://www.youtube.com/watch?v=gyKiDczLIZ4&ab_channel=HackerSploit"
          }
        ]
      }
    },
    {
      "id": "moGMHNR58wFlzhS7je1wc",
      "name": "Command Path",
      "resources": {
        "description": "# Command Path in Shell\n\nThe command path is a variable that is used by the shell to determine where to look for the executable files to run. Linux commands are nothing but programs residing in particular directories. But, one does not have to navigate to these directories every time to run these programs. The command path comes to the rescue!\n\nUsually, when you type a command in the terminal, the shell needs to know the absolute path of the command's executable to run it. Instead of typing the full path each time, command paths allow the shell to automatically search the indicated directories in the correct order. These paths are stored in the $PATH environment variable.",
        "resources": [
          {
            "type": "article",
            "title": "Linux path environment variable",
            "url": "https://linuxconfig.org/linux-path-environment-variable"
          },
          {
            "type": "article",
            "title": "How to find a path of a Linux command like a pro",
            "url": "https://www.cyberciti.biz/howto/finding-a-path-of-a-linux-command-like-a-pro/"
          }
        ]
      }
    },
    {
      "id": "zwXEmpPYjA7_msS43z7I0",
      "name": "Environment Variables",
      "resources": {
        "description": "# Environment Variables\n\nEnvironment variables are dynamic named values that can affect the behavior of running processes in a shell. They exist in every shell session. A shell session's environment includes, but is not limited to, the user's home directory, command search path, terminal type, and program preferences.\n\nEnvironment variables help to contribute to the fantastic and customizable flexibility you see in Unix systems. They provide a simple way to share configuration settings between multiple applications and processes in Linux.",
        "resources": [
          {
            "type": "article",
            "title": "Environment Variables in Linux",
            "url": "https://labex.io/tutorials/linux-environment-variables-in-linux-385274"
          },
          {
            "type": "article",
            "title": "Linux Environment Variables List, Set, Create & Remove",
            "url": "https://www.computernetworkingnotes.com/linux-tutorials/linux-environment-variables-list-set-create-remove.html"
          },
          {
            "type": "article",
            "title": "How to Set and List Environment Variables in Linux",
            "url": "https://linuxize.com/post/how-to-set-and-list-environment-variables-in-linux/"
          }
        ]
      }
    },
    {
      "id": "KaMSsQnJzNqGHg0Oia4uy",
      "name": "Command Help",
      "resources": {
        "description": "# Command Help\n\nLinux command help provides documentation and usage information for shell commands. Use `man command` for detailed manuals, `help command` for shell built-ins, `command --help` for quick options, and `tldr command` for practical examples. Essential for learning command syntax, parameters, and functionality in Linux terminal environments.",
        "resources": [
          {
            "type": "article",
            "title": "Using the Help Command in Linux",
            "url": "https://linuxhandbook.com/help-command/"
          },
          {
            "type": "article",
            "title": "Chapter 10: Getting Help in Linux Terminal",
            "url": "https://itsfoss.com/linux-command-help/"
          },
          {
            "type": "tutorial",
            "title": "tldr-pages/tldr",
            "url": "https://github.com/tldr-pages/tldr"
          },
          {
            "type": "article",
            "title": "Get Help on Linux Commands",
            "url": "https://labex.io/tutorials/linux-get-help-on-linux-commands-18000"
          }
        ]
      }
    },
    {
      "id": "JgoZzx4BfK7tmosgpZOsf",
      "name": "Redirects",
      "resources": {
        "description": "# Redirects\n\nThe shell in Linux provides a robust way of managing input and output streams of a command or program, this mechanism is known as Redirection. Linux being a multi-user and multi-tasking operating system, every process typically has 3 streams opened:\n\n- Standard Input (stdin) - This is where the process reads its input from. The default is the keyboard.\n- Standard Output (stdout) - The process writes its output to stdout. By default, this means the terminal.\n- Standard Error (stderr) - The process writes error messages to stderr. This also goes to the terminal by default.",
        "resources": [
          {
            "type": "article",
            "title": "Input Output & Error Redirection in Linux",
            "url": "https://linuxhandbook.com/redirection-linux/"
          },
          {
            "type": "article",
            "title": "Redirections (Bash Reference Manual)",
            "url": "https://www.gnu.org/software/bash/manual/html_node/Redirections.html"
          },
          {
            "type": "article",
            "title": "Redirections in Linux with Examples",
            "url": "https://linuxopsys.com/redirections-in-linux-with-examples"
          }
        ]
      }
    },
    {
      "id": "NIBSZGE9PskVrluJpdom0",
      "name": "Super User",
      "resources": {
        "description": "# Super User\n\nThe Super User, also known as \"root user\", represents a user account in Linux with extensive powers, privileges, and capabilities. This user has complete control over the system and can access any data stored on it. This includes the ability to modify system configurations, change other user's passwords, install software, and perform more administrative tasks in the shell environment.\n\nThe usage of super user is critical to operating a Linux system properly and safely as it can potentially cause serious damage. The super user can be accessed through the `sudo` or `su` commands.",
        "resources": [
          {
            "type": "article",
            "title": "Linux Superuser Access, Explained",
            "url": "https://www.redhat.com/en/blog/linux-superuser-access/"
          },
          {
            "type": "article",
            "title": "Difference between the root user and super (sudo) user",
            "url": "https://www.computernetworkingnotes.com/linux-tutorials/difference-between-the-root-user-and-super-sudo-user.html"
          },
          {
            "type": "article",
            "title": "What is Superuser Access in Linux?",
            "url": "https://www.scaler.com/topics/super-user-in-linux/"
          }
        ]
      }
    },
    {
      "id": "RsOTPZPZGTEIt1Lk41bQV",
      "name": "Working with Files",
      "resources": {
        "description": "# Working with Files\n\nWorking with files is an essential part of Linux and it's a skill every Linux user must have. In Linux, everything is considered a file: texts, images, systems, devices, and directories.\nLinux provides multiple command-line utilities to create, view, move or search files. Some of the basic commands for file handling in Linux terminal include `touch` for creating files, `mv` for moving files, `cp` for copying files, `rm` for removing files, and `ls` for listing files and directories.",
        "resources": [
          {
            "type": "article",
            "title": "Editing Files in Linux Command Line",
            "url": "https://itsfoss.com/edit-files-linux/"
          },
          {
            "type": "article",
            "title": "Mastering cp and mv Commands in Linux",
            "url": "https://dev.to/ldwit/mastering-cp-and-mv-commands-in-linux-plus-related-cmds-5cc9"
          },
          {
            "type": "article",
            "title": "Vim Tutorial for Beginners",
            "url": "https://linuxconfig.org/vim-tutorial"
          },
          {
            "type": "article",
            "title": "Linux Basic Files Operations",
            "url": "https://labex.io/tutorials/linux-basic-files-operations-270248"
          },
          {
            "type": "article",
            "title": "What is the Difference Between Cat and Touch Command",
            "url": "https://linuxways.net/centos/what-is-the-difference-between-cat-and-touch-command/"
          }
        ]
      }
    },
    {
      "id": "TnrT-cqMA8urew9nLv0Ns",
      "name": "File Permissions",
      "resources": {
        "description": "# Linux File Permissions\n\nIn Linux systems, rights and privileges are assigned to files and directories in the form of permissions. These permissions indicate who can read, write, or execute (run) them. In Linux, there are three types of users: owners, groups, and others who can have a different set of permissions.\n\nIn fact, permissions on the system are there for a reason: to prevent unprivileged users from making changes on the system that would ultimately affect other users. With inadequate permissions, unprivileged users are able to make changes that would be beneficial or harmless to the Linux system.\n\nLet's have a look at an example:\n\n```bash\n-rwxr--r-- 1 root root 4096 Jan 1 12:00 filename\n```\n\nFrom the above example, the first character `-` indicates if it is a regular file(`-`) or directory(`d`). The following group of three characters(`rwx`) represents the permissions for the file owner. The next three characters(`r--`) represent permissions for the group and the last set of three characters(`r--`) represents permissions for others.\n\nThe `r` indicates that the file can be read, `w` indicates that the file can be written to, and `x` indicates that the file can be executed.\n\nThe permissions can be changed using the `chmod`, `chown`, and `chgrp` commands.",
        "resources": [
          {
            "type": "article",
            "title": "Linux File Permissions",
            "url": "https://linuxhandbook.com/linux-file-permissions/"
          },
          {
            "type": "video",
            "title": "Linux File Permissions in 5 Minutes",
            "url": "https://www.youtube.com/watch?v=LnKoncbQBsM"
          },
          {
            "type": "article",
            "title": "Linux Permissions of Files",
            "url": "https://labex.io/tutorials/linux-permissions-of-files-270252"
          }
        ]
      }
    },
    {
      "id": "iD073xTmpzvQFfXwcwXcY",
      "name": "Archiving and Compressing",
      "resources": {
        "description": "# Archiving\n\nLinux offers powerful utilities for archiving, where multiple files and directories are combined into a single file, primarily for backup and simplification of distribution. The main tools used for this purpose are `tar`, `gzip`, and `bzip2`.\n\nThe `tar` command, originally for tape archiving, is a versatile tool that can manage and organize files into one archive. Meanwhile, `gzip` and `bzip2` are used for file compression, reducing the file size and making data transmission easier.\n\nTake a look at the following commands in use:\n\n```bash\n# To create a tar archive:\ntar cvf archive_name.tar directory_to_archive/\n\n# To extract a tar archive:\ntar xvf archive_name.tar\n\n# To create a gzip compressed tar archive:\ntar cvzf archive_name.tar.gz directory_to_archive/\n\n#To create a bzip2 compressed tar archive:\ntar cvjf archive_name.tar.bz2 directory_to_archive/\n```\n\nRemember, in Linux, archiving and compression are separate processes, hence `tar` to archive and `gzip`/`bzip2` to compress. Although they're commonly used together, they can very much be used separately as per the requirements.",
        "resources": [
          {
            "type": "article",
            "title": "Linux File Packaging and Compression",
            "url": "https://labex.io/tutorials/linux-file-packaging-and-compression-385413"
          }
        ]
      }
    },
    {
      "id": "abKO6KuuIfl9ruVxBw6t_",
      "name": "Copying and Renaming",
      "resources": {
        "description": "# Copying and Renaming Files\n\nEssential Linux file operations use `cp` to copy files and `mv` to move/rename them. The `cp` command copies files from source to destination, while `mv` moves or renames files/directories. Both commands use the syntax `command source destination`. These case-sensitive commands are fundamental for daily file management tasks in Linux systems.",
        "resources": [
          {
            "type": "article",
            "title": "mv and cp - Linux.org",
            "url": "https://www.linux.org/threads/mv-and-cp.54793/"
          },
          {
            "type": "article",
            "title": "Mastering cp and mv Commands in Linux",
            "url": "https://dev.to/ldwit/mastering-cp-and-mv-commands-in-linux-plus-related-cmds-5cc9"
          },
          {
            "type": "article",
            "title": "Linux cp Command: File Copying",
            "url": "https://labex.io/tutorials/linux-linux-cp-command-file-copying-209744"
          },
          {
            "type": "article",
            "title": "Linux mv Command: File Moving and Renaming",
            "url": "https://labex.io/tutorials/linux-linux-mv-command-file-moving-and-renaming-209743"
          }
        ]
      }
    },
    {
      "id": "KaXHG_EKxI5PUXmcvlJt6",
      "name": "Soft Links / Hard Links",
      "resources": {
        "description": "# Soft and Hard Links\n\nLinux supports two types of file links. Hard links share the same inode and data as the original file - if the original is deleted, data remains accessible. Soft links (symbolic links) are shortcuts pointing to the original file path - they break if the original is removed. Create with `ln` for hard links and `ln -s` for soft links.",
        "resources": [
          {
            "type": "article",
            "title": "Hard links and Soft links in Linux Explained",
            "url": "https://www.redhat.com/en/blog/linking-linux-explained"
          },
          {
            "type": "article",
            "title": "Difference between hard link and soft link",
            "url": "https://kerneltalks.com/commands/difference-between-hard-link-and-soft-link/"
          },
          {
            "type": "article",
            "title": "How to Understand the Difference between Hard and Symbolic Links in Linux",
            "url": "https://labex.io/tutorials/linux-how-to-understand-the-difference-between-hard-and-symbolic-links-in-linux-409929"
          }
        ]
      }
    },
    {
      "id": "-B2Dvz7160Er0OBHzS6ro",
      "name": "Text Processing",
      "resources": {
        "description": "# Text Processing\n\nLinux offers robust text processing capabilities essential for system administrators and developers. Users can leverage command-line tools like `awk`, `sed`, `grep`, and `cut` for tasks such as filtering, substitution, and regular expression handling. Scripting languages like Python and Perl further enhance text processing. While primarily command-line based, Linux also provides GUI text editors such as `gedit`, `nano`, and `vim`. Proficiency in these tools is vital for automating tasks, parsing files, and efficient data mining.",
        "resources": [
          {
            "type": "article",
            "title": "Common Linux Text Processing Commands",
            "url": "https://www.commandinline.com/linux/common-linux-text-processing-commands/"
          },
          {
            "type": "article",
            "title": "Linux Filters",
            "url": "https://ryanstutorials.net/linuxtutorial/filters.php"
          },
          {
            "type": "article",
            "title": "Linux Text Processing Command",
            "url": "https://earthly.dev/blog/linux-text-processing-commands/"
          },
          {
            "type": "article",
            "title": "Master Linux Text Processing Commands",
            "url": "https://everythingdevops.dev/linux-text-processing-commands/"
          }
        ]
      }
    },
    {
      "id": "t3fxSgCgtxuMtHjclPHA6",
      "name": "stdout / stdin / stderr",
      "resources": {
        "description": "# Stdout, Stdin, and Stderr\n\nLinux processes use three standard data streams: STDIN (input), STDOUT (output), and STDERR (error messages). STDOUT handles normal command output while STDERR specifically handles error messages. You can redirect these streams using operators like `>` for stdout and `2>` for stderr, allowing separate handling of normal output and errors for better scripting and debugging.",
        "resources": [
          {
            "type": "article",
            "title": "Linux Fundamentals - I/O, Standard Streams, and Redirection",
            "url": "https://www.putorius.net/linux-io-file-descriptors-and-redirection.html"
          },
          {
            "type": "article",
            "title": "Understanding 'stdin', 'stdout' and 'stderr' in Linux",
            "url": "https://www.slingacademy.com/article/understanding-stdin-stdout-and-stderr-in-linux/"
          },
          {
            "type": "article",
            "title": "Working with data streams on the Linux command line",
            "url": "https://opensource.com/article/18/10/linux-data-streams"
          }
        ]
      }
    },
    {
      "id": "Z5Mf_e5G24IkmxEHgYBe2",
      "name": "cut",
      "resources": {
        "description": "# Cut Command\n\nThe `cut` command is a text processing utility that allows you to cut out sections of each line from a file or output, and display it on the standard output (usually, the terminal). It's commonly used in scripts and pipelines, especially for file operations and text manipulation.",
        "resources": [
          {
            "type": "article",
            "title": "Cut Command in Linux | Linuxize",
            "url": "https://linuxize.com/post/linux-cut-command/"
          },
          {
            "type": "article",
            "title": "Linux cut Command: Text Cutting",
            "url": "https://labex.io/tutorials/linux-linux-cut-command-text-cutting-219187"
          }
        ]
      }
    },
    {
      "id": "5658kdqJw-pIOyyhll80a",
      "name": "paste",
      "resources": {
        "description": "# Paste\n\nIn Linux, paste is a powerful text processing utility that is primarily used for merging lines from multiple files. It allows users to combine data by columns rather than rows, adding immense flexibility to textual data manipulation. Users can choose a specific delimiter for separating columns, providing a range of ways to format the output. You may use `paste` command like `$ paste file1.txt file2.txt > combined.txt`.",
        "resources": [
          {
            "type": "article",
            "title": "Paste Command in Linux (Merge Lines)",
            "url": "https://linuxize.com/post/paste-command-in-linux/"
          },
          {
            "type": "article",
            "title": "7 Practical Usage of Paste Command in Linux",
            "url": "https://linuxhandbook.com/paste-command/"
          }
        ]
      }
    },
    {
      "id": "1WRIy3xHtQfiQFZrprobP",
      "name": "sort",
      "resources": {
        "description": "# Sort\n\nLinux provides a variety of tools for processing and manipulating text files, one of which is the sort command. The `sort` command in Linux is used to sort the contents of a text file, line by line. The command uses ASCII values to sort files. You can use this command to sort the data in a file in a number of different ways such as alphabetically, numerically, reverse order, or even monthly. The sort command takes a file as input and prints the sorted content on the standard output (screen).",
        "resources": [
          {
            "type": "article",
            "title": "Sort Command in Linux - 10 Useful Examples",
            "url": "https://linuxhandbook.com/sort-command/"
          },
          {
            "type": "article",
            "title": "Sort Command in Linux with Practical Examples",
            "url": "https://tecadmin.net/linux-sort-command/"
          },
          {
            "type": "article",
            "title": "Linux sort Command: Text Sorting",
            "url": "https://labex.io/tutorials/linux-linux-sort-command-text-sorting-219196"
          }
        ]
      }
    },
    {
      "id": "6xdkFk_GT93MigeTSSGCp",
      "name": "head",
      "resources": {
        "description": "# Head Command\n\nThe `head` command in Linux is a text processing utility that allows a user to output the first part (or the \"head\") of files. It is commonly used for previewing the start of a file without loading the entire document into memory, which can act as an efficient way of quickly examining the data in very large files. By default, the `head` command prints the first 10 lines of each file to standard output, which is the terminal in most systems.",
        "resources": [
          {
            "type": "article",
            "title": "Head Command in Linux - 5 Essential Examples",
            "url": "https://linuxhandbook.com/head-command/"
          },
          {
            "type": "article",
            "title": "Linux head Command: File Beginning Display",
            "url": "https://labex.io/tutorials/linux-linux-head-command-file-beginning-display-214302"
          }
        ]
      }
    },
    {
      "id": "O9Vci_WpUY-79AkA4HDx3",
      "name": "tr",
      "resources": {
        "description": "# Tr-Command\n\nThe `tr` command in Linux is a command-line utility that translates or substitutes characters. It reads from the standard input and writes to the standard output. Although commonly used for translation applications, `tr` has versatile functionality in the text processing aspect of Linux. Ranging from replacing a list of characters, to deleting or squeezing character repetitions, `tr` presents a robust tool for stream-based text manipulations.",
        "resources": [
          {
            "type": "article",
            "title": "tr Command in Linux: 6 Useful Examples",
            "url": "https://linuxhandbook.com/tr-command/"
          },
          {
            "type": "article",
            "title": "Linux tr Command: Character Translating",
            "url": "https://labex.io/tutorials/linux-linux-tr-command-character-translating-388064"
          }
        ]
      }
    },
    {
      "id": "Yyk28H6TiteZEGv6Aps1h",
      "name": "tail",
      "resources": {
        "description": "# Tail Command\n\nThe `tail` command in Linux is a utility used in text processing. Fundamentally, it's used to output the last part of the files. The command reads data from standard input or from a file and outputs the last `N` bytes, lines, blocks, characters or words to the standard output (or a different file). By default, `tail` returns the last 10 lines of each file to the standard output. This command is common in situations where the user is interested in the most recent entries in a text file, such as log files.",
        "resources": [
          {
            "type": "article",
            "title": "5 Practical Examples of Tail Command in Linux",
            "url": "https://linuxhandbook.com/tail-command/"
          },
          {
            "type": "article",
            "title": "Linux Tail Command | Linuxize",
            "url": "https://linuxize.com/post/linux-tail-command/"
          },
          {
            "type": "article",
            "title": "Linux tail Command: File End Display",
            "url": "https://labex.io/tutorials/linux-linux-tail-command-file-end-display-214303"
          }
        ]
      }
    },
    {
      "id": "vfcCS1GoyKpU1rQaE8I5r",
      "name": "join",
      "resources": {
        "description": "# join Command\n\n`join` is a powerful text processing command in Linux. It lets you combine lines of two files on a common field, which works similar to the 'Join' operation in SQL. It's particularly useful when you're dealing with large volumes of data. Specifically, `join` uses the lines from two files to form lines that contain pairs of lines related in a meaningful way.",
        "resources": [
          {
            "type": "article",
            "title": "join(1) — Linux manual page",
            "url": "https://www.man7.org/linux/man-pages/man1/join.1.html"
          },
          {
            "type": "article",
            "title": "join command in Linux with examples",
            "url": "https://linuxconfig.org/join"
          },
          {
            "type": "article",
            "title": "Linux join Command: File Joining",
            "url": "https://labex.io/tutorials/linux-linux-join-command-file-joining-219193"
          }
        ]
      }
    },
    {
      "id": "Pl9s2ti25hsSEljXJvBTj",
      "name": "split",
      "resources": {
        "description": "# Split Command\n\nLinux provides an extensive set of tools for manipulating text data. One of such utilities is the `split` command that is used, as the name suggests, to split large files into smaller files. The `split` command in Linux divides a file into multiple equal parts, based on the lines or bytes specified by the user.",
        "resources": [
          {
            "type": "article",
            "title": "Split Command in Linux: 9 Useful Examples",
            "url": "https://linuxhandbook.com/split-command/"
          },
          {
            "type": "article",
            "title": "Split Command in Linux: Usage Guide with Examples",
            "url": "https://ioflood.com/blog/split-linux-command/"
          }
        ]
      }
    },
    {
      "id": "v32PJl4fzIFTOirOm6G44",
      "name": "pipe",
      "resources": {
        "description": "# Pipe Commands\n\nThe pipe (`|`) is a powerful feature in Linux used to connect two or more commands together. This mechanism allows output of one command to be \"piped\" as input to another. With regards to text processing, using pipe is especially helpful since it allows you to manipulate, analyze, and transform text data without the need to create intermediary files or programs.\n\nHere is a simple example of piping two commands, `ls` and `grep`, to list all the text files in the current directory:\n\n```bash\nls | grep '\\.txt$'\n```\n\nIn this example, `ls` lists the files in the current directory and `grep '\\.txt$'` filters out any files that don't end with `.txt`. The pipe command, `|`, takes the output from `ls` and uses it as the input to `grep '\\.txt$'`. The output of the entire command is the list of text files in the current directory.",
        "resources": [
          {
            "type": "article",
            "title": "An In-Depth Guide to Pipes in Linux - TheLinuxCode",
            "url": "https://thelinuxcode.com/linux-pipe-command-examples/"
          },
          {
            "type": "article",
            "title": "Piping and Redirection",
            "url": "https://ryanstutorials.net/linuxtutorial/piping.php#piping"
          },
          {
            "type": "article",
            "title": "What is Piping in Linux?",
            "url": "https://linuxsimply.com/what-is-piping-in-linux/"
          }
        ]
      }
    },
    {
      "id": "Bo9CdrGJej-QcNmw46k9t",
      "name": "tee",
      "resources": {
        "description": "# Tee\n\nThe `tee` command reads from standard input and writes to both standard output and files simultaneously, like a T-splitter in plumbing. It enables users to view results in the terminal while saving output to files concurrently. Syntax: `command | tee file`. Extremely useful for documenting terminal activities and preserving command outputs for later analysis.",
        "resources": [
          {
            "type": "article",
            "title": "Tee Command in Linux Explained with Examples",
            "url": "https://linuxhandbook.com/tee-command/"
          },
          {
            "type": "article",
            "title": "Linux Tee Command",
            "url": "https://linuxize.com/post/linux-tee-command/"
          }
        ]
      }
    },
    {
      "id": "YSfGrmT795miIeIZrtC3D",
      "name": "nl",
      "resources": {
        "description": "# NL (Number Lines)\n\nThe `nl` command numbers lines in text files, providing an overview of line locations. By default, it numbers only non-empty lines, but this behavior can be modified. Syntax: `nl [options] [file_name]`. If no file is specified, nl reads from stdin. Valuable for text processing when line numbers are needed for reference or debugging purposes.",
        "resources": [
          {
            "type": "article",
            "title": "nl command",
            "url": "https://www.computerhope.com/unix/nl.htm"
          },
          {
            "type": "article",
            "title": "Linux nl Command: Line Numbering",
            "url": "https://labex.io/tutorials/linux-linux-nl-command-line-numbering-210988"
          },
          {
            "type": "article",
            "title": "Master the Linux 'nl' Command: A Comprehensive Guide",
            "url": "https://hopeness.medium.com/master-the-linux-nl-command-a-comprehensive-guide-79c6adf50fa9"
          }
        ]
      }
    },
    {
      "id": "LIGOJwrXexnIcPyHVlhQ8",
      "name": "wc",
      "resources": {
        "description": "# WC - Text Processing\n\nThe `wc` command is a commonly used tool in Unix or Linux that allows users to count the number of bytes, characters, words, and lines in a file or in data piped from standard input. The name `wc` stands for 'word count', but it can do much more than just count words. Common usage of `wc` includes tracking program output, counting code lines, and more. It's an invaluable tool for analyzing text at both granular and larger scales.",
        "resources": [
          {
            "type": "article",
            "title": "Wc Command in Linux (Count Number of Lines, Words, and Characters)",
            "url": "https://linuxize.com/post/linux-wc-command/"
          },
          {
            "type": "article",
            "title": "wc Command Examples - Linux Handbook",
            "url": "https://linuxhandbook.com/wc-command/"
          },
          {
            "type": "article",
            "title": "Linux wc Command: Text Counting",
            "url": "https://labex.io/tutorials/linux-linux-wc-command-text-counting-219200"
          }
        ]
      }
    },
    {
      "id": "TZuDVFS7DZFBgaSYYXoGe",
      "name": "expand",
      "resources": {
        "description": "# Expand\n\nThe `expand` command converts tabs to spaces in text files, useful for consistent formatting across different systems and editors. Default conversion is 8 spaces per tab. Use `expand filename` for basic conversion or `expand -t 4 filename` to specify 4 spaces per tab. Essential for maintaining code readability and consistent indentation in shell scripts.",
        "resources": [
          {
            "type": "article",
            "title": "expand — Linux manual page",
            "url": "https://www.man7.org/linux/man-pages/man1/expand.1.html"
          },
          {
            "type": "article",
            "title": "How to Use the 'expand' Command (with examples)",
            "url": "https://commandmasters.com/commands/expand-common/"
          }
        ]
      }
    },
    {
      "id": "sKduFaX6xZaUUBdXRMKCL",
      "name": "unexpand",
      "resources": {
        "description": "# Unexpand\n\nThe `unexpand` command converts spaces to tabs in text files, making documents more coherent and neat. Commonly used in programming scripts where tab indentation is preferred. Use `unexpand -t 4 file.txt` to replace every four spaces with a tab. Opposite of `expand` command, useful for standardizing indentation formatting in code files.",
        "resources": [
          {
            "type": "article",
            "title": "unexpand Cheat Sheet",
            "url": "https://www.commandinline.com/cheat-sheet/unexpand/"
          },
          {
            "type": "article",
            "title": "Master the Linux 'unexpand' Command: A Comprehensive Guide",
            "url": "https://hopeness.medium.com/master-the-linux-unexpand-command-a-comprehensive-guide-6966c1f90acb"
          },
          {
            "type": "article",
            "title": "Linux unexpand Command with Practical Examples",
            "url": "https://labex.io/tutorials/linux-linux-unexpand-command-with-practical-examples-422975"
          }
        ]
      }
    },
    {
      "id": "qnBbzphImflQbEbtFub9x",
      "name": "uniq",
      "resources": {
        "description": "# Uniq\n\n`uniq` is an extremely useful command-line program for text processing. It aids in the examination and manipulation of text files by comparing or filtering out repeated lines that are adjacent. Whether you're dealing with a list of data or a large text document, the `uniq` command allows you to find and filter out duplicate lines, or even provide a count of each unique line in a file. It's important to remember that `uniq` only removes duplicates that are next to each other, so to get the most out of this command, data is often sorted using the `sort` command first.",
        "resources": [
          {
            "type": "article",
            "title": "Uniq Command in Unix and Linux: 7 Essential Examples",
            "url": "https://linuxhandbook.com/uniq-command/"
          },
          {
            "type": "article",
            "title": "Linux uniq Command: Duplicate Filtering",
            "url": "https://labex.io/tutorials/linux-linux-uniq-command-duplicate-filtering-219199"
          },
          {
            "type": "article",
            "title": "How to Use the Uniq Command to Process Lists in Linux",
            "url": "https://www.redhat.com/en/blog/uniq-command-lists"
          }
        ]
      }
    },
    {
      "id": "umlhxidsvtZG9k40Ca0Ac",
      "name": "grep",
      "resources": {
        "description": "# GREP\n\nGREP (Global Regular Expression Print) is a powerful text search utility that finds and filters text matching specific patterns in files. It searches line by line and prints matching lines to the screen. Essential for shell scripts and command-line operations. Example: `grep \"pattern\" fileName` searches for specified patterns. Alternative: `ripgrep` offers enhanced performance and features.",
        "resources": [
          {
            "type": "article",
            "title": "Grep and Regular Expressions for Beginners",
            "url": "https://ryanstutorials.net/linuxtutorial/grep.php"
          },
          {
            "type": "article",
            "title": "bgsu.edu: Advanced Grep Topics",
            "url": "https://caspar.bgsu.edu/~courses/Stats/Labs/Handouts/grepadvanced.htm"
          },
          {
            "type": "tutorial",
            "title": "Ripgrep: GitHub Repository",
            "url": "https://github.com/BurntSushi/ripgrep"
          },
          {
            "type": "article",
            "title": "Linux grep Command: Pattern Searching",
            "url": "https://labex.io/tutorials/linux-linux-grep-command-pattern-searching-219192"
          }
        ]
      }
    },
    {
      "id": "QTmECqpRVMjNgQU70uCF8",
      "name": "awk",
      "resources": {
        "description": "# AWK\n\nAWK is a powerful text-processing language for Unix-like systems, named after its creators Aho, Weinberger, and Kernighan. It reads files line by line, identifies patterns, and executes actions on matches. Commonly used in bash scripts for sorting, filtering, and report generation.\n\nExample: `awk '{print $1,$2}' filename` prints first two fields of each line.",
        "resources": [
          {
            "type": "article",
            "title": "IBM.com: Awk by Example",
            "url": "https://developer.ibm.com/tutorials/l-awk1/"
          },
          {
            "type": "article",
            "title": "AWK Tutorial",
            "url": "https://linuxhandbook.com/awk-command-tutorial/"
          },
          {
            "type": "video",
            "title": "Learning Awk Is Essential For Linux Users",
            "url": "https://www.youtube.com/watch?v=9YOZmI-zWok"
          },
          {
            "type": "article",
            "title": "Linux awk Command: Text Processing",
            "url": "https://labex.io/tutorials/linux-linux-awk-command-text-processing-388493"
          },
          {
            "type": "article",
            "title": "Explore top posts about Bash",
            "url": "https://app.daily.dev/tags/bash?ref=roadmapsh"
          }
        ]
      }
    },
    {
      "id": "jSzfQf0MlnXtWHCc-HYvr",
      "name": "Server Review",
      "resources": {
        "description": "# Server Review\n\nServer review in Linux involves assessing performance, security, and configuration to identify improvements and issues. Check security enhancements, log files, user accounts, network configuration, and software versions. Common commands: `free -m` for memory, `df -h` for disk usage, `uptime` for CPU load. Critical task for system administrators and DevOps professionals to ensure optimal performance, security, and reliability.",
        "resources": [
          {
            "type": "article",
            "title": "Linux Server Management Essentials",
            "url": "https://www.ictbroadcast.com/linux-server-management-essentials-administration-monitoring-and-maintenance-guidelines-for-success/"
          },
          {
            "type": "article",
            "title": "Essential Linux Server Maintenance Checklist",
            "url": "https://tecadmin.net/linux-server-maintenance-checklist/"
          },
          {
            "type": "article",
            "title": "Optimizing Linux Server Performance",
            "url": "https://www.linuxjournal.com/content/optimizing-linux-server-performance-benchmarking-and-advanced-techniques"
          }
        ]
      }
    },
    {
      "id": "19lTWqAvZFT2CDlhLlPSq",
      "name": "Uptime and Load",
      "resources": {
        "description": "# Uptime and Load\n\nThe `uptime` command shows system running time and load averages for 1, 5, and 15-minute intervals. Load average indicates computational work and processes waiting for CPU time. High load suggests insufficient resources or misconfigurations. Example: `uptime` shows \"2 days, 20 min\" uptime and \"0.00, 0.01, 0.05\" load averages. Essential for performance monitoring and capacity planning.",
        "resources": [
          {
            "type": "article",
            "title": "Linux Uptime Command With Usage Examples",
            "url": "https://www.tecmint.com/linux-uptime-command-examples/"
          },
          {
            "type": "article",
            "title": "How to Check Uptime in Linux Command Line",
            "url": "https://linuxhandbook.com/uptime-command/"
          },
          {
            "type": "article",
            "title": "Linux Load Average: What is Load Average in Linux?",
            "url": "https://www.digitalocean.com/community/tutorials/load-average-in-linux"
          }
        ]
      }
    },
    {
      "id": "WwybfdKuP9ogCGpT7d3NU",
      "name": "Authentication Logs",
      "resources": {
        "description": "# Authentication Logs\n\nAuthentication logs in Linux record all auth-related events like logins, password changes, and sudo commands. Located at `/var/log/auth.log` (Debian) or `/var/log/secure` (RHEL/CentOS), these logs help detect brute force attacks and unauthorized access attempts. Use `tail /var/log/auth.log` to view recent entries. Regular log analysis is essential for server security monitoring.\n\nHere is an example of how you can use the `tail` command to view the last few entries of the authentication log:\n\n```bash\ntail /var/log/auth.log\n```",
        "resources": [
          {
            "type": "article",
            "title": "Monitoring Linux Authentication Logs",
            "url": "https://betterstack.com/community/guides/logging/monitoring-linux-auth-logs/"
          },
          {
            "type": "article",
            "title": "How to Check Linux Login History - Linux Handbook",
            "url": "https://linuxhandbook.com/linux-login-history/"
          }
        ]
      }
    },
    {
      "id": "ewUuI_x-YhOQIYd3MTgJJ",
      "name": "Services Running",
      "resources": {
        "description": "# Running Services\n\nLinux servers run various services including web, database, DNS, and mail servers. System administrators use tools like `systemctl`, `service`, `netstat`, `ss`, and `lsof` to manage and monitor services. Use `systemctl --type=service` to list all active services with their status. Essential for server management, resource monitoring, and troubleshooting.",
        "resources": [
          {
            "type": "article",
            "title": "How to List Linux Services With systemctl",
            "url": "https://www.howtogeek.com/839285/how-to-list-linux-services-with-systemctl/"
          },
          {
            "type": "article",
            "title": "Service Management in Linux: A Comprehensive Guide",
            "url": "https://medium.com/@thesureshvadde/service-management-in-linux-a-comprehensive-guide-cb4c7e81dfa9"
          },
          {
            "type": "article",
            "title": "How to Manage Services in Linux: systemd and SysVinit",
            "url": "https://dev.to/iaadidev/how-to-manage-services-in-linux-systemd-and-sysvinit-essentials-devops-prerequisite-8-1jop"
          }
        ]
      }
    },
    {
      "id": "tx0nh6cbBjVxwNlyrBNYm",
      "name": "Available Memory / Disk",
      "resources": {
        "description": "# Available Memory and Disk\n\nLinux provides tools like `free`, `vmstat`, and `top` to monitor system memory usage and performance. The `free -h` command shows total, used, free, shared, buffer/cache, and available memory in human-readable format. Regular memory monitoring helps maintain optimal server performance, prevent overload, and troubleshoot resource issues effectively.",
        "resources": [
          {
            "type": "article",
            "title": "5 Best Ways To Check Available Memory In Linux",
            "url": "https://itslinuxfoss.com/5-ways-check-available-memory-linux/"
          },
          {
            "type": "article",
            "title": "Free vs. Available Memory in Linux",
            "url": "https://linuxblog.io/free-vs-available-memory-in-linux/"
          }
        ]
      }
    },
    {
      "id": "h01Y6dW09ChidlM2HYoav",
      "name": "Process Management",
      "resources": {
        "description": "# Process Management\n\nLinux treats every running program as a process. Process management commands help view, control, and manipulate these processes. Key commands: `ps aux` shows running processes, `top` provides live system view, `kill -SIGTERM pid` gracefully stops processes, `kill -SIGKILL pid` forcefully terminates processes. Essential for understanding and controlling Linux system operations effectively.",
        "resources": [
          {
            "type": "article",
            "title": "The Complete Guide to Process Management Commands",
            "url": "https://thelinuxcode.com/process-management-commands-linux/"
          },
          {
            "type": "article",
            "title": "Commands for Process Management in Linux",
            "url": "https://www.digitalocean.com/community/tutorials/process-management-in-linux"
          }
        ]
      }
    },
    {
      "id": "mUKoiGUTpIaUgQNF3BND_",
      "name": "Background / Foreground Processes",
      "resources": {
        "description": "# Background and Foreground Processes\n\nLinux processes run in foreground (taking direct user input) or background (running independently). Send processes to background with `&` or `bg` command. Bring to foreground with `fg`. Use Ctrl+Z to pause, then `bg` to resume in background. Part of job control for managing multiple tasks simultaneously from single terminal.",
        "resources": [
          {
            "type": "article",
            "title": "Understanding Foreground and Background Processes",
            "url": "https://linuxconfig.org/understanding-foreground-and-background-linux-processes"
          },
          {
            "type": "article",
            "title": "Running Linux Commands in Background and Foreground",
            "url": "https://linuxhandbook.com/run-process-background/"
          },
          {
            "type": "article",
            "title": "Foreground and Background Processes - LinuxOPsys",
            "url": "https://linuxopsys.com/foreground-and-background-processes-co11/"
          }
        ]
      }
    },
    {
      "id": "lf3_CRyOI2ZXGzz5ff451",
      "name": "Listing / Finding Processes",
      "resources": {
        "description": "# Listing and Finding Processes\n\nLinux processes can be monitored using the `proc` virtual filesystem and commands like `ps`, `top`, and `htop`. Use `ps -ef` for process snapshots, `top`/`htop` for real-time views. The `/proc` directory contains detailed process information. View specific process details with `cat /proc/{PID}/status`. Essential for system performance monitoring and troubleshooting.",
        "resources": [
          {
            "type": "article",
            "title": "The /proc File System",
            "url": "https://www.kernel.org/doc/html/latest/filesystems/proc.html"
          },
          {
            "type": "article",
            "title": "What is a Process in Linux/Unix?",
            "url": "https://www.scaler.com/topics/linux-process/"
          },
          {
            "type": "article",
            "title": "Exploring the Linux /proc Filesystem",
            "url": "https://www.redhat.com/en/blog/linux-proc-filesystem"
          }
        ]
      }
    },
    {
      "id": "VkLWTvKnRXzvLGWza2v45",
      "name": "Process Signals",
      "resources": {
        "description": "# Process Signals\n\nProcess signals are communication mechanisms in Linux that notify processes of synchronous or asynchronous events. Common signals include SIGINT, SIGSTOP, SIGKILL for interrupting, pausing, or terminating processes. Example: `kill -SIGSTOP 12345` suspends process with PID 12345 until `SIGCONT` is received. Essential for comprehensive process management and resource allocation.",
        "resources": [
          {
            "type": "article",
            "title": "Process signals",
            "url": "https://linuxjourney.com/lesson/process-signals"
          },
          {
            "type": "article",
            "title": "Understanding Linux Process Signals",
            "url": "https://www.ceos3c.com/linux/understanding-linux-process-signals-a-complete/"
          },
          {
            "type": "article",
            "title": "Linux Process Signals and their meaning",
            "url": "https://linux-audit.com/processes/linux-process-signals/"
          }
        ]
      }
    },
    {
      "id": "0FLUI9r7znMqi6YKReLzD",
      "name": "Killing Processes",
      "resources": {
        "description": "# Killing Processes\n\nThe `kill` command terminates processes in Linux by sending signals to specific Process IDs (PIDs). Use `kill [signal] PID` to terminate processes manually. Different signals provide various termination methods - SIGTERM for graceful shutdown, SIGKILL for forced termination. Process termination is essential for managing unresponsive or unwanted processes.",
        "resources": [
          {
            "type": "article",
            "title": "Killing Processes",
            "url": "https://linuxjourney.com/lesson/killing-processes"
          },
          {
            "type": "article",
            "title": "Using Kill Command in Linux",
            "url": "https://linuxhandbook.com/kill-command/"
          },
          {
            "type": "article",
            "title": "Kill Command in Linux",
            "url": "https://linuxize.com/post/kill-command-in-linux/"
          }
        ]
      }
    },
    {
      "id": "5anSYRhaKIs3dCLWlvZfT",
      "name": "Process Priorities",
      "resources": {
        "description": "# Process Priorities\n\nLinux assigns priority levels to processes, affecting execution timing and resource allocation. Process priorities use \"nice\" values ranging from -20 (highest priority) to +19 (lowest priority) and only root can set negative nice value. The `/proc` filesystem contains process information including priorities. You can view priorities with `ps -eo pid,pri,user,comm` and modify them using `renice` command.\n\nVisit the following resource to learn more:\n\n- [@article@Understanding Process Thread Priorities in Linux](https://blogs.oracle.com/linux/post/task-priority)\n- [@article@How To Manipulate Process Priority In Linux](https://www.itsmarttricks.com/how-to-manipulate-process-priority-in-linux-using-nice-and-renice-commands/)",
        "resources": [
          {
            "type": "article",
            "title": "Understanding Process Thread Priorities in Linux",
            "url": "https://blogs.oracle.com/linux/post/task-priority"
          },
          {
            "type": "article",
            "title": "How To Manipulate Process Priority In Linux",
            "url": "https://www.itsmarttricks.com/how-to-manipulate-process-priority-in-linux-using-nice-and-renice-commands/"
          }
        ]
      }
    },
    {
      "id": "Rib7h9lh_ndiXkwNbftz_",
      "name": "Process Forking",
      "resources": {
        "description": "# Process Forking\n\nProcess forking uses the `fork()` system call to create child processes from parent processes, enabling concurrent execution. Child processes are nearly perfect copies of parents with different PIDs. Changes in child processes don't affect parents. Essential for understanding Linux process creation and control in multi-processing environments.",
        "resources": [
          {
            "type": "article",
            "title": "fork — Linux manual page",
            "url": "https://www.man7.org/linux/man-pages/man2/fork.2.html"
          },
          {
            "type": "article",
            "title": "Understanding the fork() System Call in Linux",
            "url": "https://thelinuxcode.com/fork-system-call-linux/"
          },
          {
            "type": "article",
            "title": "Linux Process calls: Creating process using fork",
            "url": "https://medium.com/@joshuaudayagiri/linux-process-calls-creating-process-using-fork-52a1eac7de8b"
          }
        ]
      }
    },
    {
      "id": "g6n7f1Qi0BPr_BGvisWuz",
      "name": "User Management",
      "resources": {
        "description": "# User Management\n\nLinux user management allows multiple users to interact with the system in isolation. Includes creating, deleting, modifying users and groups, assigning permissions and ownership. Key commands: `adduser`/`useradd` creates users, `deluser`/`userdel` removes users, `passwd` manages passwords, `su` switches users. Essential for providing proper accessibility and maintaining Linux system security.",
        "resources": [
          {
            "type": "article",
            "title": "User Account Management",
            "url": "https://labex.io/tutorials/linux-user-account-management-49"
          },
          {
            "type": "article",
            "title": "Creating, Modifying, and Deleting User Accounts",
            "url": "https://serveracademy.com/courses/linux-server-administration/creating-modifying-and-deleting-user-accounts/"
          },
          {
            "type": "article",
            "title": "User Management in Linux: A Beginner's Guide",
            "url": "https://dev.to/austinozor/user-management-in-linux-a-beginners-guide-to-creating-modifying-and-deleting-users-fhf"
          }
        ]
      }
    },
    {
      "id": "R9TZfkgVUQNLnMpDhovJa",
      "name": "Create / Delete / Update",
      "resources": {
        "description": "# Create, Update, and Delete Users\n\nLinux user management involves creating, updating, and deleting user accounts for system security and resource utilization. Key commands: `useradd`/`adduser` (create users), `usermod` (update user details like home directory/shell), `userdel` (delete users). Essential for maintaining secure, organized multi-user system environments and efficient resource allocation.",
        "resources": [
          {
            "type": "article",
            "title": "Creating, Modifying, and Deleting User Accounts",
            "url": "https://serveracademy.com/courses/linux-server-administration/creating-modifying-and-deleting-user-accounts/"
          },
          {
            "type": "article",
            "title": "How to create, update, and delete users account on Linux",
            "url": "https://linuxconfig.org/how-to-create-modify-and-delete-users-account-on-linux"
          },
          {
            "type": "article",
            "title": "User Management in Linux: A Beginner's Guide",
            "url": "https://dev.to/austinozor/user-management-in-linux-a-beginners-guide-to-creating-modifying-and-deleting-users-fhf"
          }
        ]
      }
    },
    {
      "id": "h8wc8XEwWYHErna68w7Mg",
      "name": "Users and Groups",
      "resources": {
        "description": "# Users and Groups\n\nUser management in Linux uses groups to organize users and manage permissions efficiently. Groups are collections of users that simplify system administration by controlling access to resources like files and directories. Users can belong to multiple groups, enabling precise privilege management. Commands like `groupadd`, `groupdel`, `groupmod`, `usermod`, and `gpasswd` manage groups effectively. Proper group management is crucial for a secure and organized system environment.",
        "resources": [
          {
            "type": "article",
            "title": "How to create, delete, and modify groups in Linux",
            "url": "https://www.redhat.com/sysadmin/linux-groups"
          },
          {
            "type": "article",
            "title": "How to Manage Groups on Linux",
            "url": "https://linuxconfig.org/how-to-manage-groups-on-linux"
          },
          {
            "type": "article",
            "title": "Creating, Modifying, and Deleting User Accounts",
            "url": "https://serveracademy.com/courses/linux-server-administration/creating-modifying-and-deleting-user-accounts/"
          },
          {
            "type": "article",
            "title": "User Management in Linux: A Beginner's Guide",
            "url": "https://dev.to/austinozor/user-management-in-linux-a-beginners-guide-to-creating-modifying-and-deleting-users-fhf"
          }
        ]
      }
    },
    {
      "id": "L6RMExeqi9501y-eCHDt1",
      "name": "Managing Permissions",
      "resources": {
        "description": "# Permissions\n\nLinux permissions control file and directory access for users, groups, and others with read, write, and execute types. Commands include `chmod` (change permissions), `chown` (change owner), and `chgrp` (change group). Proper permission management is crucial for system security and organization. Essential for maintaining controlled access to system resources.",
        "resources": [
          {
            "type": "article",
            "title": "Understanding Linux File Permissions",
            "url": "https://linuxize.com/post/understanding-linux-file-permissions/"
          },
          {
            "type": "article",
            "title": "Linux File Permissions",
            "url": "https://linuxhandbook.com/linux-file-permissions/"
          },
          {
            "type": "article",
            "title": "Linux Permissions of Files",
            "url": "https://labex.io/tutorials/linux-permissions-of-files-270252"
          },
          {
            "type": "video",
            "title": "Linux File Permissions in 5 Minutes",
            "url": "https://www.youtube.com/watch?v=LnKoncbQBsM"
          }
        ]
      }
    },
    {
      "id": "F1sU3O1ouxTOvpidDfN3k",
      "name": "Service Management (systemd)",
      "resources": {
        "description": "# Service Management\n\nService management controls Linux services (daemons) during boot and shutdown processes. Common systemctl commands include start, stop, restart, reload, status, enable/disable. Modern Linux uses systemd while older systems use SystemV or Upstart. Example: `sudo systemctl start sshd` starts SSH service. Essential skill for Linux system administration and maintaining secure, stable systems.",
        "resources": [
          {
            "type": "article",
            "title": "How to Master Linux Service Management with Systemctl",
            "url": "https://labex.io/tutorials/linux-how-to-master-linux-service-management-with-systemctl-392864"
          },
          {
            "type": "article",
            "title": "Service Management in Linux: A Comprehensive Guide",
            "url": "https://medium.com/@thesureshvadde/service-management-in-linux-a-comprehensive-guide-cb4c7e81dfa9"
          },
          {
            "type": "article",
            "title": "How to Manage Services in Linux: systemd and SysVinit",
            "url": "https://dev.to/iaadidev/how-to-manage-services-in-linux-systemd-and-sysvinit-essentials-devops-prerequisite-8-1jop"
          }
        ]
      }
    },
    {
      "id": "34UUrc8Yjc_8lvTL8itc3",
      "name": "Creating New Services",
      "resources": {
        "description": "# Service Status\n\nService status shows the current state of Linux services including network processes, backend servers, and background applications. Use `systemctl status service_name` to check service states through systemd manager. Example: `systemctl status apache2.service` shows Apache web server status. Essential for diagnosing problems, maintaining performance, and preventing service downtimes.",
        "resources": [
          {
            "type": "article",
            "title": "Service Management in Linux: A Comprehensive Guide",
            "url": "https://medium.com/@thesureshvadde/service-management-in-linux-a-comprehensive-guide-cb4c7e81dfa9"
          },
          {
            "type": "article",
            "title": "Use Systemctl Status Command to Check Service Status",
            "url": "https://linuxhandbook.com/systemctl-check-service-status/"
          },
          {
            "type": "article",
            "title": "How to Check All Running Services in Linux",
            "url": "https://www.2daygeek.com/how-to-check-all-running-services-in-linux/"
          }
        ]
      }
    },
    {
      "id": "FStz-bftQBK0M6zz2Bxl4",
      "name": "Checking Service Logs",
      "resources": {
        "description": "# Start and Stop Services\n\nLinux service management controls system services like firewall, network, and database using `systemctl` commands. Basic operations: `sudo systemctl start service_name` (start), `sudo systemctl stop service_name` (stop), `sudo systemctl restart service_name` (restart). Root permissions required. Essential for system administrators managing updates and configuration changes.",
        "resources": [
          {
            "type": "article",
            "title": "Service Management in Linux: A Comprehensive Guide",
            "url": "https://medium.com/@thesureshvadde/service-management-in-linux-a-comprehensive-guide-cb4c7e81dfa9"
          },
          {
            "type": "article",
            "title": "How to Master Linux Service Management with Systemctl",
            "url": "https://labex.io/tutorials/linux-how-to-master-linux-service-management-with-systemctl-392864"
          },
          {
            "type": "article",
            "title": "How to Manage Services in Linux: systemd and SysVinit",
            "url": "https://dev.to/iaadidev/how-to-manage-services-in-linux-systemd-and-sysvinit-essentials-devops-prerequisite-8-1jop"
          }
        ]
      }
    },
    {
      "id": "DuEfJNrm4Jfmp8-8Pggrf",
      "name": "Starting / Stopping Services",
      "resources": {
        "description": "# Checking Service Logs\n\nSystem logs are essential for troubleshooting and monitoring Linux systems. Most logs are stored in `/var/log` directory and managed by systemd. Use `journalctl` to view system logs and `journalctl -u service_name` for specific service logs. The `dmesg` command displays kernel messages. Regular log monitoring is crucial for system administration.",
        "resources": [
          {
            "type": "article",
            "title": "How to Use journalctl Command to Analyze Logs in Linux",
            "url": "https://linuxhandbook.com/journalctl-command/"
          },
          {
            "type": "article",
            "title": "journalctl — Linux manual page",
            "url": "https://www.man7.org/linux/man-pages/man1/journalctl.1.html"
          },
          {
            "type": "article",
            "title": "Linux Log Files Location & How To View Logs Files",
            "url": "https://www.cyberciti.biz/faq/linux-log-files-location-and-how-do-i-view-logs-files/"
          }
        ]
      }
    },
    {
      "id": "xk5Xgi797HlVjdZJRfwX1",
      "name": "Checking Service Status",
      "resources": {
        "description": "# Creating Services\n\nCreating Linux services involves setting up background applications using systemd service files. Services run continuously performing essential tasks like web servers, databases, and mail servers. Create `.service` files in `/etc/systemd/system/` with Unit, Service, and Install sections. Control services using `systemctl` commands. Best practice: avoid running services as root for security.",
        "resources": [
          {
            "type": "article",
            "title": "How to Create a systemd Service in Linux",
            "url": "https://linuxhandbook.com/create-systemd-services/"
          },
          {
            "type": "article",
            "title": "A Beginner's Guide to Creating Linux Services",
            "url": "https://www.fosslinux.com/111815/a-guide-to-creating-linux-services-with-systemd.htm"
          }
        ]
      }
    },
    {
      "id": "4eINX8jYMJxfYh7ZV47YI",
      "name": "Package Management",
      "resources": {
        "description": "# Package Management\n\nPackage management handles software installation, updates, configuration, and removal in Linux. It manages collections of files and tracks software prerequisites automatically. Common package managers include `apt` (Debian-based), `yum`/`dnf` (Red Hat-based), and `pacman` (Arch). Example: `sudo apt install <package-name>` installs packages. Essential for efficient application management.",
        "resources": [
          {
            "type": "course",
            "title": "APT Package Manager",
            "url": "https://www.debian.org/doc/manuals/apt-guide/index.en.html"
          },
          {
            "type": "course",
            "title": "Yum Package Manager",
            "url": "http://yum.baseurl.org/"
          },
          {
            "type": "course",
            "title": "Using the DNF Software Package Manager",
            "url": "https://docs.fedoraproject.org/en-US/quick-docs/dnf/"
          },
          {
            "type": "article",
            "title": "Linux Package Manager Explained",
            "url": "https://geekflare.com/dev/linux-package-manager-explained/"
          },
          {
            "type": "article",
            "title": "8 Best Package Manager for Linux",
            "url": "https://linuxsimply.com/linux-basics/package-management/best-package-manager/"
          },
          {
            "type": "article",
            "title": "Software Installation on Linux",
            "url": "https://labex.io/tutorials/linux-software-installation-on-linux-18005"
          }
        ]
      }
    },
    {
      "id": "2oQiuQ2j02SCt9t5eV6hg",
      "name": "Package Repositories",
      "resources": {
        "description": "# Repositories\n\nRepositories are storage locations containing collections of software packages for Linux distributions. They store thousands of compiled packages specific to each distribution (.deb for Debian/Ubuntu, .rpm for Fedora/CentOS). Repositories ensure secure, tested software with proper dependencies. Update commands: `sudo apt update` (Ubuntu), `sudo yum update` (CentOS/Fedora). Essential for secure software management.",
        "resources": [
          {
            "type": "course",
            "title": "APT Package Manager",
            "url": "https://www.debian.org/doc/manuals/apt-guide/index.en.html"
          },
          {
            "type": "article",
            "title": "What is Repository in Linux?",
            "url": "https://linuxsimply.com/what-is-repository-in-linux/"
          },
          {
            "type": "article",
            "title": "Official Repositories - ArchWiki",
            "url": "https://wiki.archlinux.org/title/Official_repositories"
          },
          {
            "type": "article",
            "title": "Understanding Linux Repositories",
            "url": "https://blogs.maalavs.com/linux/understanding-linux-repositories/"
          }
        ]
      }
    },
    {
      "id": "Z23eJZjmWoeXQuezR9AhG",
      "name": "Finding & Installing Packages",
      "resources": {
        "description": "# Finding and Installing Packages\n\nLinux package managers like `apt`, `yum`, and `dnf` automate software installation, upgrading, configuring, and removal. Debian-based systems: `sudo apt-get update && sudo apt-get install package-name`. Fedora/CentOS: `sudo dnf update && sudo dnf install package-name`. Package management eliminates manual compilation from source code. Root permissions required for installation.",
        "resources": [
          {
            "type": "course",
            "title": "APT Package Manager",
            "url": "https://www.debian.org/doc/manuals/apt-guide/index.en.html"
          },
          {
            "type": "course",
            "title": "Yum Package Manager",
            "url": "http://yum.baseurl.org/"
          },
          {
            "type": "course",
            "title": "Using the DNF Software Package Manager",
            "url": "https://docs.fedoraproject.org/en-US/quick-docs/dnf/"
          },
          {
            "type": "article",
            "title": "Linux Package Manager Explained",
            "url": "https://geekflare.com/dev/linux-package-manager-explained/"
          },
          {
            "type": "article",
            "title": "8 Best Package Manager for Linux",
            "url": "https://linuxsimply.com/linux-basics/package-management/best-package-manager/"
          }
        ]
      }
    },
    {
      "id": "48wAoAAlCNt3j5mBpKTWC",
      "name": "Listing Installed Packages",
      "resources": {
        "description": "# Listing Installed Packages\n\nLinux distributions use different package managers: `apt` (Debian-based), `dnf` (Fedora), `zypper` (OpenSUSE), `pacman` (Arch). Listing installed packages helps with auditing software and deployment automation. Commands: `sudo apt list --installed` for apt systems, `dnf list installed` for dnf systems. Each distribution has its own syntax for this command.",
        "resources": [
          {
            "type": "course",
            "title": "APT Package Manager",
            "url": "https://www.debian.org/doc/manuals/apt-guide/index.en.html"
          },
          {
            "type": "article",
            "title": "5 ways to list installed packages in Linux",
            "url": "https://www.howtouselinux.com/post/list-installed-packages-in-linux"
          },
          {
            "type": "article",
            "title": "Linux Package Manager Explained",
            "url": "https://geekflare.com/dev/linux-package-manager-explained/"
          }
        ]
      }
    },
    {
      "id": "xEHiB-egkkcBuZmgMoqHT",
      "name": "Install / Remove / Upgrade Packages",
      "resources": {
        "description": "# Install, Remove, and Upgrade Packages\n\nLinux package management handles installing, removing, and upgrading pre-compiled software modules. Different distributions use specific package managers: `apt` (Debian/Ubuntu), `yum`/`dnf` (Fedora/RHEL/CentOS), `zypper` (SUSE). Example installation: `sudo apt-get install packagename`. Each manager has specific commands for removal and upgrades. Critical skill for effective Linux system administration.",
        "resources": []
      }
    },
    {
      "id": "eKyMZn30UxQeBZQ7FxFbF",
      "name": "Snap",
      "resources": {
        "description": "# Snap\n\nSnap is a modern Linux package management system by Canonical providing self-contained packages with all dependencies included. Snaps run consistently across different Linux distributions, install from Snapcraft store, and update automatically. Updates are transactional with automatic rollback on failure. Install packages using `sudo snap install [package-name]` command.",
        "resources": [
          {
            "type": "article",
            "title": "The \"snap\" Command in Linux",
            "url": "https://linuxsimply.com/snap-command-in-linux/"
          },
          {
            "type": "article",
            "title": "How to Install and Use Snap in Various Linux Distributions",
            "url": "https://itsfoss.com/install-snap-linux/"
          }
        ]
      }
    },
    {
      "id": "Fn_uYKigJRgb7r_iYGVBr",
      "name": "Disks and Filesystems",
      "resources": {
        "description": "# Disks and Filesystems\n\nLinux uses various filesystems to organize, store, and retrieve data from storage devices. Popular filesystems include EXT4 (robust for Linux volumes), FAT32 (compatible with all OS for removable media), NTFS, and Btrfs. Each has specific advantages and use cases. Use `df -T` command to display filesystem types, disk space usage, and mounted device information.",
        "resources": [
          {
            "type": "course",
            "title": "Filesystems in the Linux Kernel",
            "url": "https://www.kernel.org/doc/html/v6.16-rc2/filesystems/index.html"
          },
          {
            "type": "article",
            "title": "Partitions And Filesystems In Linux - Introduction",
            "url": "https://www.linuxfordevices.com/tutorials/linux/partitions-and-filesystems"
          },
          {
            "type": "article",
            "title": "Overview of File System Hierarchy Standard (FHS)",
            "url": "https://access.redhat.com/documentation/ru-ru/red_hat_enterprise_linux/4/html/reference_guide/s1-filesystem-fhs#s3-filesystem-usr"
          },
          {
            "type": "article",
            "title": "Understanding Linux Filesystems: Inodes, Block Sizes, and Data",
            "url": "https://www.linuxjournal.com/content/understanding-linux-filesystems-inodes-block-sizes-and-data-structures"
          }
        ]
      }
    },
    {
      "id": "AwQJYL60NNbA5_z7iLcM7",
      "name": "Inodes",
      "resources": {
        "description": "# Inodes\n\nAn inode (index node) is a data structure in Linux filesystems that stores metadata about files and directories except their names and actual data. Contains file size, owner, permissions, timestamps, and more. Each file has a unique inode number for identification. Understanding inodes helps with advanced operations like linking and file recovery. Use `ls -i filename` to view inode numbers.",
        "resources": [
          {
            "type": "article",
            "title": "Introduction to Inodes",
            "url": "https://linuxjourney.com/lesson/inodes"
          },
          {
            "type": "article",
            "title": "Index Nodes — The Linux Kernel documentation",
            "url": "https://www.kernel.org/doc/html/latest/filesystems/ext4/inodes.html?highlight=inode"
          }
        ]
      }
    },
    {
      "id": "LFPhSHOhUqM98fUxMjQUw",
      "name": "Filesystems",
      "resources": {
        "description": "# Filesystems\n\nFilesystems define how files are stored and organized on Linux storage disks, ensuring data integrity, reliability, and efficient access. Linux supports various types like EXT4, XFS, BTRFS with different performance and recovery capabilities. All files start from root directory '/'. Use `df -T` to display filesystem types and disk usage status. Essential for Linux administration tasks.",
        "resources": [
          {
            "type": "course",
            "title": "Filesystems in the Linux Kernel",
            "url": "https://www.kernel.org/doc/html/v6.16-rc2/filesystems/index.html"
          },
          {
            "type": "article",
            "title": "df command in Linux (Check Disk Space)",
            "url": "https://linuxize.com/post/how-to-check-disk-space-in-linux-using-the-df-command/"
          },
          {
            "type": "article",
            "title": "Partitions And Filesystems In Linux - Introduction",
            "url": "https://www.linuxfordevices.com/tutorials/linux/partitions-and-filesystems"
          }
        ]
      }
    },
    {
      "id": "AWosNs2nvDGV8r6WvgBI1",
      "name": "Swap",
      "resources": {
        "description": "# Swap Space\n\nSwap space extends physical memory by using disk storage when RAM is full. Inactive memory pages move to swap, freeing RAM but with performance impact due to slower disk access. Swap can exist as dedicated partitions or regular files. Create with `fallocate`, `mkswap`, and `swapon` commands. Critical for memory management and system stability optimization.",
        "resources": [
          {
            "type": "article",
            "title": "Swap - Arch Wiki",
            "url": "https://wiki.archlinux.org/title/Swap"
          },
          {
            "type": "article",
            "title": "How to Increase Swap Space on Linux",
            "url": "https://linuxconfig.org/how-to-increase-swap-space-on-linux"
          }
        ]
      }
    },
    {
      "id": "zmb5lK_EGMAChPoPvP9E0",
      "name": "Mounts",
      "resources": {
        "description": "# Mounts\n\nMounting in Linux attaches filesystems to specific directories (mount points) in the directory tree, allowing the OS to access data on storage devices. The `mount` command performs this operation. Example: `mount /dev/sdb1 /mnt` mounts second partition to `/mnt` directory. The `/mnt` directory is conventionally used for temporary mounting operations. Essential for Linux disk and filesystem management.",
        "resources": [
          {
            "type": "course",
            "title": "The `mount` command manual page",
            "url": "https://man7.org/linux/man-pages/man8/mount.8.html"
          },
          {
            "type": "article",
            "title": "Mounting, unmounting and the /mnt directory - The Linux Documentation Project",
            "url": "https://tldp.org/LDP/Linux-Filesystem-Hierarchy/html/mnt.html"
          },
          {
            "type": "article",
            "title": "Linux `mount` command with Examples",
            "url": "https://phoenixnap.com/kb/linux-mount-command"
          }
        ]
      }
    },
    {
      "id": "4xBaZPk0eSsWG1vK3e2yW",
      "name": "Adding Disks",
      "resources": {
        "description": "# Adding Disks\n\nAdding disks in Linux involves partitioning, creating filesystems, and mounting. Use `lsblk` to list devices, `fdisk /dev/sdX` to create partitions, `mkfs.ext4 /dev/sdX1` to create filesystems, and `mount /dev/sdX1 /mount/point` to mount. This process prepares new storage devices for seamless integration into the Linux filesystem hierarchy.",
        "resources": [
          {
            "type": "article",
            "title": "How to Add a New Disk",
            "url": "https://linuxconfig.org/how-to-add-new-disk-to-existing-linux-system"
          },
          {
            "type": "article",
            "title": "How to Add a New Disk to an Existing Linux Server",
            "url": "https://www.tecmint.com/add-new-disk-to-an-existing-linux/"
          }
        ]
      }
    },
    {
      "id": "I3LNa1cM_zRkBy8wKdz3g",
      "name": "LVM",
      "resources": {
        "description": "# LVM (Logical Volume Manager)\n\nLVM provides logical volume management through device mapper framework, offering flexible disk management with resizing, mirroring, and moving capabilities. Three levels: Physical Volumes (PVs - actual disks), Volume Groups (VGs - storage pools), and Logical Volumes (LVs - carved portions). Create with `pvcreate`, `vgcreate`, and `lvcreate` commands. Essential for enterprise storage systems.",
        "resources": [
          {
            "type": "article",
            "title": "The Complete Beginner's Guide to LVM in Linux",
            "url": "https://linuxhandbook.com/lvm-guide/"
          },
          {
            "type": "article",
            "title": "A Beginner's Guide to LVM in Linux - It's FOSS",
            "url": "https://itsfoss.com/lvm-guide/"
          }
        ]
      }
    },
    {
      "id": "DQEa8LrJ9TVW4ULBE4aHJ",
      "name": "Booting Linux",
      "resources": {
        "description": "# Booting Linux\n\nLinux booting involves several stages: POST, MBR, GRUB, Kernel, Init, and GUI/CLI. The bootloader loads the kernel into memory, which detects hardware, loads drivers, mounts filesystems, starts system processes, and presents login prompts. GRUB configuration is managed through `/etc/default/grub` with settings like timeout and default boot options.",
        "resources": [
          {
            "type": "course",
            "title": "The GNU GRUB",
            "url": "https://www.gnu.org/software/grub/"
          },
          {
            "type": "article",
            "title": "Booting process of Linux - Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Booting_process_of_Linux"
          },
          {
            "type": "article",
            "title": "The Linux Booting Process",
            "url": "https://thelinuxcode.com/the-linux-booting-process-6-steps-described-in-detail/"
          }
        ]
      }
    },
    {
      "id": "ru7mpLQZKE1QxAdiA1sS3",
      "name": "Logs",
      "resources": {
        "description": "# System Logs\n\nLinux maintains logs documenting system activities, errors, and kernel messages. Boot logs record all operations during system startup for troubleshooting. Use `dmesg` to view kernel ring buffer messages in real-time, or access logs in `/var/log`. Systemd uses `journalctl` for logging. Log levels range from emergency (system unusable) to debug messages.",
        "resources": [
          {
            "type": "article",
            "title": "How to Use journalctl Command to Analyze Logs in Linux",
            "url": "https://linuxhandbook.com/journalctl-command/"
          },
          {
            "type": "article",
            "title": "How to Check System Logs on Linux",
            "url": "https://www.fosslinux.com/8984/how-to-check-system-logs-on-linux-complete-usage-guide.htm"
          },
          {
            "type": "article",
            "title": "What is dmesg in Linux, And How Do I Use It?",
            "url": "https://linuxconfig.org/what-is-dmesg-and-how-do-i-use-it"
          }
        ]
      }
    },
    {
      "id": "o5lSQFW-V_PqndGqo1mp3",
      "name": "Boot Loaders",
      "resources": {
        "description": "# Boot Loaders\n\nBoot loaders load the OS kernel into memory when systems start. Common Linux boot loaders include GRUB (modern, feature-rich with graphical interface) and LILO (older, broader hardware support). Boot loaders initialize hardware, load drivers, start schedulers, and execute init processes. Use `sudo update-grub` to update GRUB configuration. Enable multi-OS booting on single machines.",
        "resources": [
          {
            "type": "course",
            "title": "The GNU GRUB",
            "url": "https://www.gnu.org/software/grub/"
          },
          {
            "type": "article",
            "title": "Bootloader - Archlinux wiki",
            "url": "https://wiki.archlinux.org/title/Arch_boot_process#Boot_loader"
          },
          {
            "type": "article",
            "title": "Most Popular Linux Boot Loaders",
            "url": "https://thelinuxcode.com/what-is-a-boot-loader/"
          },
          {
            "type": "article",
            "title": "GRUB Bootloader in Linux",
            "url": "https://phoenixnap.com/kb/what-is-grub"
          }
        ]
      }
    },
    {
      "id": "Mb42VFjCzMZn_PovKIfKx",
      "name": "Networking",
      "resources": {
        "description": "# Networking\n\nLinux networking enables system connections and resource sharing across platforms with robust management tools. Network configurations stored in `/etc/network/interfaces`. Key commands include `ifconfig` (deprecated) and `ip` for interface management. Supports various protocols with excellent scalability. Essential for system connectivity and network troubleshooting. Linux adopts a file-based approach for network configuration, storing network-related settings and configurations in standard files, such as `/etc/network/interfaces` or `/etc/sysconfig/network-scripts/`, depending on the Linux distribution.",
        "resources": [
          {
            "type": "article",
            "title": "A Comprehensive Guide to Linux Networking",
            "url": "https://centlinux.com/linux-networking/"
          },
          {
            "type": "article",
            "title": "A Beginner's Guide to Linux Networking Fundamentals",
            "url": "https://dev.to/iaadidev/a-beginners-guide-to-linux-networking-fundamentals-dev-ops-prerequisite-7-434o"
          },
          {
            "type": "article",
            "title": "Practice on Networking Fundamentals",
            "url": "https://linuxjourney.com/lesson/network-basics"
          }
        ]
      }
    },
    {
      "id": "0pciSsiQqIGJh3x8465_s",
      "name": "TCP/IP Stack",
      "resources": {
        "description": "# TCP/IP Stack\n\nTCP/IP (Transmission Control Protocol/Internet Protocol) is the foundational networking protocol suite that enables computer communication over networks. It consists of four layers: Network Interface, Internet, Transport, and Application. In Linux, TCP/IP is integral to the OS functionality, allowing hosts to connect and transfer data across same or different networks.",
        "resources": [
          {
            "type": "article",
            "title": "TCP/IP Commands for Linux",
            "url": "https://whatismyipaddress.com/tcp-ip-commands-linux"
          },
          {
            "type": "article",
            "title": "Netstat Command in Linux",
            "url": "https://phoenixnap.com/kb/netstat-command"
          },
          {
            "type": "article",
            "title": "Netstat Command in Linux: 13 Practical Examples",
            "url": "https://linuxhandbook.com/netstat-command/"
          }
        ]
      }
    },
    {
      "id": "Xszo9vXuwwXZo26seHehD",
      "name": "Subnetting",
      "resources": {
        "description": "# Subnetting\n\nSubnetting divides networks into smaller subnets to improve performance and security in Linux networking. It organizes IP addresses within IP addressing schemes, preventing conflicts and efficiently utilizing address ranges. Use `route -n` to view routing tables and `route add -net xxx.xxx.xxx.x/xx gw yyy.yyy.yyy.y` to add subnets. Essential for complex networking environments.",
        "resources": [
          {
            "type": "article",
            "title": "Understanding IP Addressing and Subnetting in Linux",
            "url": "https://useful.codes/understanding-ip-addressing-and-subnetting-in-linux/"
          },
          {
            "type": "article",
            "title": "The Basics of IP Subnetting | Linux Journal",
            "url": "https://www.linuxjournal.com/article/6287"
          },
          {
            "type": "article",
            "title": "How to Find Subnet Mask in Linux",
            "url": "https://www.howtouselinux.com/post/find-subnet-mask-on-linux"
          }
        ]
      }
    },
    {
      "id": "4ees23q281J1DPVAc7iXd",
      "name": "Ethernet & arp/rarp",
      "resources": {
        "description": "# Ethernet, ARP and RARP\n\nThree crucial Linux networking components: Ethernet enables LAN device communication, ARP (Address Resolution Protocol) translates IP addresses to MAC addresses for direct network communication, and RARP (Reverse ARP) converts MAC addresses to IP addresses when devices know their MAC but need their IP. Essential for diagnosing and managing Linux networking issues.",
        "resources": [
          {
            "type": "article",
            "title": "A Comprehensive guide to Linux Networking",
            "url": "https://centlinux.com/linux-networking/"
          },
          {
            "type": "article",
            "title": "A Beginner's Guide to Linux Networking Fundamentals",
            "url": "https://dev.to/iaadidev/a-beginners-guide-to-linux-networking-fundamentals-dev-ops-prerequisite-7-434o"
          },
          {
            "type": "video",
            "title": "ARP Explained - Address Resolution Protocol",
            "url": "https://www.youtube.com/watch?v=cn8Zxh9bPio"
          },
          {
            "type": "video",
            "title": "What is Ethernet?",
            "url": "https://www.youtube.com/watch?v=HLziLmaYsO0"
          }
        ]
      }
    },
    {
      "id": "X6Jw95kbyPgsDNRhvkQP9",
      "name": "DHCP",
      "resources": {
        "description": "# DHCP\n\nDHCP (Dynamic Host Configuration Protocol) automatically allocates IP addresses and network configuration to clients, ensuring unique addresses for each machine. In Linux, install with `sudo apt-get install isc-dhcp-server` and configure via `/etc/dhcp/dhcpd.conf`. DHCP servers require static IPs for effective management and can handle DNS and network data. The DHCP server effectively manages the IP addresses and information related to them, making sure that each client machine gets a unique IP and all the correct network information.\n\nVisit the following sources to learn more:\n\n- [@article@Dynamic Host Configuration Protocol - Wikipedia](https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol)\n- [@article@DHCP Protocol: How Dynamic Host Configuration Protocol Works](https://network-guides.com/dhcp-protocol/)",
        "resources": [
          {
            "type": "article",
            "title": "Dynamic Host Configuration Protocol - Wikipedia",
            "url": "https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol"
          },
          {
            "type": "article",
            "title": "DHCP Protocol: How Dynamic Host Configuration Protocol Works",
            "url": "https://network-guides.com/dhcp-protocol/"
          }
        ]
      }
    },
    {
      "id": "D0yUzzaJsfhtdBWMtquAj",
      "name": "IP Routing",
      "resources": {
        "description": "# IP Routing\n\nIP routing in Linux involves configuring routing tables and network routes for packet forwarding across networks. The kernel handles route selection to send packets to their destinations. Use the `ip` command (replacing deprecated `ifconfig`) for network configuration. Example: `ip route show` displays all kernel-known routes for network troubleshooting and management.",
        "resources": [
          {
            "type": "article",
            "title": "Linux Set Up Routing with ip Command",
            "url": "https://www.cyberciti.biz/faq/howto-linux-configuring-default-route-with-ipcommand/"
          },
          {
            "type": "article",
            "title": "Linux Networking: A Simplified Guide to IP Addresses",
            "url": "https://www.linuxjournal.com/content/linux-networking-simplified-guide-ip-addresses-and-routing"
          }
        ]
      }
    },
    {
      "id": "f5oQYhmjNM2_FD7Qe1zGK",
      "name": "DNS Resolution",
      "resources": {
        "description": "# DNS Resolution\n\nDNS (Domain Name System) converts hostnames to IP addresses, enabling users to access websites without remembering numeric addresses. Linux systems use `/etc/resolv.conf` to configure DNS resolution. Applications consult the DNS resolver, which communicates with DNS servers for address translation. Use `nslookup` or `dig` commands to query DNS and troubleshoot network connectivity issues.",
        "resources": [
          {
            "type": "article",
            "title": "Setup DNS Resolution With \"resolv.conf\" in Examples",
            "url": "https://www.shellhacks.com/setup-dns-resolution-resolvconf-example/"
          },
          {
            "type": "article",
            "title": "DNS Resolution",
            "url": "https://wiki.archlinux.org/title/Domain_name_resolution"
          },
          {
            "type": "article",
            "title": "nslookup command",
            "url": "https://linuxconfig.org/nslookup-linux-command"
          },
          {
            "type": "article",
            "title": "dig command",
            "url": "https://linuxhandbook.com/dig-command/"
          }
        ]
      }
    },
    {
      "id": "bZ8Yj6QfBeDdh8hRM_aZs",
      "name": "Netfilter",
      "resources": {
        "description": "# Netfilter\n\nNetfilter is a Linux kernel framework for manipulating and filtering network packets with hooks at various stages (pre-routing, input, forward, output, post-routing). Used for firewalls and NAT management with iptables configuration. Essential for traffic control, packet modification, logging, and intrusion detection in Linux networking systems.",
        "resources": [
          {
            "type": "course",
            "title": "netfilter/iptables project homepage",
            "url": "https://netfilter.org/"
          },
          {
            "type": "article",
            "title": "Packet filtering in Linux - iptables, nftables and firewalld",
            "url": "https://wyssmann.com/blog/2021/07/packet-filtering-in-linux-iptables-nftables-and-firewalld/"
          }
        ]
      }
    },
    {
      "id": "uk6UMuI8Uhf02TBAGVeLS",
      "name": "SSH",
      "resources": {
        "description": "# SSH\n\nSSH (Secure Shell) is a cryptographic network protocol providing secure remote access, command execution, and data communication between networked computers. Replaces insecure protocols like Telnet with confidentiality, integrity, and security. Use `ssh username@server_ip_address` to connect to remote Linux servers. Essential for secure system administration and remote management.",
        "resources": [
          {
            "type": "article",
            "title": "Secure Shell",
            "url": "https://en.wikipedia.org/wiki/Secure_Shell"
          },
          {
            "type": "article",
            "title": "Mastering SSH - A Complete Guide to Secure Shell Protocol",
            "url": "https://www.socketxp.com/iot/ssh-secure-shell/"
          },
          {
            "type": "article",
            "title": "What is SSH? | Secure Shell (SSH) Protocol - Cloudflare",
            "url": "https://www.cloudflare.com/learning/access-management/what-is-ssh/"
          }
        ]
      }
    },
    {
      "id": "tVrbVcNEfc11FbEUoO2Dk",
      "name": "File Transfer",
      "resources": {
        "description": "# File Transfer\n\nLinux file transfer involves copying or moving files between systems over networks. Command-line tools support protocols like FTP, HTTP, SCP, SFTP, and NFS. Common commands include `scp`, `rsync`, and `wget`. Example: `scp /local/file username@remote:/destination` copies files to remote systems. These tools make network file sharing streamlined, easier, and more secure.",
        "resources": [
          {
            "type": "article",
            "title": "How to Use Linux FTP Command to Transfer Files",
            "url": "https://linuxize.com/post/how-to-use-linux-ftp-command-to-transfer-files/"
          },
          {
            "type": "article",
            "title": "Rsync Command in Linux with Examples",
            "url": "https://linuxize.com/post/how-to-use-rsync-for-local-and-remote-data-transfer-and-synchronization/"
          },
          {
            "type": "article",
            "title": "Using scp Command in Linux",
            "url": "https://linuxhandbook.com/scp-command/"
          },
          {
            "type": "article",
            "title": "Wget Command in Linux with Examples",
            "url": "https://linuxize.com/post/wget-command-examples/"
          }
        ]
      }
    },
    {
      "id": "4tFZ1PLpz50bddf7zSFrW",
      "name": "Shell Programming",
      "resources": {
        "description": "# Shell Programming\n\nShell programming (scripting) automates administrative tasks, repetitive operations, and system monitoring in Linux. Bash is the default shell and scripting language in most distributions. Scripts are text files executed by the shell, excellent for system automation. Example: `#!/bin/bash echo \"Hello, World!\"` creates a simple script that prints output to terminal.",
        "resources": [
          {
            "type": "article",
            "title": "Learn Shell - Free Interactive Shell Tutorial",
            "url": "https://www.learnshell.org/"
          },
          {
            "type": "article",
            "title": "Bash Scripting Tutorial Series for Beginners",
            "url": "https://linuxhandbook.com/bash/"
          },
          {
            "type": "article",
            "title": "Linux Bash Shell Scripting Tutorial Wiki",
            "url": "https://bash.cyberciti.biz/guide/Main_Page"
          },
          {
            "type": "video",
            "title": "Bash Scripting on Linux - YT Playlist",
            "url": "https://youtube.com/playlist?list=PLT98CRl2KxKGj-VKtApD8-zCqSaN2mD4w&si=MSehStqnhSqgoMSj"
          }
        ]
      }
    },
    {
      "id": "-pW7R76yNIeGf7TQoX4QL",
      "name": "Literals",
      "resources": {
        "description": "# Literals\n\nShell literals are fixed values in source code including string literals (enclosed in quotes), numeric literals (sequences of digits), and boolean literals (1=true, 0=false). String examples: 'Hello, world!' or \"Hello, world!\". Numeric examples: 25, 100, 1234. Understanding literals is fundamental for shell scripting readability and functionality in Linux programming.",
        "resources": [
          {
            "type": "article",
            "title": "Bash Tutorial - Quoting literal text",
            "url": "https://riptutorial.com/bash/example/2465/quoting-literal-text"
          },
          {
            "type": "article",
            "title": "Handling Special Characters in Shell Scripts",
            "url": "https://www.baeldung.com/linux/special-characters-in-shell-scripts"
          }
        ]
      }
    },
    {
      "id": "JyxvZOb7iusOSUYSlniGl",
      "name": "Variables",
      "resources": {
        "description": "# Variables\n\nShell variables store system or user-defined data that can change during script execution. Two categories exist: System Variables (PATH, HOME, PWD) created by Linux, and User-Defined Variables created by users. Define variables with `=` operator and retrieve values with `$` prefix. Example: `MY_VARIABLE=\"Hello World\"` then `echo $MY_VARIABLE` prints the value.",
        "resources": [
          {
            "type": "article",
            "title": "Learning The Shell",
            "url": "https://www.linuxcommand.org/lc3_lts0010.php"
          },
          {
            "type": "article",
            "title": "How to Use Variables in Bash Shell Scripts",
            "url": "https://linuxhandbook.com/bash-variables/"
          },
          {
            "type": "article",
            "title": "How To Read and Set Environmental and Shell Variables",
            "url": "https://www.digitalocean.com/community/tutorials/how-to-read-and-set-environmental-and-shell-variables-on-linux"
          }
        ]
      }
    },
    {
      "id": "WJT-yrMq8cEI87RHWA2jY",
      "name": "Loops",
      "resources": {
        "description": "# Loops\n\nShell loops automate repetitive tasks with three types: `for` (iterates over lists), `while` (executes while condition true), `until` (runs until condition true). Example: `for i in 1 2 3; do echo \"$i\"; done` outputs each number. Essential for script efficiency, automation, and effective Linux shell programming.",
        "resources": [
          {
            "type": "article",
            "title": "Using For, While and Until Loops in Bash",
            "url": "https://linuxhandbook.com/bash-loops/"
          },
          {
            "type": "article",
            "title": "Bash Loops with examples",
            "url": "https://linuxconfig.org/bash-loops-with-examples"
          }
        ]
      }
    },
    {
      "id": "rQxfp7UWqN72iqewZhOdc",
      "name": "Conditionals",
      "resources": {
        "description": "# Conditionals\n\nShell conditionals allow scripts to make decisions based on conditions using `if`, `elif`, and `else` statements. These control process flow by evaluating string variables, arithmetic tests, or process status. Conditions are checked sequentially - if true, the corresponding code block executes; otherwise, it moves to the next condition until finding a match or reaching `else`.",
        "resources": [
          {
            "type": "article",
            "title": "Bash Scripting: Conditionals",
            "url": "https://linuxconfig.org/bash-scripting-conditionals"
          }
        ]
      }
    },
    {
      "id": "rOGnHbGIr3xPCFdpkqoeK",
      "name": "Debugging",
      "resources": {
        "description": "# Debugging\n\nShell script debugging in Linux uses tools like bash's `-x` option for execution traces, `trap`, `set` commands, and external tools like `shellcheck`. Use `#!/bin/bash -x` in scripts or `bash -x script.sh` from command line for tracing. These debugging options help detect, trace, and fix errors to make scripts more efficient and error-proof.\n\nVisit the following sources to learn more:\n\n- [@article@How To Debug a Bash Shell Script Under Linux or UNIX](https://www.cyberciti.biz/tips/debugging-shell-script.html)\n- [@article@How to Debug a Bash Shell Script in Linux](https://www.linuxtechi.com/debugging-shell-scripts-in-linux/)\n- [@article@How to Debug Bash Scripts](https://thelinuxcode.com/debug-bash-script/)",
        "resources": [
          {
            "type": "article",
            "title": "How To Debug a Bash Shell Script Under Linux or UNIX",
            "url": "https://www.cyberciti.biz/tips/debugging-shell-script.html"
          },
          {
            "type": "article",
            "title": "How to Debug a Bash Shell Script in Linux",
            "url": "https://www.linuxtechi.com/debugging-shell-scripts-in-linux/"
          },
          {
            "type": "article",
            "title": "How to Debug Bash Scripts",
            "url": "https://thelinuxcode.com/debug-bash-script/"
          }
        ]
      }
    },
    {
      "id": "bdQNcr1sj94aX_gjwf2Fa",
      "name": "Troubleshooting",
      "resources": {
        "description": "# Troubleshooting\n\nLinux troubleshooting involves identifying and resolving system errors, hardware/software issues, network problems, and resource management challenges. Key skills include using command-line tools, inspecting log files, understanding processes, and interpreting error messages. Tools like `top` provide real-time process monitoring to identify resource-heavy processes causing performance issues efficiently.",
        "resources": [
          {
            "type": "article",
            "title": "Troubleshooting Linux Problems: A Beginner's Guide",
            "url": "https://learn.redhat.com/t5/Platform-Linux/Troubleshooting-Linux-Problems-A-Beginner-s-Guide/td-p/36236"
          },
          {
            "type": "article",
            "title": "Linux Top 20 Important Commands for Monitoring and Troubleshooting",
            "url": "https://medium.com/@stepstodevops/linux-top-20-important-commands-for-monitoring-and-troubleshooting-a-comprehensive-guide-for-cd5aaa37da17"
          },
          {
            "type": "article",
            "title": "10 Linux Troubleshooting Tips - dummies",
            "url": "https://www.dummies.com/article/technology/computers/operating-systems/linux/10-linux-troubleshooting-tips-274301/"
          }
        ]
      }
    },
    {
      "id": "Ymf3u_sG1dyt8ZR_LbwqJ",
      "name": "ICMP",
      "resources": {
        "description": "# ICMP\n\nInternet Control Message Protocol (ICMP) is a supportive protocol used by network devices to communicate error messages and operational information. Essential for Linux network troubleshooting, ICMP enables tools like `ping` and `traceroute` to diagnose network connectivity and routing issues. Use `ping www.google.com` to send ICMP echo requests and test network reachability effectively.",
        "resources": [
          {
            "type": "article",
            "title": "icmp(7) — Linux manual page",
            "url": "https://www.man7.org/linux/man-pages/man7/icmp.7.html"
          },
          {
            "type": "article",
            "title": "Understanding ICMP Packets with Examples",
            "url": "https://www.howtouselinux.com/post/icmp-packets"
          }
        ]
      }
    },
    {
      "id": "Uc36t92UAlILgM3_XxcMG",
      "name": "ping",
      "resources": {
        "description": "# Ping\n\nThe `ping` command is essential for Linux network troubleshooting, checking connectivity between your host and target machines. It sends ICMP ECHO_REQUEST packets and listens for ECHO_RESPONSE returns, providing insights into connection health and speed. Use `ping <target IP or hostname>` to diagnose network connectivity issues and identify reachability problems efficiently.",
        "resources": [
          {
            "type": "article",
            "title": "Ping Command in Linux",
            "url": "https://linuxize.com/post/linux-ping-command/"
          },
          {
            "type": "article",
            "title": "Ping Command Examples in Linux - It's FOSS",
            "url": "https://itsfoss.com/ping-command/"
          }
        ]
      }
    },
    {
      "id": "BnB3Rirh4R7a7LW7-k-95",
      "name": "traceroute",
      "resources": {
        "description": "# Traceroute\n\nTraceroute is a Linux network diagnostic tool that displays the path packets take from your system to a destination. It identifies routing problems, measures latency, and reveals network structure as packets traverse the internet. Each hop is tested multiple times with round-trip times displayed. Use `traceroute www.example.com` to discover packet routes and diagnose failures.",
        "resources": [
          {
            "type": "article",
            "title": "traceroute Command Examples in Linux",
            "url": "https://linuxhandbook.com/traceroute/"
          },
          {
            "type": "article",
            "title": "How to Use the traceroute Command on Linux",
            "url": "https://www.howtogeek.com/657780/how-to-use-the-traceroute-command-on-linux/"
          }
        ]
      }
    },
    {
      "id": "yrxNYMluJ9OAQCKuM5W1u",
      "name": "netstat",
      "resources": {
        "description": "# Netstat\n\nNetstat is a command-line tool for network troubleshooting and performance measurement in Linux. It provides network statistics, open ports, routing table information, and protocol details. Use options like `-n` for numerical addresses, `-c` for continuous monitoring, and `-t`/`-u` for specific protocols. Example: `netstat -n` lists all connections with numerical values.",
        "resources": [
          {
            "type": "article",
            "title": "Netstat Command in Linux",
            "url": "https://linuxhandbook.com/netstat-command/"
          },
          {
            "type": "article",
            "title": "How to Use netstat on Linux",
            "url": "https://www.howtogeek.com/513003/how-to-use-netstat-on-linux/"
          }
        ]
      }
    },
    {
      "id": "7seneb4TWts4v1_x8xlcZ",
      "name": "Packet Analysis",
      "resources": {
        "description": "# Packet Analysis\n\nPacket analysis is a key Linux network troubleshooting skill involving capturing and analyzing network traffic to identify performance issues, connectivity problems, and security vulnerabilities. Tools like tcpdump and Wireshark provide packet-level details for network diagnostics. Use `sudo tcpdump -i eth0` to capture packets on the eth0 interface for debugging network protocols.",
        "resources": [
          {
            "type": "article",
            "title": "How to Capture and Analyze Packets with tcpdump",
            "url": "https://www.debian.org/doc/manuals/apt-guide/index.en.html"
          },
          {
            "type": "article",
            "title": "Mastering Network Traffic Analysis in Linux",
            "url": "https://en.ittrip.xyz/linux/linux-network-analysis"
          },
          {
            "type": "article",
            "title": "16 Best Free and Open Source Network Analyzers",
            "url": "https://www.linuxlinks.com/best-free-open-source-network-analyzers/"
          }
        ]
      }
    },
    {
      "id": "3OpGaQhyNtk1n1MLp-tlb",
      "name": "Containerization",
      "resources": {
        "description": "# Containerization\n\nContainerization is a virtualization method that encapsulates applications in containers with isolated operating environments, enabling reliable deployment across computing environments. Unlike VMs requiring full operating systems, containers share the host system's user space, making them lightweight and faster. Docker is a popular Linux containerization tool for managing complex applications.",
        "resources": [
          {
            "type": "course",
            "title": "Docker",
            "url": "https://docker.com"
          },
          {
            "type": "course",
            "title": "Kubernetes",
            "url": "https://kubernetes.io"
          },
          {
            "type": "article",
            "title": "What is Containerization? - Containerization Explained - AWS",
            "url": "https://aws.amazon.com/what-is/containerization/"
          },
          {
            "type": "article",
            "title": "What is Containerization? - DigitalOcean",
            "url": "https://www.digitalocean.com/resources/articles/what-is-containerization"
          }
        ]
      }
    },
    {
      "id": "QgfenmhMc18cU_JngQ1n0",
      "name": "ulimits",
      "resources": {
        "description": "# Ulimits\n\nUlimits (user limits) are Linux kernel features that restrict resources like file handles and memory that processes can consume. In containerization, ulimits prevent rogue processes from exhausting server resources and creating denial-of-service situations. Use `ulimit -a` to view current limits and `ulimit -n 1024` to set specific limits for optimal container performance and security.",
        "resources": [
          {
            "type": "article",
            "title": "Check and set user limits with ulimit Linux command",
            "url": "https://linuxconfig.org/limit-user-environment-with-ulimit-linux-command"
          },
          {
            "type": "article",
            "title": "How to Use Ulimit Command in Linux",
            "url": "https://linuxhandbook.com/ulimit-command/"
          },
          {
            "type": "article",
            "title": "10 Linux Troubleshooting Tips",
            "url": "https://www.dummies.com/article/technology/computers/operating-systems/linux/10-linux-troubleshooting-tips-274301/"
          }
        ]
      }
    },
    {
      "id": "23lsrUw8ux6ZP9JlDNNu2",
      "name": "cgroups",
      "resources": {
        "description": "# Cgroups\n\nCgroups (control groups) are a Linux kernel feature that organizes processes into hierarchical groups and limits their resource usage (CPU, memory, disk I/O). Essential for containerization, cgroups prevent containers from monopolizing host resources, ensuring system stability and performance. Use `cgcreate` to create groups, assign processes, and set resource limits effectively.",
        "resources": [
          {
            "type": "course",
            "title": "Control Groups — The Linux Kernel",
            "url": "https://docs.kernel.org/admin-guide/cgroup-v1/"
          },
          {
            "type": "article",
            "title": "cgroups — Linux manual page",
            "url": "https://www.man7.org/linux/man-pages/man7/cgroups.7.html"
          },
          {
            "type": "article",
            "title": "Introduction to Control Groups (Cgroups)",
            "url": "https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/7/html/resource_management_guide/chap-introduction_to_control_groups"
          }
        ]
      }
    },
    {
      "id": "bVCwRoFsYb3HD8X4xuKOo",
      "name": "Container Runtime",
      "resources": {
        "description": "# Container Runtime\n\nContainer runtime is software responsible for running containers in Linux, providing image transport, storage, execution, and network interactions. Popular options include Docker (comprehensive ecosystem), Containerd (lightweight standalone), and CRI-O (Kubernetes-optimized). Each runtime offers specific features and benefits for different use cases in containerized application deployment and management.",
        "resources": [
          {
            "type": "article",
            "title": "Container Runtimes",
            "url": "https://kubernetes.io/docs/setup/production-environment/container-runtimes/"
          },
          {
            "type": "article",
            "title": "What are Container Runtimes? Types and Popular Runtime",
            "url": "https://www.wiz.io/academy/container-runtimes"
          },
          {
            "type": "article",
            "title": "What are container runtimes?",
            "url": "https://opensource.com/article/21/9/container-runtimes"
          }
        ]
      }
    },
    {
      "id": "MfengY3ouz6sSOx3PXYf8",
      "name": "Docker",
      "resources": {
        "description": "# Docker\n\nDocker is an open-source containerization platform that uses OS-level virtualization to package applications with dependencies into lightweight containers. In Linux, Docker containers share the kernel and use features like namespaces and cgroups for isolation. This provides less overhead than traditional VMs while enabling consistent deployment across environments.",
        "resources": [
          {
            "type": "article",
            "title": "Visit Dedicated Docker Roadmap",
            "url": "https://roadmap.sh/docker"
          },
          {
            "type": "course",
            "title": "Docker",
            "url": "https://docker.com"
          },
          {
            "type": "course",
            "title": "Docker Documentation",
            "url": "https://docs.docker.com/"
          },
          {
            "type": "article",
            "title": "How To Install and Use Docker on Ubuntu",
            "url": "https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-20-04"
          }
        ]
      }
    }
  ],
  "edges": [
    {
      "source": "HU7wZWiES3m3xl1-NYP6F",
      "target": "y7KjVfSI6CAduyHd4mBFT"
    },
    {
      "source": "y7KjVfSI6CAduyHd4mBFT",
      "target": "qLeEEwBvlGt1fP5Qcreah"
    },
    {
      "source": "y7KjVfSI6CAduyHd4mBFT",
      "target": "q-Ky0ietZGpyUcBQfh-BJ"
    },
    {
      "source": "y7KjVfSI6CAduyHd4mBFT",
      "target": "9oo2fxTM2_p0VYPBroqxa"
    },
    {
      "source": "y7KjVfSI6CAduyHd4mBFT",
      "target": "3fzuXKH7az_LVnmnoXB1p"
    },
    {
      "source": "HGmeYvRf7_XusZl_K4x9k",
      "target": "yqRwmcZThjQuqh2ao0dWK"
    },
    {
      "source": "HGmeYvRf7_XusZl_K4x9k",
      "target": "8QBMyL8D5jPovxN8jyZW9"
    },
    {
      "source": "8QBMyL8D5jPovxN8jyZW9",
      "target": "KaMSsQnJzNqGHg0Oia4uy"
    },
    {
      "source": "8QBMyL8D5jPovxN8jyZW9",
      "target": "moGMHNR58wFlzhS7je1wc"
    },
    {
      "source": "8QBMyL8D5jPovxN8jyZW9",
      "target": "zwXEmpPYjA7_msS43z7I0"
    },
    {
      "source": "8QBMyL8D5jPovxN8jyZW9",
      "target": "JgoZzx4BfK7tmosgpZOsf"
    },
    {
      "source": "8QBMyL8D5jPovxN8jyZW9",
      "target": "NIBSZGE9PskVrluJpdom0"
    },
    {
      "source": "8QBMyL8D5jPovxN8jyZW9",
      "target": "RsOTPZPZGTEIt1Lk41bQV"
    },
    {
      "source": "RsOTPZPZGTEIt1Lk41bQV",
      "target": "-B2Dvz7160Er0OBHzS6ro"
    },
    {
      "source": "RsOTPZPZGTEIt1Lk41bQV",
      "target": "TnrT-cqMA8urew9nLv0Ns"
    },
    {
      "source": "RsOTPZPZGTEIt1Lk41bQV",
      "target": "iD073xTmpzvQFfXwcwXcY"
    },
    {
      "source": "RsOTPZPZGTEIt1Lk41bQV",
      "target": "abKO6KuuIfl9ruVxBw6t_"
    },
    {
      "source": "RsOTPZPZGTEIt1Lk41bQV",
      "target": "KaXHG_EKxI5PUXmcvlJt6"
    },
    {
      "source": "-B2Dvz7160Er0OBHzS6ro",
      "target": "jSzfQf0MlnXtWHCc-HYvr"
    },
    {
      "source": "jSzfQf0MlnXtWHCc-HYvr",
      "target": "19lTWqAvZFT2CDlhLlPSq"
    },
    {
      "source": "jSzfQf0MlnXtWHCc-HYvr",
      "target": "h01Y6dW09ChidlM2HYoav"
    },
    {
      "source": "h01Y6dW09ChidlM2HYoav",
      "target": "mUKoiGUTpIaUgQNF3BND_"
    },
    {
      "source": "h01Y6dW09ChidlM2HYoav",
      "target": "g6n7f1Qi0BPr_BGvisWuz"
    },
    {
      "source": "u2K2QU5WxT9sSe9FCB-CA",
      "target": "F1sU3O1ouxTOvpidDfN3k"
    },
    {
      "source": "F1sU3O1ouxTOvpidDfN3k",
      "target": "34UUrc8Yjc_8lvTL8itc3"
    },
    {
      "source": "F1sU3O1ouxTOvpidDfN3k",
      "target": "FStz-bftQBK0M6zz2Bxl4"
    },
    {
      "source": "F1sU3O1ouxTOvpidDfN3k",
      "target": "DuEfJNrm4Jfmp8-8Pggrf"
    },
    {
      "source": "F1sU3O1ouxTOvpidDfN3k",
      "target": "xk5Xgi797HlVjdZJRfwX1"
    },
    {
      "source": "F1sU3O1ouxTOvpidDfN3k",
      "target": "4eINX8jYMJxfYh7ZV47YI"
    },
    {
      "source": "4eINX8jYMJxfYh7ZV47YI",
      "target": "Fn_uYKigJRgb7r_iYGVBr"
    },
    {
      "source": "DQEa8LrJ9TVW4ULBE4aHJ",
      "target": "o5lSQFW-V_PqndGqo1mp3"
    },
    {
      "source": "DQEa8LrJ9TVW4ULBE4aHJ",
      "target": "ru7mpLQZKE1QxAdiA1sS3"
    },
    {
      "source": "Fn_uYKigJRgb7r_iYGVBr",
      "target": "DQEa8LrJ9TVW4ULBE4aHJ"
    },
    {
      "source": "DQEa8LrJ9TVW4ULBE4aHJ",
      "target": "Mb42VFjCzMZn_PovKIfKx"
    },
    {
      "source": "Mb42VFjCzMZn_PovKIfKx",
      "target": "0pciSsiQqIGJh3x8465_s"
    },
    {
      "source": "Mb42VFjCzMZn_PovKIfKx",
      "target": "Xszo9vXuwwXZo26seHehD"
    },
    {
      "source": "Mb42VFjCzMZn_PovKIfKx",
      "target": "4ees23q281J1DPVAc7iXd"
    },
    {
      "source": "Mb42VFjCzMZn_PovKIfKx",
      "target": "D0yUzzaJsfhtdBWMtquAj"
    },
    {
      "source": "Mb42VFjCzMZn_PovKIfKx",
      "target": "f5oQYhmjNM2_FD7Qe1zGK"
    },
    {
      "source": "Mb42VFjCzMZn_PovKIfKx",
      "target": "uk6UMuI8Uhf02TBAGVeLS"
    },
    {
      "source": "Mb42VFjCzMZn_PovKIfKx",
      "target": "tVrbVcNEfc11FbEUoO2Dk"
    },
    {
      "source": "Mb42VFjCzMZn_PovKIfKx",
      "target": "4tFZ1PLpz50bddf7zSFrW"
    },
    {
      "source": "4tFZ1PLpz50bddf7zSFrW",
      "target": "rOGnHbGIr3xPCFdpkqoeK"
    },
    {
      "source": "4tFZ1PLpz50bddf7zSFrW",
      "target": "bdQNcr1sj94aX_gjwf2Fa"
    },
    {
      "source": "bdQNcr1sj94aX_gjwf2Fa",
      "target": "BnB3Rirh4R7a7LW7-k-95"
    },
    {
      "source": "bdQNcr1sj94aX_gjwf2Fa",
      "target": "yrxNYMluJ9OAQCKuM5W1u"
    },
    {
      "source": "bdQNcr1sj94aX_gjwf2Fa",
      "target": "Ymf3u_sG1dyt8ZR_LbwqJ"
    },
    {
      "source": "bdQNcr1sj94aX_gjwf2Fa",
      "target": "7seneb4TWts4v1_x8xlcZ"
    },
    {
      "source": "bdQNcr1sj94aX_gjwf2Fa",
      "target": "3OpGaQhyNtk1n1MLp-tlb"
    },
    {
      "source": "3OpGaQhyNtk1n1MLp-tlb",
      "target": "MfengY3ouz6sSOx3PXYf8"
    }
  ]
}