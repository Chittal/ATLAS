{
  "nodes": [
    {
      "id": "4U-HZQGH7kaWCB94Xy8Mh",
      "name": "Introduction",
      "resources": {
        "description": "# Introduction\n\nRust is a modern system programming language focused on performance, safety, and concurrency. It accomplishes these goals without having a garbage collector, making it a useful language for a number of use cases other languages arenâ€™t good at. Its syntax is similar to C++, but Rust offers better memory safety while maintaining high performance.",
        "resources": [
          {
            "type": "course",
            "title": "Rust Programming Language",
            "url": "https://www.rust-lang.org/"
          },
          {
            "type": "course",
            "title": "Rust by Example",
            "url": "https://doc.rust-lang.org/stable/rust-by-example/index.html"
          },
          {
            "type": "tutorial",
            "title": "Rust Book",
            "url": "https://edu.anarcho-copy.org/Programming%20Languages/Rust/rust-programming-language-steve-klabnik.pdf"
          },
          {
            "type": "tutorial",
            "title": "Rust Book Interactive",
            "url": "https://rust-book.cs.brown.edu/experiment-intro.html"
          }
        ]
      }
    },
    {
      "id": "cMfsRtvzvDZZJ0TqeUOxm",
      "name": "What is Rust?",
      "resources": {
        "description": "# What is Rust?\n\nRust is a modern system programming language focused on performance, safety, and concurrency. It accomplishes these goals without having a garbage collector, making it a useful language for a number of use cases other languages arenâ€™t good at. Its syntax is similar to C++, but Rust offers better memory safety while maintaining high performance.",
        "resources": [
          {
            "type": "course",
            "title": "Rust? What is it?",
            "url": "https://doc.rust-lang.org/stable/rust-by-example/index.html"
          },
          {
            "type": "course",
            "title": "Rust Programming Language",
            "url": "https://www.rust-lang.org/"
          },
          {
            "type": "article",
            "title": "What is Rust and why is it so popular?",
            "url": "https://stackoverflow.blog/2020/01/20/what-is-rust-and-why-is-it-so-popular/"
          },
          {
            "type": "video",
            "title": "What is Rust?",
            "url": "https://www.youtube.com/watch?v=R33h77nrMqc"
          },
          {
            "type": "article",
            "title": "Explore top posts about Rust",
            "url": "https://app.daily.dev/tags/rust?ref=roadmapsh"
          }
        ]
      }
    },
    {
      "id": "VhSEH_RoWFt1z2lial7xZ",
      "name": "Why use Rust?",
      "resources": {
        "description": "# Why use Rust?\n\nRust is a system programming language that aims to provide memory safety, concurrency, and performance with a focus on zero cost abstractions. It was originally created by Graydon Hoare at Mozilla Research, with contributions from Brendan Eich, the creator of JavaScript. Rust is appreciated for the solutions it provides to common programming language issues. Its emphasis on safety, speed, and support for concurrent programming, as well as its robust type system, are just a few reasons why developers choose Rust.",
        "resources": [
          {
            "type": "course",
            "title": "Rust? What is it?",
            "url": "https://doc.rust-lang.org/stable/rust-by-example/index.html"
          },
          {
            "type": "course",
            "title": "Rust Programming Language",
            "url": "https://www.rust-lang.org/"
          },
          {
            "type": "video",
            "title": "What is Rust?",
            "url": "https://www.youtube.com/watch?v=R33h77nrMqc"
          },
          {
            "type": "video",
            "title": "Convince your boss to use Rust",
            "url": "https://www.youtube.com/playlist?list=PLZaoyhMXgBzqkaLKR8HHWZaASMvW4gRtZ"
          },
          {
            "type": "video",
            "title": "Rust in 100 seconds",
            "url": "https://www.youtube.com/watch?v=5C_HPTJg5ek\\&pp=ygUNcnVzdCBmaXJlYmFzZQ%3D%3D"
          },
          {
            "type": "article",
            "title": "Explore top posts about Rust",
            "url": "https://app.daily.dev/tags/rust?ref=roadmapsh"
          }
        ]
      }
    },
    {
      "id": "-IqA02ObYvXPW1ot6t_b9",
      "name": "Installing Rust and Cargo",
      "resources": {
        "description": "# Installing Rust and Cargo\n\nTo install Rust, navigate to the rust official website and download the appropriate installation file (or run the appropriate terminal command) for your operating system. You'll be installing `rustup`, which is the preferred tool for installing, updating, and managing your core Rust tooling. For UNIX systems like Linux and MacOS, installation is as easy as running a single command in the terminal. For Windows, you'll be provided with an '.exe' installer which you need to execute. Further instructions can be found on the download page of the website.",
        "resources": [
          {
            "type": "course",
            "title": "Rust Programming Language",
            "url": "https://www.rust-lang.org"
          },
          {
            "type": "course",
            "title": "Install Rust",
            "url": "https://www.rust-lang.org/tools/install"
          },
          {
            "type": "course",
            "title": "Installation - The Rust Programming Language",
            "url": "https://doc.rust-lang.org/book/ch01-01-installation.html"
          }
        ]
      }
    },
    {
      "id": "oyP1ZyOgDC4nYEQXHwdVQ",
      "name": "IDEs and Rust Toolchains",
      "resources": {
        "description": "# IDEs and Rust Toolchains\n\nFor the Rust Programming Language, several Integrated Development Environments (IDEs) and editors provide great support. Visual Studio Code is highly preferred among Rust developers due to its support for Rust via the \"Rust Language Server\" or \"rust-analyzer\" plugins. Another popular choice is RustRover, a dedicated IDE for Rust development by JetBrains. Additionally, Sublime Text with respective Rust-enhancement plugins are also used. For a more terminal-centric approach, Vim and Emacs are equipped with Rust modes. These IDEs and editors offer various features like auto-completion, syntax highlighting, and debugging tools which prove useful for Rust programming.",
        "resources": [
          {
            "type": "course",
            "title": "Visual Studio Code",
            "url": "https://code.visualstudio.com"
          },
          {
            "type": "course",
            "title": "RustRover",
            "url": "https://www.jetbrains.com/rust/"
          },
          {
            "type": "course",
            "title": "Vim",
            "url": "https://www.vim.org"
          },
          {
            "type": "course",
            "title": "Emacs",
            "url": "https://www.gnu.org/software/emacs/"
          },
          {
            "type": "course",
            "title": "Sublime Text",
            "url": "https://www.sublimetext.com"
          }
        ]
      }
    },
    {
      "id": "eYCNYtwXBjZwcPUe7QYZ-",
      "name": "Rust REPL (Rust Playground)",
      "resources": {
        "description": "# Rust REPL (Rust Playground)\n\n`Rust REPL` (Read-Eval-Print-Loop) is an interactive shell in which you can write and test Rust snippets in real-time. Unlike running a program normally in Rust where you have to manually compile and then run the program, REPL automatically evaluates your inputs, and the result is returned immediately after execution. This is helpful when experimenting with Rust code, learning the language, and debugging. REPL isn't built into Rust directly, but is available via third-party tools such as `evcxr_repl`.",
        "resources": [
          {
            "type": "course",
            "title": "Rust Playground",
            "url": "https://play.rust-lang.org/"
          },
          {
            "type": "article",
            "title": "Debugging Rust apps with GDB",
            "url": "https://blog.logrocket.com/debugging-rust-apps-with-gdb/"
          },
          {
            "type": "article",
            "title": "Debugging Rust with rust-lldb",
            "url": "https://dev.to/bmatcuk/debugging-rust-with-rust-lldb-j1f"
          },
          {
            "type": "article",
            "title": "Interactive Rust in a REPL and Jupyter Notebook",
            "url": "https://depth-first.com/articles/2020/09/21/interactive-rust-in-a-repl-and-jupyter-notebook-with-evcxr/"
          }
        ]
      }
    },
    {
      "id": "6E4pGifNfSAq6SbzfzFNT",
      "name": "Language Basics",
      "resources": {
        "description": "# Language Basics\n\nRust language basics cover fundamental programming concepts including syntax and semantics, variables and data types, control flow (loops and conditionals), and functions. These elements form the foundation for writing effective Rust code and understanding how to structure and reuse code segments.",
        "resources": [
          {
            "type": "course",
            "title": "Introduction - Rust By Example",
            "url": "https://doc.rust-lang.org/stable/rust-by-example/"
          },
          {
            "type": "article",
            "title": "How to Learn Rust in 2025: A Complete Beginner's Guide",
            "url": "https://blog.jetbrains.com/rust/2024/09/20/how-to-learn-rust/"
          },
          {
            "type": "article",
            "title": "Explore top posts about Rust",
            "url": "https://app.daily.dev/tags/rust?ref=roadmapsh"
          }
        ]
      }
    },
    {
      "id": "Gw5E21W5zis-RUIgNSEV2",
      "name": "Variables, DataTypes and Constants",
      "resources": {
        "description": "# Variables, Constants, and Data Types\n\nIn Rust, variables are declared using the `let` keyword. All variables are immutable by default, which means once a value is bound to a variable, it cannot be changed. If you want to make a variable mutable, the `mut` keyword is used. So, if you wanted to declare a mutable variable `x` and assign it the value `5`, you would write `let mut x = 5;`. Variables can also be patterned. By default in Rust, variables are block-scoped. Rust also supports several types of variable attributes.",
        "resources": [
          {
            "type": "course",
            "title": "Variables and Mutability",
            "url": "https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html"
          },
          {
            "type": "course",
            "title": "Data Types",
            "url": "https://doc.rust-lang.org/book/ch03-02-data-types.html"
          },
          {
            "type": "course",
            "title": "Constants",
            "url": "https://doc.rust-lang.org/rust-by-example/custom_types/constants.html"
          }
        ]
      }
    },
    {
      "id": "u2wlnmE1uLaTqWw35UF0a",
      "name": "Control Flow and Constructs",
      "resources": {
        "description": "# Control Flow Constructs\n\nIn Rust, control flow is managed through various structures, like `if`, `else`, `while`, `for`, `loop`, `match` and `if let`. The `if` and `else` structures are used to execute different blocks of code based on certain conditions. Similar to other languages, `while` and `for` are used for looping over a block of code. The `while` loop repeats a block of code until the condition is false, and the `for` loop is used to iterate over a collection of values, such as an array or a range. The `loop` keyword tells Rust to execute a block of code over and over again forever or until you explicitly tell it to stop. Rust's `match` structure, which is similar to switch statements in other languages, is a powerful tool used for pattern matching: it checks through different cases defined by the programmer and executes the block where the match is found. The `if let` syntax lets you combine `if` and `let` into a less verbose way to handle values that match one pattern while ignoring the rest.\n\nLearn more from the following links:\n\n- [@official@Control Flow](https://doc.rust-lang.org/book/ch03-05-control-flow.html)\n- [@article@Concise Control Flow with `if let`](https://rust-book.cs.brown.edu/ch06-03-if-let.html)\n- [@article@Mastering Control Flow in Rust](https://dev.to/iamdipankarpaul/mastering-control-flow-in-rust-36fd)",
        "resources": [
          {
            "type": "course",
            "title": "Control Flow",
            "url": "https://doc.rust-lang.org/book/ch03-05-control-flow.html"
          },
          {
            "type": "article",
            "title": "Concise Control Flow with `if let`",
            "url": "https://rust-book.cs.brown.edu/ch06-03-if-let.html"
          },
          {
            "type": "article",
            "title": "Mastering Control Flow in Rust",
            "url": "https://dev.to/iamdipankarpaul/mastering-control-flow-in-rust-36fd"
          }
        ]
      }
    },
    {
      "id": "5hKJaMKpeFEUi3S1Hpiyk",
      "name": "Functions and Method Syntax",
      "resources": {
        "description": "# Functions and Method Syntax\n\nIn Rust, functions are declared using the `fn` keyword. Each function can take a set of input variables with their specified types, and may return data of a specified type. The body of a function is contained within curly braces `{}`. Unlike other languages, in Rust, you don't need to end the last statement in a block with a semicolon; omitting the last semicolon of a block in this way turns the last statement into an expression, and the result of this expression becomes the implicit return value of the block.",
        "resources": [
          {
            "type": "course",
            "title": "Functions",
            "url": "https://doc.rust-lang.org/book/ch03-03-how-functions-work.html"
          },
          {
            "type": "article",
            "title": "Rust Functions Explained with Examples",
            "url": "https://boxoflearn.com/rust-functions-complete-guide/"
          }
        ]
      }
    },
    {
      "id": "yqp3UePmSlGyOYpxITis4",
      "name": "Pattern Matching & Destructuring",
      "resources": {
        "description": "# Pattern Matching and Destructuring\n\nIn Rust, \"pattern matching\" is a robust tool that allows you to destructure data types and perform conditional checks in a succinct and clear way. The main structures used for pattern matching are `match` and `if let`. The `match` keyword can be used to compare a value against a series of patterns and then execute code based on which pattern matches. Patterns can be made up of literal values, variable names, wildcards, and many other things. The `if let` structure allows you to combine `if` and `let` into a less verbose way of handling values that match one specific pattern, rather than a series of patterns. It's basically a nice syntax sugar over a `match` statement.",
        "resources": [
          {
            "type": "course",
            "title": "Patterns and Matching",
            "url": "https://doc.rust-lang.org/book/ch19-00-patterns.html"
          },
          {
            "type": "course",
            "title": "Destructuring",
            "url": "https://doc.rust-lang.org/rust-by-example/flow_control/match/destructuring.html"
          },
          {
            "type": "course",
            "title": "Matching",
            "url": "https://doc.rust-lang.org/rust-by-example/flow_control/match.html"
          },
          {
            "type": "article",
            "title": "Control Flow with if let",
            "url": "https://rust-book.cs.brown.edu/ch06-03-if-let.html"
          }
        ]
      }
    },
    {
      "id": "FswpjWqqt8-BzUTsDDjel",
      "name": "Enums",
      "resources": {
        "description": "# Enums\n\nAn enum, short for enumeration, is a custom data type that allows you to define a type by enumerating (listing out one-by-one) all of its possible variants. In Rust, if something is one of a given set of possibilities (e.g., `Rock` or `Paper` or `Scissors`), it's probably appropriate to represent that data with an enum, like so: `enum RpsChoice { Rock, Paper, Scissors }`.\n\nAn instance of an `enum` can be one and only one of the enum's declared variants at any given time. Unlike enumerations in some other languages, variants in Rust are not restricted to a singular data type. When you define an `enum`, you can decide for each of its possible variants whether or not that variant will hold additional embedded data; each variant of the enum is also allowed to hold data of completely different types and amounts.",
        "resources": [
          {
            "type": "course",
            "title": "Defining an Enum",
            "url": "https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html"
          },
          {
            "type": "article",
            "title": "Understanding and Implementing Enums in Rust",
            "url": "https://towardsdev.com/understanding-and-implementing-enums-in-rust-6eae37b6b5e3"
          }
        ]
      }
    },
    {
      "id": "Mi9mQ-8gyDPd8Mbu1zuHt",
      "name": "Structs",
      "resources": {
        "description": "# Structs\n\nIn Rust, a struct is a custom data type used for grouping related values together into one entity. Structs are similar to classes in other programming languages. Essentially, each `struct` creates a new type that we can use to streamline complex data handling.",
        "resources": [
          {
            "type": "course",
            "title": "Defining and Instantiating Structs",
            "url": "https://doc.rust-lang.org/book/ch05-01-defining-structs.html"
          },
          {
            "type": "article",
            "title": "Understanding Structs in Rust: A Complete Guide with Examples",
            "url": "https://medium.com/@er.pwndhull07/understanding-structs-in-rust-a-complete-guide-with-examples-621bf9753b88"
          }
        ]
      }
    },
    {
      "id": "SJMuIEuHp8X6nfLb0k0TU",
      "name": "Traits",
      "resources": {
        "description": "# Traits\n\nTraits in Rust define behaviors that are shared among different data types. Implementing traits for data types is a great way to group method signatures together and define a set of behaviors your types require. Essentially, anything with a certain `trait` applied to it will \"inherit\" the behavior of that trait's methods, but this is not the same thing as inheritance found in object-oriented programming languages.\n\nTraits are abstract; it's not possible to create instances of traits. However, we can define pointers of trait types, and these can hold any data type that implements the `trait`. A `trait` is **implemented** for something else with the syntax `impl TraitAbc for Xyz {...}`, which can be a concrete type or another trait.",
        "resources": [
          {
            "type": "article",
            "title": "Traits: Defining Shared Behaviour",
            "url": "https://doc.rust-lang.org/book/ch10-02-traits.html"
          },
          {
            "type": "article",
            "title": "Understanding Traits and Trait Bounds in Rust",
            "url": "https://leapcell.medium.com/understanding-traits-and-trait-bounds-in-rust-d575f19dd649"
          }
        ]
      }
    },
    {
      "id": "HzWHDQZjA9OgVZEWrmhKf",
      "name": "Impl Blocks",
      "resources": {
        "description": "# Impl Blocks\n\nImpl blocks use the `impl` keyword, and are used to **implement** behavior in the form of **methods** for a `struct`, `enum`, or `trait`. If you want your data type or trait to have methods, you need a corresponding `impl` block containing functions for the type or trait.\n\nNote that `self` and `Self` have different meanings in the context of an `impl` block's functions. `self` represents the specific value in your program that's calling the method and passing itself as an argument, while `Self` is syntax sugar for the `impl` block's data type, which is commonly used in constructor methods that return a new instance of the type.",
        "resources": [
          {
            "type": "course",
            "title": "Keyword impl",
            "url": "https://doc.rust-lang.org/std/keyword.impl.html"
          },
          {
            "type": "article",
            "title": "Method Syntax",
            "url": "https://rust-book.cs.brown.edu/ch05-03-method-syntax.html"
          },
          {
            "type": "article",
            "title": "Rust: Understanding Structs and impl Blocks with 10 Examples",
            "url": "https://medium.com/@TechSavvyScribe/rust-understanding-structs-and-impl-blocks-with-10-examples-20371f90b1ed"
          }
        ]
      }
    },
    {
      "id": "FHZSxSiOZYNBEz6tu8wuF",
      "name": "Integers",
      "resources": {
        "description": "# Integers\n\nIn Rust, integers are a primitive data type that hold whole number values, both positive and negative. Integer types in Rust can be divided into signed and unsigned ones:\n\n- Signed integers, denoted by \"i\", are those that can hold negative, zero, and positive values.\n- Unsigned integers, denoted by \"u\", only hold zero and positive values.",
        "resources": [
          {
            "type": "course",
            "title": "Integer Data Type in Rust",
            "url": "https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-types"
          },
          {
            "type": "course",
            "title": "Machine-dependent Integer Types",
            "url": "https://doc.rust-lang.org/reference/types/numeric.html#machine-dependent-integer-types"
          },
          {
            "type": "article",
            "title": "Rust Data Types (With Examples)",
            "url": "https://www.programiz.com/rust/data-types#integer-type"
          },
          {
            "type": "article",
            "title": "Integer Types",
            "url": "https://rust-book.cs.brown.edu/ch03-02-data-types.html#integer-types"
          }
        ]
      }
    },
    {
      "id": "bjwJCGMx5ZfrH7vz3eLS7",
      "name": "Boolean",
      "resources": {
        "description": "# Boolean\n\nRust's `bool` primitive type represents truth values with two possible states: `true` or `false`. Booleans are used in conditional statements and logical operations like `&&` (AND), `||` (OR), and `!` (NOT). When cast to integers, `true` becomes `1` and `false` becomes `0`. Example: `let is_active: bool = true;`\n\nLearn more from the following links:\n\n- [@official@bool](https://doc.rust-lang.org/std/primitive.bool.html)\n- [@article@The Boolean Type](https://rust-book.cs.brown.edu/ch03-02-data-types.html#the-boolean-type)\n- [@video@Rust Tutorial - Booleans](https://www.youtube.com/watch?v=t047Hseyj_k&t=388s)",
        "resources": [
          {
            "type": "course",
            "title": "bool",
            "url": "https://doc.rust-lang.org/std/primitive.bool.html"
          },
          {
            "type": "article",
            "title": "The Boolean Type",
            "url": "https://rust-book.cs.brown.edu/ch03-02-data-types.html#the-boolean-type"
          },
          {
            "type": "video",
            "title": "Rust Tutorial - Booleans",
            "url": "https://www.youtube.com/watch?v=t047Hseyj_k&t=388s"
          }
        ]
      }
    },
    {
      "id": "rNHHp1GgmRnKIYlZayi59",
      "name": "Floats",
      "resources": {
        "description": "# Floats\n\nIn Rust, `floats` are a primitive data types used to represent floating-point numbers. They are defined as numerical values with fractional components. Floating-point numbers are represented according to the IEEE-754 standard.\n\nRust supports two types of floating-point numbers: `f32` and `f64`. These are 32-bit and 64-bit in size, respectively.\n\n- `f32` (_binary32_ type defined in IEEE-754-2008) is a single-precision float, which means is less precise than `f64` type.\n- `f64` (_binary64_ type defined in IEEE-754-2008) has double precision. The default type is `f64` because on modern CPUs itâ€™s roughly the same speed as `f32` but allows more precision.\n\nBoth `f32` and `f64` represent negative, zero and positive floating-point values.",
        "resources": [
          {
            "type": "course",
            "title": "f32",
            "url": "https://doc.rust-lang.org/std/primitive.f32.html"
          },
          {
            "type": "article",
            "title": "IEEE-754 Standard",
            "url": "https://en.wikipedia.org/wiki/IEEE_754"
          },
          {
            "type": "article",
            "title": "Floating-Point Types",
            "url": "https://rust-book.cs.brown.edu/ch03-02-data-types.html#floating-point-types"
          },
          {
            "type": "video",
            "title": "Rust Tutorial - Floating-Points",
            "url": "https://www.youtube.com/watch?v=t047Hseyj_k&t=335s"
          }
        ]
      }
    },
    {
      "id": "dXMJb2wDmmh2jie1AnPoK",
      "name": "Character",
      "resources": {
        "description": "# Character\n\nRust's `char` type represents a Unicode Scalar Value, supporting far more than ASCII including emojis, accented letters, and various scripts. Each `char` occupies 4 bytes (32 bits) in memory and is defined using single quotes. Example: `let letter: char = 'z';` or `let emoji: char = 'ðŸ¦€';`\n\nLearn more from the following links:\n\n- [@official@The char Primitive Type](https://doc.rust-lang.org/std/primitive.char.html)\n- [@article@The Character Type](https://rust-book.cs.brown.edu/ch03-02-data-types.html#the-character-type)\n- [@article@Unicode Glossary - Unicode Scalar Value](https://www.unicode.org/glossary/#unicode_scalar_value)\n- [@video@Char Type in Rust](https://www.youtube.com/watch?v=NZaEinuVPVg&pp=ygURY2hhciB0eXBlIGluIHJ1c3Q%3D)",
        "resources": [
          {
            "type": "course",
            "title": "The char Primitive Type",
            "url": "https://doc.rust-lang.org/std/primitive.char.html"
          },
          {
            "type": "article",
            "title": "The Character Type",
            "url": "https://rust-book.cs.brown.edu/ch03-02-data-types.html#the-character-type"
          },
          {
            "type": "article",
            "title": "Unicode Glossary - Unicode Scalar Value",
            "url": "https://www.unicode.org/glossary/#unicode_scalar_value"
          },
          {
            "type": "video",
            "title": "Char Type in Rust",
            "url": "https://www.youtube.com/watch?v=NZaEinuVPVg&pp=ygURY2hhciB0eXBlIGluIHJ1c3Q%3D"
          }
        ]
      }
    },
    {
      "id": "81_J7CwtUUjYPvKV_prg3",
      "name": "Tuple",
      "resources": {
        "description": "# Tuple\n\nTuples are fixed-size collections that can hold elements of different types. Access elements using dot notation with zero-based indexing: `tuple.0`, `tuple.1`, etc. Example: `let data: (i32, f64, char) = (42, 3.14, 'x');`. Useful for grouping related values of different types and multiple variable assignments.\n\nLearn more from the following links:\n\n- [@official@Tuple](https://doc.rust-lang.org/std/primitive.tuple.html)\n- [@article@The Tuple Type](https://rust-book.cs.brown.edu/ch03-02-data-types.html#the-tuple-type)\n- [@video@Rust Tutorial - Tuples](https://www.youtube.com/watch?v=t047Hseyj_k&t=506s)",
        "resources": [
          {
            "type": "course",
            "title": "Tuple",
            "url": "https://doc.rust-lang.org/std/primitive.tuple.html"
          },
          {
            "type": "article",
            "title": "The Tuple Type",
            "url": "https://rust-book.cs.brown.edu/ch03-02-data-types.html#the-tuple-type"
          },
          {
            "type": "video",
            "title": "Rust Tutorial - Tuples",
            "url": "https://www.youtube.com/watch?v=t047Hseyj_k&t=506s"
          }
        ]
      }
    },
    {
      "id": "Hu1jf46OpX44nam_UvYqc",
      "name": "String",
      "resources": {
        "description": "# String\n\nRust's `String` is a growable, mutable, UTF-8 encoded string type stored on the heap. Unlike string slices (`&str`), `String` owns its data and can be modified. Create with `String::from(\"text\")` or `\"text\".to_string()`. Common operations include `push_str()`, `push()`, and concatenation with `+` or `format!()` macro.",
        "resources": [
          {
            "type": "course",
            "title": "String",
            "url": "https://doc.rust-lang.org/std/string/struct.String.html"
          },
          {
            "type": "course",
            "title": "str",
            "url": "https://doc.rust-lang.org/std/primitive.str.html"
          },
          {
            "type": "course",
            "title": "What as a String?",
            "url": "https://doc.rust-lang.org/book/ch08-02-strings.html?highlight=String#what-is-a-string"
          },
          {
            "type": "article",
            "title": "Rust String (With Examples)",
            "url": "https://www.programiz.com/rust/string"
          },
          {
            "type": "video",
            "title": "All Rust string types explained",
            "url": "https://www.youtube.com/watch?v=CpvzeyzgQdw&pp=ygUOc3RyaW5nIGluIHJ1c3Q%3D"
          }
        ]
      }
    },
    {
      "id": "2DbdHCjFzGHwCUETakaGh",
      "name": "Array",
      "resources": {
        "description": "# Array\n\nArrays are fixed-size collections of elements of the same type stored consecutively in memory. Size must be known at compile time and cannot change. Syntax: `let arr: [type; size] = [elements];`. Example: `let nums: [i32; 3] = [1, 2, 3];`. Access elements with zero-based indexing: `arr[0]`.\n\nLearn more from the following links:\n\n- [@official@Array](https://doc.rust-lang.org/std/primitive.array.html)\n- [@article@The Array Type](https://rust-book.cs.brown.edu/ch03-02-data-types.html#the-array-type)\n- [@article@Rust Array (With Examples)](https://www.programiz.com/rust/array)\n- [@video@Rust Tutorial - Arrays](https://www.youtube.com/watch?v=t047Hseyj_k&t=767s)",
        "resources": [
          {
            "type": "course",
            "title": "Array",
            "url": "https://doc.rust-lang.org/std/primitive.array.html"
          },
          {
            "type": "article",
            "title": "The Array Type",
            "url": "https://rust-book.cs.brown.edu/ch03-02-data-types.html#the-array-type"
          },
          {
            "type": "article",
            "title": "Rust Array (With Examples)",
            "url": "https://www.programiz.com/rust/array"
          },
          {
            "type": "video",
            "title": "Rust Tutorial - Arrays",
            "url": "https://www.youtube.com/watch?v=t047Hseyj_k&t=767s"
          }
        ]
      }
    },
    {
      "id": "JAgjrf5WDXiorZ6gFRzTc",
      "name": "Hashmap",
      "resources": {
        "description": "# Hashmap\n\n`HashMap<K, V>` stores key-value pairs using hashing for fast lookups, insertions, and removals. Keys must be unique; duplicate keys replace old values. Rust uses cryptographically strong hashing for security. Items are unordered. Example: `HashMap::new()` or `HashMap::from([(\"key\", \"value\")])`.\n\nLearn more from the following links:\n\n- [@official@HashMap in std::collections](https://doc.rust-lang.org/std/collections/struct.HashMap.html)\n- [@official@Storing Keys With Associated Values In Hash Maps](https://doc.rust-lang.org/book/ch08-03-hash-maps.html?highlight=hashmap#storing-keys-with-associated-values-in-hash-maps)\n- [@article@Hash Table](https://en.wikipedia.org/wiki/Hash_table)\n- [@video@HashMaps: key-value stores in Rust](https://www.youtube.com/watch?v=BfmSYuDdg8Q)",
        "resources": [
          {
            "type": "course",
            "title": "HashMap in std::collections",
            "url": "https://doc.rust-lang.org/std/collections/struct.HashMap.html"
          },
          {
            "type": "course",
            "title": "Storing Keys With Associated Values In Hash Maps",
            "url": "https://doc.rust-lang.org/book/ch08-03-hash-maps.html?highlight=hashmap#storing-keys-with-associated-values-in-hash-maps"
          },
          {
            "type": "article",
            "title": "Hash Table",
            "url": "https://en.wikipedia.org/wiki/Hash_table"
          },
          {
            "type": "video",
            "title": "HashMaps: key-value stores in Rust",
            "url": "https://www.youtube.com/watch?v=BfmSYuDdg8Q"
          }
        ]
      }
    },
    {
      "id": "PskCueCc9pSxfnSzfdX-u",
      "name": "Vector",
      "resources": {
        "description": "# Vector\n\n`Vec<T>` is Rust's growable, heap-allocated array that stores elements of the same type contiguously. Unlike arrays, vectors can resize at runtime. Key methods include `push()` to add elements, `pop()` to remove the last element, and `len()` for size. Example: `let mut v = vec![1, 2, 3];`",
        "resources": [
          {
            "type": "course",
            "title": "Vector",
            "url": "https://doc.rust-lang.org/std/vec/struct.Vec.html"
          },
          {
            "type": "course",
            "title": "Storing Lists of Values with Vectors",
            "url": "https://doc.rust-lang.org/book/ch08-01-vectors.html?highlight=vector#storing-lists-of-values-with-vectors"
          },
          {
            "type": "article",
            "title": "Rust Vector (With Examples)",
            "url": "https://www.programiz.com/rust/vector"
          },
          {
            "type": "video",
            "title": "Rust Vectors",
            "url": "https://www.youtube.com/watch?v=nOKOFYzvvHo&t=97s&pp=ygUMcnVzdCB2ZWN0b3Jz"
          },
          {
            "type": "video",
            "title": "Common Collections in Rust",
            "url": "https://www.youtube.com/watch?v=Zs-pS-egQSs&t=39s&pp=ygUMcnVzdCB2ZWN0b3Jz"
          }
        ]
      }
    },
    {
      "id": "b1iYy4Hvkj47Q13V2HE4i",
      "name": "Hashset",
      "resources": {
        "description": "# Hashset\n\n`HashSet<T>` is a collection of unique elements using hash-based storage for fast lookups, insertions, and deletions. No duplicates are allowed and elements are unordered. Provides methods like `insert()`, `contains()`, and `remove()`. Example: `let mut set = HashSet::new(); set.insert(\"value\");`\n\nLearn more from the following links:\n\n- [@official@HashSet in std::collections](https://doc.rust-lang.org/std/collections/struct.HashSet.html)\n- [@official@Hashset](https://doc.rust-lang.org/rust-by-example/std/hash/hashset.html)\n- [@video@Rust HashSet Collection Type](https://www.youtube.com/watch?v=KYw3Lnf0nSY&t=1440s)",
        "resources": [
          {
            "type": "course",
            "title": "HashSet in std::collections",
            "url": "https://doc.rust-lang.org/std/collections/struct.HashSet.html"
          },
          {
            "type": "course",
            "title": "Hashset",
            "url": "https://doc.rust-lang.org/rust-by-example/std/hash/hashset.html"
          },
          {
            "type": "video",
            "title": "Rust HashSet Collection Type",
            "url": "https://www.youtube.com/watch?v=KYw3Lnf0nSY&t=1440s"
          }
        ]
      }
    },
    {
      "id": "iR0ewc2yURqS7bfMWfoBi",
      "name": "LinkedList",
      "resources": {
        "description": "# LinkedList\n\n`LinkedList<T>` is a doubly-linked list where each node contains a value and pointers to both next and previous nodes. Provides O(1) insertion/removal at both ends but O(n) indexing. Generally slower than `Vec` and rarely needed; `VecDeque` is usually preferred for queue operations.",
        "resources": [
          {
            "type": "course",
            "title": "LinkedList in std::collections",
            "url": "https://doc.rust-lang.org/std/collections/struct.LinkedList.html"
          },
          {
            "type": "article",
            "title": "Too Many Linked Lists",
            "url": "https://rust-unofficial.github.io/too-many-lists/"
          }
        ]
      }
    },
    {
      "id": "B-S1hE-ofNTutnkc2hJBf",
      "name": "Stack",
      "resources": {
        "description": "# Stack\n\nStack is a LIFO (Last-In-First-Out) data structure where elements are added and removed from the same end. In Rust, the call stack manages function calls, with each call pushing a frame and returns popping it. Stack memory is fast but limited in size, with stack overflow occurring when exceeded.",
        "resources": [
          {
            "type": "course",
            "title": "Box, Stack and Heap",
            "url": "https://doc.rust-lang.org/rust-by-example/std/box.html"
          },
          {
            "type": "course",
            "title": "std::collections",
            "url": "https://doc.rust-lang.org/std/collections/index.html"
          },
          {
            "type": "article",
            "title": "Getting Started with SQLx and SQLite in Rust",
            "url": "https://medium.com/rustaceans/getting-started-with-sqlx-and-sqlite-in-rust-895ae7fc01ae"
          }
        ]
      }
    },
    {
      "id": "fq2NMV-QV9ayJl82ZWzov",
      "name": "Queue",
      "resources": {
        "description": "# Queue\n\nQueue follows FIFO (First-In-First-Out) ordering where elements are added at one end and removed from the other. Rust doesn't have a built-in queue, but `VecDeque` provides queue functionality with `push_back()` for adding and `pop_front()` for removing elements efficiently.",
        "resources": [
          {
            "type": "course",
            "title": "VecDeque in std::collections",
            "url": "https://doc.rust-lang.org/std/collections/struct.VecDeque.html"
          },
          {
            "type": "article",
            "title": "Working with Queues in Rust",
            "url": "https://basillica.medium.com/working-with-queues-in-rust-5a5afe82da46"
          },
          {
            "type": "course",
            "title": "Queues",
            "url": "https://docs.rs/queues/latest/queues/"
          }
        ]
      }
    },
    {
      "id": "jdndHBzmdgI6uYql6bO4W",
      "name": "Binary Heap",
      "resources": {
        "description": "# BinaryHeap\n\n`BinaryHeap<T>` is a priority queue implemented as a max-heap using a binary tree structure stored in an array. The largest element is always at the root, accessible via `peek()`. Supports O(log n) insertion with `push()` and removal with `pop()`. Useful for priority-based algorithms.\n\nLearn more from the following links:\n\n- [@official@BinaryHeap](https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html)\n- [@article@The Rust Guide - BinaryHeap](https://rust-guide.com/en/documentation/collections/BinaryHeap)\n- [@article@Comprehensive Guide to BinaryHeap in Rust](https://www.gyata.ai/rust/binaryheap)",
        "resources": [
          {
            "type": "course",
            "title": "BinaryHeap",
            "url": "https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html"
          },
          {
            "type": "article",
            "title": "The Rust Guide - BinaryHeap",
            "url": "https://rust-guide.com/en/documentation/collections/BinaryHeap"
          },
          {
            "type": "article",
            "title": "Comprehensive Guide to BinaryHeap in Rust",
            "url": "https://www.gyata.ai/rust/binaryheap"
          }
        ]
      }
    },
    {
      "id": "2UQ3AuGkDbT0-54l0rOGM",
      "name": "Ownsership Rules & Memory Safety",
      "resources": {
        "description": "# Ownership Rules and Memory Safety\n\nRust's ownership has three key rules: each value has exactly one owner, only one owner exists at a time, and values are dropped when owners go out of scope. This prevents data races, ensures memory safety without garbage collection, and eliminates common bugs like use-after-free and memory leaks.",
        "resources": [
          {
            "type": "course",
            "title": "What is Ownership?",
            "url": "https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html"
          },
          {
            "type": "article",
            "title": "Rust Ownership & Borrowing - Memory Safety Without Garbage",
            "url": "https://webreference.com/rust/ownership/"
          },
          {
            "type": "article",
            "title": "What Is Ownership?",
            "url": "https://rust-book.cs.brown.edu/ch04-01-what-is-ownership.html"
          }
        ]
      }
    },
    {
      "id": "-onH5vPffdcZFjjVcnEpk",
      "name": "Borrowing, References and Slices",
      "resources": {
        "description": "# Borrowing, References, and Slices\n\nBorrowing allows accessing data without taking ownership. Immutable borrows (`&T`) permit multiple read-only references, while mutable borrows (`&mut T`) allow one exclusive reference that can modify data. Slices (`&[T]`, `&str`) are references to contiguous sequences, enabling safe access to portions of data.\n\nLearn more from the following links:\n\n- [@official@References and Borrowing](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html)\n- [@article@The Slice Type](https://rust-book.cs.brown.edu/ch04-04-slices.html)\n- [@article@Borrowing and References in Rust](https://codeforgeek.com/borrowing-and-references-in-rust/)",
        "resources": [
          {
            "type": "course",
            "title": "References and Borrowing",
            "url": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html"
          },
          {
            "type": "article",
            "title": "The Slice Type",
            "url": "https://rust-book.cs.brown.edu/ch04-04-slices.html"
          },
          {
            "type": "article",
            "title": "Borrowing and References in Rust",
            "url": "https://codeforgeek.com/borrowing-and-references-in-rust/"
          }
        ]
      }
    },
    {
      "id": "UdXq0H8599cDTKXaIlPqt",
      "name": "Deep Dive: Stack vs Heap",
      "resources": {
        "description": "# Deep Dive: Stack vs Heap\n\nStack memory stores fixed-size data with automatic allocation/deallocation following LIFO order - fast but limited. Heap memory stores dynamic-size data with manual management - slower but flexible. Rust's ownership system ensures memory safety across both, with stack being default and heap accessed via smart pointers.",
        "resources": [
          {
            "type": "course",
            "title": "Box, Stack and Heap",
            "url": "https://doc.rust-lang.org/rust-by-example/std/box.html"
          },
          {
            "type": "article",
            "title": "Memory Management in Rust: Stack vs. Heap",
            "url": "https://dev.to/iamdipankarpaul/memory-management-in-rust-stack-vs-heap-3m45"
          },
          {
            "type": "article",
            "title": "The Stack and the Heap",
            "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/the-stack-and-the-heap.html"
          }
        ]
      }
    },
    {
      "id": "LWgaZWTJVWLDes3HzflRh",
      "name": "BTreeMap",
      "resources": {
        "description": "# BTreeMap\n\n`BTreeMap<K, V>` stores key-value pairs in a sorted binary tree structure. Keys must implement `Ord` trait and are automatically kept in sorted order. Provides O(log n) operations for insertion, removal, and lookup. Ideal when you need ordered iteration and range queries.\n\nLearn more from the following links:\n\n- [@official@BTreeMap](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html)\n- [@article@BTreeMap](https://cglab.ca/~abeinges/blah/rust-btree-case/)",
        "resources": [
          {
            "type": "course",
            "title": "BTreeMap",
            "url": "https://doc.rust-lang.org/std/collections/struct.BTreeMap.html"
          },
          {
            "type": "article",
            "title": "BTreeMap",
            "url": "https://cglab.ca/~abeinges/blah/rust-btree-case/"
          }
        ]
      }
    },
    {
      "id": "FsyLYRQP_rs4qL7IAj9Mo",
      "name": "BTreeSet",
      "resources": {
        "description": "# BTreeSet\n\n`BTreeSet<T>` is a sorted set of unique elements implemented using a B-tree. Elements must implement `Ord` trait and are kept in sorted order. Provides O(log n) insertion, removal, and lookup operations. Supports efficient range queries and set operations like union and intersection.\n\nLearn more from the following links:\n\n- [@official@Btree Set](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html)",
        "resources": [
          {
            "type": "course",
            "title": "Btree Set",
            "url": "https://doc.rust-lang.org/std/collections/struct.BTreeSet.html"
          }
        ]
      }
    },
    {
      "id": "U9Bd-GO0QwYVLvESR4PTb",
      "name": "RC",
      "resources": {
        "description": "# Rc\n\n`Rc<T>` (Reference Counting) enables multiple owners of the same heap-allocated data in single-threaded contexts. It tracks the number of references and automatically deallocates data when the count reaches zero. Use `Rc::clone()` to create additional references without deep copying data.",
        "resources": [
          {
            "type": "course",
            "title": "Rc\\<T\\> in std::rc",
            "url": "https://doc.rust-lang.org/std/rc/struct.Rc.html"
          },
          {
            "type": "course",
            "title": "rct - The Reference Counted Smart Pointer",
            "url": "https://doc.rust-lang.org/book/ch15-04-rc.html#rct-the-reference-counted-smart-pointer"
          }
        ]
      }
    },
    {
      "id": "yYmV5qkldu0FkDhOhWOXs",
      "name": "Arc",
      "resources": {
        "description": "# Arc\n\n`Arc<T>` (Atomic Reference Counting) is a thread-safe smart pointer for sharing immutable data across multiple threads. It uses atomic operations to track reference counts, allowing multiple ownership of heap-allocated data. When the reference count reaches zero, the data is automatically cleaned up.\n\nLearn more from the following links:\n\n- [@official@Arc in std::sync](https://doc.rust-lang.org/std/sync/struct.Arc.html)\n- [@official@Arc in Rust Lang](https://doc.rust-lang.org/rust-by-example/std/arc.html)",
        "resources": [
          {
            "type": "course",
            "title": "Arc in std::sync",
            "url": "https://doc.rust-lang.org/std/sync/struct.Arc.html"
          },
          {
            "type": "course",
            "title": "Arc in Rust Lang",
            "url": "https://doc.rust-lang.org/rust-by-example/std/arc.html"
          }
        ]
      }
    },
    {
      "id": "GbbeV3r27IBEKHyiyLqs6",
      "name": "Mutex",
      "resources": {
        "description": "# Mutex\n\n`Mutex<T>` (Mutual Exclusion) protects shared data from concurrent access by multiple threads. Only one thread can access the protected data at a time through `lock()`. Rust automatically unlocks mutexes when they go out of scope and handles panics to prevent deadlocks.",
        "resources": [
          {
            "type": "course",
            "title": "Mutex",
            "url": "https://doc.rust-lang.org/std/sync/struct.Mutex.html"
          },
          {
            "type": "article",
            "title": "Rust Mutex: From Basics to Advanced Techniques",
            "url": "https://medium.com/@TechSavvyScribe/rust-mutex-from-basics-to-advanced-techniques-56e1f1389d9b"
          },
          {
            "type": "article",
            "title": "Rust Concurrency Made Easy: A Guide to Arc and Mutex",
            "url": "https://www.ruststepbystep.com/rust-concurrency-made-easy-a-guide-to-arc-and-mutex/"
          }
        ]
      }
    },
    {
      "id": "WzGl4DkANjUu7VC1AIWI-",
      "name": "RwLock",
      "resources": {
        "description": "# RwLock\n\n`RwLock<T>` (Read-Write Lock) allows multiple concurrent readers OR one exclusive writer, unlike Mutex which allows only one accessor. Use `read()` for shared access and `write()` for exclusive access. Ideal for read-heavy workloads where data is frequently read but rarely modified.",
        "resources": [
          {
            "type": "course",
            "title": "RwLock",
            "url": "https://doc.rust-lang.org/std/sync/struct.RwLock.html"
          },
          {
            "type": "article",
            "title": "Rust Read-Write Locks: Managing Concurrent Read and Write Access",
            "url": "https://medium.com/@TechSavvyScribe/rust-read-write-locks-managing-concurrent-read-and-write-access-a6ab689bbed3"
          }
        ]
      }
    },
    {
      "id": "3nXJg5Y4SUug_dEAj0eQm",
      "name": "Channels",
      "resources": {
        "description": "# Channels\n\nChannels enable thread communication via message passing from `std::sync::mpsc` (Multiple Producer, Single Consumer). They have `Sender` for sending data and `Receiver` for receiving. This avoids shared state concurrency issues and enables safe communication between threads without data races.\n\nLearn more from the following links:\n\n- [@official@Channels](https://doc.rust-lang.org/rust-by-example/std_misc/channels.html)\n- [@article@Using Channels in Rust: Why and When?](https://howtorust.com/using-channels-in-rust-why-and-when/)",
        "resources": [
          {
            "type": "course",
            "title": "Channels",
            "url": "https://doc.rust-lang.org/rust-by-example/std_misc/channels.html"
          },
          {
            "type": "article",
            "title": "Using Channels in Rust: Why and When?",
            "url": "https://howtorust.com/using-channels-in-rust-why-and-when/"
          }
        ]
      }
    },
    {
      "id": "X2gB0m-ZKSC4TJyIcwsMx",
      "name": "Error Handling",
      "resources": {
        "description": "# Error Handling\n\nRust handles errors through `Result<T, E>` for operations that may fail and `Option<T>` for values that may be absent. `Result` has `Ok(T)` for success and `Err(E)` for errors, while `Option` has `Some(T)` and `None`. Pattern matching and the `?` operator enable elegant error handling and propagation. Rust doesn't use exceptions, eliminating many common error-handling problems.",
        "resources": [
          {
            "type": "course",
            "title": "Error Handling",
            "url": "https://doc.rust-lang.org/book/ch09-00-error-handling.html"
          },
          {
            "type": "article",
            "title": "How to Handle Errors in Rust",
            "url": "https://dev.to/nathan20/how-to-handle-errors-in-rust-a-comprehensive-guide-1cco"
          }
        ]
      }
    },
    {
      "id": "wQHkBydWsiGEOZMdKmz40",
      "name": "Option and Result Enumerations",
      "resources": {
        "description": "# Option & Result Enumerations\n\n`Option<T>` handles nullable values with `Some(T)` and `None` variants, replacing null pointers safely. `Result<T, E>` manages error handling with `Ok(T)` for success and `Err(E)` for failures. Both enums enable safe error handling through pattern matching and method chaining.",
        "resources": [
          {
            "type": "course",
            "title": "Option & unwrap",
            "url": "https://doc.rust-lang.org/rust-by-example/error/option_unwrap.html"
          },
          {
            "type": "course",
            "title": "Result",
            "url": "https://doc.rust-lang.org/rust-by-example/error/result.html"
          },
          {
            "type": "article",
            "title": "Error Handling in Rust - Andrew Gallant's Blog",
            "url": "https://burntsushi.net/rust-error-handling"
          },
          {
            "type": "article",
            "title": "Using unwrap() in Rust is Okay - Andrew Gallant's Blog",
            "url": "https://burntsushi.net/unwrap/"
          }
        ]
      }
    },
    {
      "id": "pTC1ucmErVnMbNFnYLJK7",
      "name": "Propagating Errors and `?` Operator",
      "resources": {
        "description": "# Propagating Errors and `?` Operator\n\nThe `?` operator provides concise error propagation in functions returning `Result` or `Option`. It automatically unwraps `Ok`/`Some` values or early-returns `Err`/`None` to the caller. This eliminates verbose `match` expressions and enables clean, readable error handling patterns.",
        "resources": [
          {
            "type": "course",
            "title": "Recoverable Errors with Result",
            "url": "https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html"
          },
          {
            "type": "article",
            "title": "Understanding Result, Option, and '?' Operators in Rust",
            "url": "https://howtorust.com/understanding-result-option-and-operators-in-rust/"
          }
        ]
      }
    },
    {
      "id": "LwqOxYY9E9MUDgz2M40uV",
      "name": "Custom Error Types and Traits",
      "resources": {
        "description": "# Custom Error Types and Traits\n\nCustom error types use `enum` to define specific error variants with attached data. Implement `Debug`, `Display`, and optionally `std::error::Error` traits for proper error handling integration. Libraries like `thiserror` provide derive macros to simplify custom error creation and formatting.",
        "resources": [
          {
            "type": "course",
            "title": "Defining an Error Type",
            "url": "https://doc.rust-lang.org/rust-by-example/error/multiple_error_types/define_error_type.html"
          }
        ]
      }
    },
    {
      "id": "Zpowr_NGd-E2DC3g-oW9h",
      "name": "Modules & Crates",
      "resources": {
        "description": "# Modules and Crates\n\nModules provide namespacing and encapsulation within a crate, organizing code with `mod` keyword and controlling visibility with `pub`. Crates are compilation units (binaries or libraries) that can depend on other crates. The module system organizes code within crates, while crates enable sharing functionality between projects.",
        "resources": [
          {
            "type": "course",
            "title": "Crates",
            "url": "https://doc.rust-lang.org/rust-by-example/crates.html"
          },
          {
            "type": "course",
            "title": "Managing Growing Projects with Packages, Crates, and Modules",
            "url": "https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"
          },
          {
            "type": "article",
            "title": "How It Works: Rust's Module System Finally Explained",
            "url": "https://confidence.sh/blog/rust-module-system-explained/"
          }
        ]
      }
    },
    {
      "id": "c_SdccEXEJyh4ymWzvCeX",
      "name": "Code Organization & Namespacing",
      "resources": {
        "description": "# Code Organization and Namespacing\n\nRust organizes code through modules (`mod`) for grouping related functionality and crates (binary/library projects). Modules provide namespacing and can be nested. Crates are compilation units with a root file (`main.rs` or `lib.rs`) forming the module tree for libraries or executables.",
        "resources": [
          {
            "type": "course",
            "title": "Modules",
            "url": "https://doc.rust-lang.org/rust-by-example/mod.html"
          },
          {
            "type": "course",
            "title": "Namespaces",
            "url": "https://doc.rust-lang.org/reference/names/namespaces.html"
          },
          {
            "type": "article",
            "title": "Explore top posts about General Programming",
            "url": "https://app.daily.dev/tags/general-programming?ref=roadmapsh"
          }
        ]
      }
    },
    {
      "id": "PkePVzV-b1pgFJP5xID5_",
      "name": "Dependency Management with Cargo",
      "resources": {
        "description": "# Dependency Management with Cargo.toml\n\nCargo manages Rust projects and dependencies through `Cargo.toml` files. Dependencies are listed in `[dependencies]` sections with crate names and semantic version specifications. Cargo automatically downloads, builds, and manages external libraries (crates) from crates.io or other sources.",
        "resources": [
          {
            "type": "course",
            "title": "Dependencies",
            "url": "https://doc.rust-lang.org/rust-by-example/cargo/deps.html"
          },
          {
            "type": "course",
            "title": "Cargo",
            "url": "https://blog.rust-lang.org/2016/05/05/cargo-pillars.html"
          }
        ]
      }
    },
    {
      "id": "Op0-bdMV3kE9Be6Ot1aC6",
      "name": "Publishing on Crates.io",
      "resources": {
        "description": "# Publishing on crates.io\n\nPublishing Rust crates involves creating an account on crates.io, preparing proper `Cargo.toml` metadata, and using `cargo publish`. Once published, versions cannot be deleted or overwritten, ensuring dependency stability. The registry serves as Rust's central package repository for sharing libraries.",
        "resources": [
          {
            "type": "course",
            "title": "The Cargo Book: Publishing",
            "url": "https://doc.rust-lang.org/cargo/reference/publishing.html"
          },
          {
            "type": "article",
            "title": "From Zero to Hero: Your First Rust Crate",
            "url": "https://medium.com/rust-programming-language/from-zero-to-hero-your-first-rust-crate-6f2c084df464"
          }
        ]
      }
    },
    {
      "id": "pehYc_xLrs6BFUbcpPTiJ",
      "name": "Concurrency & Parallelism",
      "resources": {
        "description": "# Concurrency and Parallelism\n\nConcurrency allows tasks to run in overlapping time periods (interleaved execution), while parallelism executes multiple tasks simultaneously on different cores. Rust provides safe concurrency primitives like channels, mutexes, and atomic operations without data races, enforced at compile time.",
        "resources": [
          {
            "type": "course",
            "title": "Fearless Concurrency",
            "url": "https://doc.rust-lang.org/book/ch16-00-concurrency.html"
          },
          {
            "type": "article",
            "title": "Rust Concurrency and Parallelism",
            "url": "https://rustlang.app/article/Rust_concurrency_and_parallelism.html"
          },
          {
            "type": "article",
            "title": "Concurrency and Parallelism in Rust",
            "url": "https://sterlingcobb.medium.com/concurrency-and-parallelism-in-rust-an-overview-and-examples-bd811f5a5afe"
          }
        ]
      }
    },
    {
      "id": "pJN260pWQVO0gHxi1-_3U",
      "name": "Threads, Channels and Message Passing",
      "resources": {
        "description": "# Threads, Channels, and Message Passing\n\nRust provides native threading with `std::thread::spawn()` and `join()` for 1:1 OS thread mapping. Channels enable safe message passing between threads, avoiding shared state issues. This model promotes concurrent programming without data races through Rust's ownership system.",
        "resources": [
          {
            "type": "course",
            "title": "std::thread",
            "url": "https://doc.rust-lang.org/std/thread/"
          },
          {
            "type": "course",
            "title": "Using Message Passing to Transfer Data Between Threads",
            "url": "https://doc.rust-lang.org/book/ch16-02-message-passing.html"
          },
          {
            "type": "article",
            "title": "Understanding Threads in Rust: A Comprehensive Guide",
            "url": "https://blog.stackademic.com/understanding-threads-in-rust-a-comprehensive-guide-7e2d23fb85b0"
          },
          {
            "type": "article",
            "title": "Rust Atomics and Locks - Low-Level Concurrency in Practice",
            "url": "https://marabos.nl/atomics/"
          }
        ]
      }
    },
    {
      "id": "n1Epl_nBuoXW2OE0IKYVR",
      "name": "Atomic Operations & Memory Barriers",
      "resources": {
        "description": "# Atomic Operations and Memory Barriers\n\nAtomic operations provide lock-free concurrency through uninterruptible operations like `load`, `store`, `swap`, and `compare_and_swap`. These low-level primitives enable thread-safe data sharing without locks, forming the foundation for higher-level concurrent abstractions and non-blocking data structures.",
        "resources": [
          {
            "type": "course",
            "title": "fence in std::sync::atomic",
            "url": "https://doc.rust-lang.org/std/sync/atomic/fn.fence.html"
          },
          {
            "type": "article",
            "title": "Atomic Operations and Memory Barriers",
            "url": "https://medium.com/@murataslan1/atomic-operations-and-memory-barriers-43ee6f60ead5"
          }
        ]
      }
    },
    {
      "id": "kVfBbsOHoixvqb4dYTG3Q",
      "name": "Futures and Async/Await Paradigm",
      "resources": {
        "description": "# Futures and Async/Await Paradigm\n\nFutures represent asynchronous computations that produce values or errors eventually. The `async/await` syntax provides ergonomic programming over futures, allowing asynchronous code to look synchronous. Futures are lazy and must be polled to make progress, forming the foundation of Rust's async ecosystem.",
        "resources": [
          {
            "type": "course",
            "title": "Fundamentals of Asynchronous Programming",
            "url": "https://doc.rust-lang.org/book/ch17-00-async-await.html"
          },
          {
            "type": "article",
            "title": "Async/Await in Rust: A Beginner's Guide",
            "url": "https://leapcell.medium.com/async-await-in-rust-a-beginners-guide-8752d2c2abbf"
          }
        ]
      }
    },
    {
      "id": "08qKtgnhJ3tlb5JKfTDf5",
      "name": "Testing",
      "resources": {
        "description": "# Testing\n\nRust has built-in testing support through `cargo test` and the `#[test]` attribute. Test functions use assertion macros like `assert!`, `assert_eq!`, and `assert_ne!` to verify expected behavior. Organize tests with unit tests, integration tests, and documentation tests for comprehensive coverage.",
        "resources": [
          {
            "type": "course",
            "title": "Writing Automated Tests",
            "url": "https://doc.rust-lang.org/book/ch11-01-writing-tests.html"
          },
          {
            "type": "article",
            "title": "Testing in Rust: A Quick Guide to Unit Tests",
            "url": "https://dev.to/tramposo/testing-in-rust-a-quick-guide-to-unit-tests-integration-tests-and-benchmarks-2bah"
          },
          {
            "type": "video",
            "title": "Mocking and Testing Rust",
            "url": "https://www.youtube.com/watch?v=8XaVlL3lObQ"
          },
          {
            "type": "article",
            "title": "Explore top posts about Testing",
            "url": "https://app.daily.dev/tags/testing?ref=roadmapsh"
          }
        ]
      }
    },
    {
      "id": "w9coeW9-crDxu0KC-9gEU",
      "name": "Unit & Integration Testing",
      "resources": {
        "description": "# Unit and Integration Testing\n\nUnit tests verify individual functions using `#[test]` and live alongside code. Integration tests are in separate files/directories and test component interactions. Rust provides `cargo test` to run both types, supporting test organization for comprehensive code verification and quality assurance.",
        "resources": [
          {
            "type": "course",
            "title": "Unit Testing",
            "url": "https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html"
          },
          {
            "type": "course",
            "title": "How to Write Tests",
            "url": "https://doc.rust-lang.org/book/ch11-01-writing-tests.html"
          },
          {
            "type": "article",
            "title": "Testing in Rust: A Quick Guide to Unit Tests",
            "url": "https://dev.to/tramposo/testing-in-rust-a-quick-guide-to-unit-tests-integration-tests-and-benchmarks-2bah"
          },
          {
            "type": "video",
            "title": "Mocking and Testing Rust",
            "url": "https://www.youtube.com/watch?v=8XaVlL3lObQ"
          }
        ]
      }
    },
    {
      "id": "HEqfA6An6ZeT3z4R610en",
      "name": "Mocking & Property Based Testing",
      "resources": {
        "description": "# Mocking and Property-based Testing\n\nMocking creates fake functions/objects for testing different scenarios. Rust uses external libraries like `mockito`, `mockall`, and `mockall_double` for mocking capabilities. Property-based testing generates test cases automatically to verify code behavior across a wide range of inputs.",
        "resources": [
          {
            "type": "article",
            "title": "Docs.rs: mockito",
            "url": "https://docs.rs/mockito/latest/mockito/"
          },
          {
            "type": "article",
            "title": "Docs.rs: mockall",
            "url": "https://docs.rs/mockall/latest/mockall/"
          },
          {
            "type": "article",
            "title": "Docs.rs: mockall\\_double",
            "url": "https://docs.rs/mockall_double/latest/mockall_double/"
          },
          {
            "type": "article",
            "title": "Mocking in Rust: Mockall and alternatives",
            "url": "https://blog.logrocket.com/mocking-rust-mockall-alternatives/"
          },
          {
            "type": "article",
            "title": "Explore top posts about Testing",
            "url": "https://app.daily.dev/tags/testing?ref=roadmapsh"
          }
        ]
      }
    },
    {
      "id": "zLKbYX0nnbfD5n3P_JRaS",
      "name": "Traits & Generics",
      "resources": {
        "description": "# Traits and Generics\n\nTraits define shared behavior that types can implement, while generics enable code reuse with type parameters. Together, they provide trait bounds (`T: Display`) to constrain generic types, ensuring they have required functionality. This enables safe, zero-cost polymorphism and code abstraction.",
        "resources": [
          {
            "type": "course",
            "title": "Generic Types, Traits, and Lifetimes",
            "url": "https://doc.rust-lang.org/book/ch10-00-generics.html"
          }
        ]
      }
    },
    {
      "id": "_EicstELZcdesHiXFWJGu",
      "name": "Trait Definitions & Implementations",
      "resources": {
        "description": "# Trait Definitions and Implementations\n\nTraits define shared behavior as a set of method signatures that types can implement. Define with `trait Name { fn method(&self); }` and implement with `impl TraitName for Type`. Traits enable polymorphism, code reuse, and abstraction while maintaining type safety and zero-cost performance.",
        "resources": [
          {
            "type": "course",
            "title": "Traits",
            "url": "https://doc.rust-lang.org/rust-by-example/trait.html"
          },
          {
            "type": "article",
            "title": "Understanding Traits and Trait Bounds in Rust",
            "url": "https://leapcell.medium.com/understanding-traits-and-trait-bounds-in-rust-d575f19dd649"
          }
        ]
      }
    },
    {
      "id": "pRDgDtRIVpNM2CdhSOS3Q",
      "name": "Trait Bounds and Associated Types",
      "resources": {
        "description": "# Trait Bounds and Associated Types\n\nTrait bounds constrain generics by requiring types to implement specific traits (`T: Display`). Associated types define type placeholders within traits that implementors must specify. Together, they enable flexible generic programming with type safety and improved API design patterns.",
        "resources": [
          {
            "type": "course",
            "title": "Trait and Lifetime Bounds",
            "url": "https://doc.rust-lang.org/reference/trait-bounds.html"
          },
          {
            "type": "article",
            "title": "Understanding Traits and Trait Bounds in Rust",
            "url": "https://leapcell.medium.com/understanding-traits-and-trait-bounds-in-rust-d575f19dd649"
          }
        ]
      }
    },
    {
      "id": "_hxwo_iAdOwlWBltv7i6i",
      "name": "Generics & Type-Level Programming",
      "resources": {
        "description": "# Advanced Generics and Type-level Programming\n\nAdvanced generics in Rust include `where` clauses for complex bounds, `?Sized` for unsized types, associated types, and higher-kinded types. These enable sophisticated type-level programming, allowing precise control over generic constraints and enabling powerful abstractions while maintaining zero-cost performance.",
        "resources": [
          {
            "type": "course",
            "title": "Generic Types, Traits, and Lifetimes",
            "url": "https://doc.rust-lang.org/book/ch10-00-generics.html"
          },
          {
            "type": "course",
            "title": "Generics",
            "url": "https://doc.rust-lang.org/rust-by-example/generics.html"
          },
          {
            "type": "course",
            "title": "Generics Data Type",
            "url": "https://doc.rust-lang.org/book/ch10-01-syntax.html"
          }
        ]
      }
    },
    {
      "id": "UZ56NKloehcxUFNuSeO19",
      "name": "Lifetimes & Borrow Checker",
      "resources": {
        "description": "# Lifetimes and Borrow Checker\n\nLifetimes define how long references remain valid, preventing dangling references and memory safety issues. The borrow checker enforces these rules at compile time. Lifetime annotations use syntax like `'a` to specify relationships between references in function signatures when the compiler can't infer them automatically.",
        "resources": [
          {
            "type": "course",
            "title": "Lifetimes",
            "url": "https://doc.rust-lang.org/rust-by-example/scope/lifetime.html"
          },
          {
            "type": "article",
            "title": "Mastering Lifetimes in Rust: Memory Safety and Borrow Checking",
            "url": "https://leapcell.medium.com/mastering-lifetimes-in-rust-memory-safety-and-borrow-checking-4a8c082a54ee"
          },
          {
            "type": "video",
            "title": "Crust of Rust: Lifetime Annotations",
            "url": "https://youtu.be/rAl-9HwD858"
          }
        ]
      }
    },
    {
      "id": "R5HIVS-lyCp9b46aXqx2m",
      "name": "Explicit Lifetime Annotations",
      "resources": {
        "description": "# Explicit Lifetime Annotations\n\nExplicit lifetime annotations use syntax like `'a` to specify relationships between reference lifetimes in function signatures. Required when the compiler can't infer lifetimes automatically. Example: `fn longest<'a>(x: &'a str, y: &'a str) -> &'a str` ensures all references live equally long.",
        "resources": [
          {
            "type": "course",
            "title": "Explicit Annotation",
            "url": "https://doc.rust-lang.org/rust-by-example/scope/lifetime/explicit.html"
          },
          {
            "type": "article",
            "title": "What are Lifetimes in Rust? Explained with Code Examples",
            "url": "https://www.freecodecamp.org/news/what-are-lifetimes-in-rust-explained-with-code-examples/"
          }
        ]
      }
    },
    {
      "id": "qJI8GObmsxyc_tTtUEOAd",
      "name": "Lifetime Elision Rules",
      "resources": {
        "description": "# Lifetime Elision Rules\n\nLifetime elision allows the compiler to infer lifetimes in common patterns, reducing explicit annotations. Rules: each reference parameter gets its own lifetime, single input lifetime applies to all outputs, methods with `&self` propagate its lifetime to outputs. Simplifies code while maintaining safety.",
        "resources": [
          {
            "type": "course",
            "title": "Lifetime Elision",
            "url": "https://doc.rust-lang.org/reference/lifetime-elision.html"
          },
          {
            "type": "article",
            "title": "Understanding Lifetime Elision in Rust",
            "url": "https://masteringbackend.com/posts/understanding-lifetime-elision-in-rust"
          }
        ]
      }
    },
    {
      "id": "7yVvMnvCvLbFa51pESx0j",
      "name": "Covariant & Contravariant Lifetimes",
      "resources": {
        "description": "# Covariant and Contravariant Lifetimes\n\nVariance describes how subtyping relationships change when types are nested. Covariant types preserve ordering (`&'long T` is subtype of `&'short T`), contravariant reverses it, invariant requires exact matches. Affects how lifetimes work with references, boxes, and function parameters.\n\nLearn more from the following links:\n\n- [@official@Subtyping and Variance](https://doc.rust-lang.org/nomicon/subtyping.html)\n- [@article@Demystifying Covariant and Contravariant Lifetimes in Rust](https://medium.com/@murataslan1/demystifying-covariant-and-contravariant-lifetimes-in-rust-76051484fe1c)",
        "resources": [
          {
            "type": "course",
            "title": "Subtyping and Variance",
            "url": "https://doc.rust-lang.org/nomicon/subtyping.html"
          },
          {
            "type": "article",
            "title": "Demystifying Covariant and Contravariant Lifetimes in Rust",
            "url": "https://medium.com/@murataslan1/demystifying-covariant-and-contravariant-lifetimes-in-rust-76051484fe1c"
          }
        ]
      }
    },
    {
      "id": "eTpZXd8E2jVBmk_aSLZYV",
      "name": "Macros & Metaprogramming",
      "resources": {
        "description": "# Macros and Metaprogramming\n\nMacros are code that writes code, enabling metaprogramming in Rust. Declarative macros use `macro_rules!` for pattern-based code generation, while procedural macros provide custom derives and function-like macros. They're expanded at compile time, offering zero-cost abstractions.",
        "resources": [
          {
            "type": "course",
            "title": "Macros",
            "url": "https://doc.rust-lang.org/book/ch20-05-macros.html"
          },
          {
            "type": "course",
            "title": "macro_rules\\!",
            "url": "https://doc.rust-lang.org/rust-by-example/macros.html"
          },
          {
            "type": "article",
            "title": "Macros in Rust: A Tutorial with Examples",
            "url": "https://blog.logrocket.com/macros-in-rust-a-tutorial-with-examples/"
          },
          {
            "type": "article",
            "title": "Metaprogramming Magic in Rust: The Complete Guide",
            "url": "https://elitedev.in/rust/metaprogramming-magic-in-rust-the-complete-guide-/"
          }
        ]
      }
    },
    {
      "id": "AXWXXsww7Xkl3BYgtThNe",
      "name": "Declarative Macros with macro_rules!",
      "resources": {
        "description": "# Declarative Macros with macro_rules!\n\nDeclarative macros use `macro_rules!` for pattern-based code generation at compile time. They match syntax patterns and expand into replacement code, enabling code reuse without runtime overhead. More limited than procedural macros but simpler to write and understand.",
        "resources": [
          {
            "type": "course",
            "title": "Macros",
            "url": "https://doc.rust-lang.org/book/ch20-05-macros.html"
          },
          {
            "type": "article",
            "title": "Macros in Rust: A Tutorial with Examples",
            "url": "https://blog.logrocket.com/macros-in-rust-a-tutorial-with-examples/"
          }
        ]
      }
    },
    {
      "id": "bkVM1OIbv4XUpY6FQb8x_",
      "name": "Procedural Macros & Custom Derive",
      "resources": {
        "description": "# Procedural Macros and Custom Derive\n\nProcedural macros operate on token streams at compile time, generating new code. Three types exist: custom derive (for `#[derive(MyTrait)]`), attribute-like (`#[my_attr]`), and function-like (`my_macro!()`). More powerful than declarative macros but require separate crates with special configuration.",
        "resources": [
          {
            "type": "course",
            "title": "Procedural Macros",
            "url": "https://doc.rust-lang.org/reference/procedural-macros.html"
          },
          {
            "type": "article",
            "title": "Understanding Procedural Macros and Custom Derive",
            "url": "https://www.gyata.ai/rust/procedural-macros-and-custom-derive"
          }
        ]
      }
    },
    {
      "id": "Kb7KF7JCMaWFz-GuaQmQV",
      "name": "Domain Specific Languages (DSLs)",
      "resources": {
        "description": "# Domain-Specific Languages (DSLs)\n\nDSLs are specialized programming languages for specific domains. Rust macros enable creating DSLs by manipulating syntax trees and defining custom syntax patterns. This allows extending Rust's language capabilities for specialized applications like game development, configuration, or domain-specific tasks.",
        "resources": [
          {
            "type": "course",
            "title": "Domain Specific Languages (DSLs)",
            "url": "https://doc.rust-lang.org/rust-by-example/macros/dsl.html"
          },
          {
            "type": "article",
            "title": "Crafting Expressive Tools: Domain-Specific Languages (DSLs)",
            "url": "https://medium.com/@murataslan1/crafting-expressive-tools-domain-specific-languages-dsls-in-rust-94394debe12b"
          }
        ]
      }
    },
    {
      "id": "KomYBYxj0FTrJDYB3nU5B",
      "name": "Web Development",
      "resources": {
        "description": "# Web Development\n\nRust offers excellent web development capabilities with frameworks like Actix, Rocket, Axum, and Warp. These provide HTTP handling, routing, middleware, and database integration. Rust's performance and safety make it ideal for high-performance web services, APIs, and microservices.",
        "resources": [
          {
            "type": "course",
            "title": "Rocket - Simple, Fast, Type-Safe Web Framework for Rust",
            "url": "https://rocket.rs/"
          },
          {
            "type": "article",
            "title": "Rust for Web Development: A Beginner's Guide",
            "url": "https://medium.com/@enravishjeni411/rust-for-web-development-a-beginners-guide-fcc994e5c090"
          },
          {
            "type": "article",
            "title": "How to Write Your First Rust Web App with Rocket and RustRover",
            "url": "https://blog.jetbrains.com/rust/2024/02/28/how-to-write-your-first-rust-web-app-with-rocket-and-rustrover/"
          }
        ]
      }
    },
    {
      "id": "duQ1RO1lqq793mfb5w31P",
      "name": "Axum",
      "resources": {
        "description": "# Axum\n\nAxum is a modern, ergonomic web framework built on hyper and designed for async Rust. It features excellent type safety, powerful extractors, middleware support, and seamless Tokio integration. Axum emphasizes developer experience while maintaining high performance for web services and APIs.",
        "resources": [
          {
            "type": "course",
            "title": "Axum Documentation",
            "url": "https://docs.rs/axum/latest/axum/"
          },
          {
            "type": "article",
            "title": "Getting Started with Axum - Rust's Most Popular Web Framework",
            "url": "https://www.shuttle.dev/blog/2023/12/06/using-axum-rust"
          }
        ]
      }
    },
    {
      "id": "3Y90v2ysoMcyjDL24H7mC",
      "name": "Actix",
      "resources": {
        "description": "# Actix\n\nActix is a high-performance, pragmatic web framework for Rust built on the actor model. It features powerful middleware, WebSocket support, and excellent performance benchmarks. Actix provides a flexible, feature-rich API for building web applications, APIs, and microservices with minimal boilerplate.",
        "resources": [
          {
            "type": "course",
            "title": "Actix - Actor framework for Rust",
            "url": "https://actix.rs/"
          },
          {
            "type": "course",
            "title": "Actix Documentation",
            "url": "https://docs.rs/actix/latest/actix/"
          },
          {
            "type": "article",
            "title": "Building a Clean API in Rust with Actix Web",
            "url": "https://medium.com/@anto18671/building-a-clean-api-in-rust-with-actix-web-a-comprehensive-guide-d084e368a988"
          }
        ]
      }
    },
    {
      "id": "n5t3MUqmvrcr36VIIOw0u",
      "name": "Leptos",
      "resources": {
        "description": "# Leptos\n\nLeptos is a rust based web framework that lets you build reactive UIs with Rust and WebAssembly. It supports SSR and CSR, fine-grained reactivity, and a rich ecosystem of libraries and tools. Leptos lets you build web applications with client-side rendering, server-side rendering, or hydration.",
        "resources": [
          {
            "type": "course",
            "title": "Home - Leptos",
            "url": "https://www.leptos.dev/"
          },
          {
            "type": "course",
            "title": "Introduction - Leptos Documentation",
            "url": "https://book.leptos.dev/"
          },
          {
            "type": "tutorial",
            "title": "leptos-rs/leptos: Build fast web applications with Rust",
            "url": "https://github.com/leptos-rs/leptos"
          }
        ]
      }
    },
    {
      "id": "GnSBtZoN9mAehRf5Eczng",
      "name": "Loco",
      "resources": {
        "description": "# Loco\n\nLoco is a web framework for Rust that is inspired by Ruby on Rails, designed to help developers build MVC-style applications easily. It emphasizes simplicity, rapid development, and integrates features like ORM, background jobs, and templating engines for a productive coding experience.",
        "resources": [
          {
            "type": "course",
            "title": "Loco.rs - Productivity-first Rust Fullstack Web Framework",
            "url": "https://loco.rs/"
          },
          {
            "type": "course",
            "title": "The Loco Guide - Loco.rs",
            "url": "https://loco.rs/docs/getting-started/guide/"
          },
          {
            "type": "article",
            "title": "Getting Started with Loco in Rust",
            "url": "https://www.shuttle.dev/blog/2023/12/28/using-loco-rust-rails"
          }
        ]
      }
    },
    {
      "id": "ApjwY_70OGG_dNIC85oBD",
      "name": "Rocket",
      "resources": {
        "description": "# Rocket\n\nRocket is a web framework for Rust emphasizing ease of use, expressiveness, and type safety. It features code generation via procedural macros, built-in templating, request guards, and comprehensive error handling. Rocket prioritizes developer productivity with intuitive APIs and detailed error messages.",
        "resources": [
          {
            "type": "course",
            "title": "Rocket - Simple, Fast, Type-Safe Web Framework for Rust",
            "url": "https://rocket.rs/"
          },
          {
            "type": "article",
            "title": "Getting Started with Rocket in Rust",
            "url": "https://www.shuttle.dev/blog/2023/12/13/using-rocket-rust"
          }
        ]
      }
    },
    {
      "id": "yu0f5gALho0e8wzV10yow",
      "name": "Asynchronous Programming",
      "resources": {
        "description": "# Asynchronous Programming\n\nAsync programming in Rust allows executing tasks concurrently rather than sequentially, enabling efficient resource usage especially in IO-heavy applications. Rust provides `async` and `await` keywords: `async` marks functions that can return `Future` values, while `await` pauses and resumes async functions. Popular async runtimes like Tokio and async-std manage task execution efficiently.",
        "resources": [
          {
            "type": "course",
            "title": "Fundamentals of Asynchronous Programming",
            "url": "https://doc.rust-lang.org/book/ch17-00-async-await.html"
          },
          {
            "type": "course",
            "title": "async-std",
            "url": "https://docs.rs/async-std/latest/async_std/"
          },
          {
            "type": "article",
            "title": "Demystifying Async Programming in Rust",
            "url": "https://medium.com/@trek007/demystifying-async-programming-in-rust-a-complete-guide-with-real-world-examples-147079950f8b"
          },
          {
            "type": "article",
            "title": "Rust Async Programming: Tokio & Async-std",
            "url": "https://medium.com/@AlexanderObregon/async-programming-in-rust-exploring-tokio-and-async-std-97d4b524cef0"
          }
        ]
      }
    },
    {
      "id": "H0mctp3Bj2OYfIGFDWGfz",
      "name": "Tokio",
      "resources": {
        "description": "# Tokio\n\nTokio is Rust's most popular async runtime for building fast, reliable network applications. It provides an async/await runtime, I/O drivers, timers, and networking primitives. Tokio enables high-performance concurrent applications by efficiently managing thousands of tasks on a small number of threads.",
        "resources": [
          {
            "type": "course",
            "title": "Tokio",
            "url": "https://tokio.rs/"
          },
          {
            "type": "article",
            "title": "Tokio Docs",
            "url": "https://docs.rs/tokio/latest/tokio/"
          }
        ]
      }
    },
    {
      "id": "_2uQInXPdOY-DpYTO1Prt",
      "name": "async-std",
      "resources": {
        "description": "# async-std\n\n`async-std` provides an asynchronous version of Rust's standard library, offering familiar APIs for async programming. It includes its own runtime, task scheduler, and async I/O primitives, designed as a drop-in replacement for std with async capabilities and intuitive syntax.",
        "resources": [
          {
            "type": "course",
            "title": "async-std",
            "url": "https://docs.rs/async-std/latest/async_std/"
          },
          {
            "type": "article",
            "title": "Rust Async Programming: Tokio & Async-std",
            "url": "https://medium.com/@AlexanderObregon/async-programming-in-rust-exploring-tokio-and-async-std-97d4b524cef0"
          }
        ]
      }
    },
    {
      "id": "3C9gCBAq3OQVb583S72D4",
      "name": "smol",
      "resources": {
        "description": "# smol\n\n`smol` is a small, fast async runtime for Rust with minimal API and clean design. Built on async-std and Tokio, it supports async/await natively with efficient scheduling. Offers essential async functionality including timers, futures, and task management with superior performance in a lightweight package.",
        "resources": [
          {
            "type": "course",
            "title": "Smol - Gist of Rust",
            "url": "https://book.gist.rs/rust/r1/smol.html"
          },
          {
            "type": "article",
            "title": "Smol Documentation",
            "url": "https://docs.rs/smol/latest/smol/"
          },
          {
            "type": "tutorial",
            "title": "smol-rs/smol: A small and fast async runtime for Rust",
            "url": "https://github.com/smol-rs/smol"
          }
        ]
      }
    },
    {
      "id": "3pL0ARqk8uRNimopHSalW",
      "name": "Networking",
      "resources": {
        "description": "# Networking\n\nRust's `std::net` module provides networking primitives including `TcpStream`, `TcpListener`, `UdpSocket`, and address types. Built on BSD sockets, it offers low-level network operations for building networking applications. Higher-level crates like Tokio provide async networking capabilities.",
        "resources": [
          {
            "type": "course",
            "title": "std\\:\\:net",
            "url": "https://doc.rust-lang.org/std/net/"
          },
          {
            "type": "course",
            "title": "TcpListener",
            "url": "https://doc.rust-lang.org/std/net/struct.TcpListener.html"
          },
          {
            "type": "course",
            "title": "UdpSocket",
            "url": "https://doc.rust-lang.org/std/net/struct.UdpSocket.html"
          },
          {
            "type": "course",
            "title": "TcpStream",
            "url": "https://doc.rust-lang.org/std/net/struct.TcpStream.html"
          },
          {
            "type": "article",
            "title": "Networking Fundamentals in Rust",
            "url": "https://medium.com/@murataslan1/networking-fundamentals-in-rust-525dcfbd5058"
          }
        ]
      }
    },
    {
      "id": "TtajUXZpyNx9AmdUawm-8",
      "name": "reqwest",
      "resources": {
        "description": "# reqwest\n\n`reqwest` is a popular HTTP client library for Rust that provides both sync and async APIs for making HTTP requests. Built on `hyper` and `tokio`, it supports JSON, forms, cookies, and various authentication methods with an ergonomic, easy-to-use interface for web API interactions.",
        "resources": [
          {
            "type": "article",
            "title": "Making HTTP requests in Rust with Reqwest",
            "url": "https://blog.logrocket.com/making-http-requests-rust-reqwest/"
          },
          {
            "type": "article",
            "title": "Exploring Reqwest in Rust",
            "url": "https://medium.com/@chetanreddyk394/exploring-reqwest-in-rust-b91c548e69af"
          },
          {
            "type": "article",
            "title": "Reqwest Documentation",
            "url": "https://docs.rs/reqwest/latest/reqwest/"
          }
        ]
      }
    },
    {
      "id": "-MiN5ytI43EjgmWV55BhU",
      "name": "hyper",
      "resources": {
        "description": "# hyper\n\nHyper is a fast, safe HTTP client/server library for Rust built on Tokio for async I/O. It supports HTTP/1 and HTTP/2 with automatic protocol negotiation. Hyper provides low-level HTTP primitives that power many higher-level web frameworks and serves as the foundation for efficient network programming.",
        "resources": [
          {
            "type": "course",
            "title": "Hyper.rs",
            "url": "https://hyper.rs/"
          },
          {
            "type": "article",
            "title": "Hyper Documentation",
            "url": "https://docs.rs/hyper/latest/hyper/"
          },
          {
            "type": "article",
            "title": "Creating a Basic HTTP Server in Rust using Hyper",
            "url": "https://medium.com/@ajay.bhatia/creating-a-basic-http-server-in-rust-using-hyper-a-step-by-step-tutorial-459b48d61151"
          }
        ]
      }
    },
    {
      "id": "qi1pmsY8bPk8nbHiBIGha",
      "name": "quinn",
      "resources": {
        "description": "# quinn\n\n`Quinn` is a high-performance QUIC protocol implementation for Rust built on Tokio. QUIC is a modern transport protocol offering better performance than TCP with multiplexing and security. Quinn provides async, futures-based API supporting both client and server roles for networking applications.",
        "resources": [
          {
            "type": "tutorial",
            "title": "quinn-rs/quinn: Async-friendly QUIC implementation in Rust",
            "url": "https://github.com/quinn-rs/quinn"
          },
          {
            "type": "course",
            "title": "Quinn â€” Rust Network Library",
            "url": "https://lib.rs/crates/quinn"
          },
          {
            "type": "article",
            "title": "Quinn",
            "url": "https://docs.rs/quinn/latest/quinn/"
          }
        ]
      }
    },
    {
      "id": "gcmKSLWfBqx4aPZOmyQsg",
      "name": "Serialization / Deserialization",
      "resources": {
        "description": "# Serialization/Deserialization\n\nSerialization converts Rust data structures into bytes for storage or transmission, while deserialization reverses the process. *Serde* is the standard framework with support for JSON, YAML, TOML, Binary, and more formats. Provides efficient, type-safe data conversion.",
        "resources": [
          {
            "type": "article",
            "title": "Serde Documentation",
            "url": "https://docs.rs/serde/latest/serde/"
          },
          {
            "type": "article",
            "title": "Serialization and Deserialization in Rust: A Comprehensive Guide",
            "url": "https://rustmeup.com/serialization-in-rust-with-serde"
          },
          {
            "type": "article",
            "title": "Rust Serialization: Easy Beginner's Guide with Examples",
            "url": "https://boxoflearn.com/rust-serialization-guide/"
          }
        ]
      }
    },
    {
      "id": "EHErECEYws05oi59OsZpC",
      "name": "Serde",
      "resources": {
        "description": "# Serde\n\nSerde is Rust's most popular serialization framework for converting data structures to/from formats like JSON, YAML, TOML, and Binary. It provides `Serialize` and `Deserialize` traits with derive macros for automatic implementation. Offers high performance with customizable behavior for complex use cases.",
        "resources": [
          {
            "type": "course",
            "title": "Serde",
            "url": "https://serde.rs/"
          },
          {
            "type": "article",
            "title": "Serde Documentation",
            "url": "https://docs.rs/serde/latest/serde/"
          },
          {
            "type": "article",
            "title": "Serialization in Rust with Serde",
            "url": "https://rustmeup.com/serialization-in-rust-with-serde"
          }
        ]
      }
    },
    {
      "id": "ZXMKY0f7mqqlsvyH9u-LM",
      "name": "json-rust",
      "resources": {
        "description": "# json-rust\n\nJSON handling in Rust primarily uses `serde` and `serde_json` libraries for high-performance serialization/deserialization. These provide seamless conversion between Rust data structures and JSON, with parsing from strings/files, serialization to JSON, and direct manipulation of JSON values.",
        "resources": [
          {
            "type": "course",
            "title": "Serde",
            "url": "https://serde.rs/"
          },
          {
            "type": "article",
            "title": "Docs.rs: JSON",
            "url": "https://docs.rs/json/latest/json/"
          },
          {
            "type": "tutorial",
            "title": "serde-rs/serde: Serialization framework for Rust",
            "url": "https://github.com/serde-rs/serde"
          },
          {
            "type": "article",
            "title": "Explore top posts about Rust",
            "url": "https://app.daily.dev/tags/rust?ref=roadmapsh"
          }
        ]
      }
    },
    {
      "id": "LmFog_qXrS9e5ARhV6OD_",
      "name": "toml-rs",
      "resources": {
        "description": "# TOML Parsing\n\n`toml-rs` parses and serializes TOML (Tom's Obvious, Minimal Language) configuration files in Rust. Uses serde for automatic serialization/deserialization between TOML and Rust types. Leverages Rust's trait system and type inference to convert TOML documents into statically-typed Rust structures.",
        "resources": [
          {
            "type": "course",
            "title": "TOML",
            "url": "https://docs.rs/toml/latest/toml/"
          }
        ]
      }
    },
    {
      "id": "_n7emeqzf5UTxVB5-385G",
      "name": "Database and ORM",
      "resources": {
        "description": "# Database and ORM\n\nORMs (Object-Relational Mapping) provide abstraction layers between Rust code and SQL databases. Popular Rust ORMs include Diesel (compile-time safety), SQLx (async with compile-time query checking), and Sea-ORM. They eliminate raw SQL writing while maintaining type safety and performance.",
        "resources": [
          {
            "type": "course",
            "title": "Diesel is a Safe, Extensible ORM and Query Builder for Rust",
            "url": "https://diesel.rs/"
          },
          {
            "type": "article",
            "title": "Choosing the Right ORM for Rust: A Comparative Analysis",
            "url": "https://medium.com/@wiederinchristoph/rusts-ecosystem-offers-a-variety-of-object-relational-mapping-orm-libraries-and-database-ce4690a97a61"
          }
        ]
      }
    },
    {
      "id": "UAXpBK3lfnq0Q4RcBehZ1",
      "name": "Diesel",
      "resources": {
        "description": "# Diesel\n\nDiesel is a safe, extensible ORM and query builder for Rust that provides compile-time guarantees against SQL injection and type mismatches. It supports PostgreSQL, MySQL, and SQLite with high-level APIs for database operations while maintaining excellent performance and type safety.",
        "resources": [
          {
            "type": "course",
            "title": "Diesel",
            "url": "https://diesel.rs/"
          },
          {
            "type": "tutorial",
            "title": "Repository",
            "url": "https://github.com/diesel-rs/diesel"
          },
          {
            "type": "article",
            "title": "Docs.rs: Diesel",
            "url": "https://docs.rs/diesel/latest/diesel/"
          },
          {
            "type": "video",
            "title": "Rust & SQL Databases (With Diesel)",
            "url": "https://www.youtube.com/watch?v=tRC4EIKhMzw"
          }
        ]
      }
    },
    {
      "id": "r2KembNZ2WIzLe87EB91K",
      "name": "sqlx",
      "resources": {
        "description": "# sqlx\n\nSQLx is an async, pure-Rust SQL toolkit providing compile-time query checking for PostgreSQL, MySQL, SQLite, and MSSQL. It features macro-based query validation, strong typing, and compatibility with Tokio/async-std runtimes. SQLx eliminates runtime SQL errors through compile-time verification.",
        "resources": [
          {
            "type": "tutorial",
            "title": "launchbadge/sqlx",
            "url": "https://github.com/launchbadge/sqlx"
          },
          {
            "type": "article",
            "title": "sqlx Documentation",
            "url": "https://docs.rs/sqlx/latest/sqlx/"
          },
          {
            "type": "article",
            "title": "Getting Started with SQLx and SQLite in Rust",
            "url": "https://medium.com/rustaceans/getting-started-with-sqlx-and-sqlite-in-rust-895ae7fc01ae"
          }
        ]
      }
    },
    {
      "id": "a2MLN7f-FvsgdmvP9ixlv",
      "name": "rusqlite",
      "resources": {
        "description": "# rusqlite\n\n`rusqlite` is an ergonomic SQLite library for Rust built around the sqlite3 C library. It provides simple, efficient database operations with minimal SQL knowledge required. Features seamless `serde` integration for type-safe bidirectional mapping between SQL and Rust data structures.",
        "resources": [
          {
            "type": "article",
            "title": "Rusqlite",
            "url": "https://docs.rs/rusqlite/latest/rusqlite/"
          },
          {
            "type": "tutorial",
            "title": "rusqlite/rusqlite",
            "url": "https://github.com/rusqlite/rusqlite"
          },
          {
            "type": "article",
            "title": "Rust | Sqlite Database",
            "url": "https://medium.com/@mikecode/rust-sqlite-database-rusqlite-162bad63fb5d"
          }
        ]
      }
    },
    {
      "id": "Rv_Z-rbtELPZ1Nv0PZQmV",
      "name": "Cryptography",
      "resources": {
        "description": "# Cryptography\n\nCryptography involves securing data through encryption (making readable data unreadable) and decryption (reversing the process). Rust offers crypto libraries like `ring`, `sodiumoxide`, and `rust-crypto` for hashing, symmetric/asymmetric encryption, and digital signatures with memory-safe implementations.\n\nLearn more from the following links:\n\n- [@official@Cryptography â€” list of Rust libraries/crates](https://lib.rs/cryptography)\n- [@article@Awesome Rust Cryptography](https://cryptography.rs/)",
        "resources": [
          {
            "type": "course",
            "title": "Cryptography â€” list of Rust libraries/crates",
            "url": "https://lib.rs/cryptography"
          },
          {
            "type": "article",
            "title": "Awesome Rust Cryptography",
            "url": "https://cryptography.rs/"
          }
        ]
      }
    },
    {
      "id": "f68x7r-qzaQfrzXnjOI2q",
      "name": "rust-crypto",
      "resources": {
        "description": "# rust-crypto\n\n`rust-crypto` is a collection of cryptographic algorithms implemented in pure Rust including AES, DES ciphers, SHA, MD5 hash functions, and RSA digital signatures. Known for speed and low memory usage, making it suitable for resource-constrained systems requiring cryptographic functionality.",
        "resources": [
          {
            "type": "article",
            "title": "Awesome Rust Cryptography",
            "url": "https://cryptography.rs/"
          },
          {
            "type": "article",
            "title": "rust-crypto",
            "url": "https://docs.rs/rust-crypto/latest/crypto/"
          },
          {
            "type": "article",
            "title": "Rust | Sqlite Database",
            "url": "https://medium.com/@mikecode/rust-sqlite-database-rusqlite-162bad63fb5d"
          }
        ]
      }
    },
    {
      "id": "hzzRFb5cyXkgUdLZxaozB",
      "name": "sodiumoxide",
      "resources": {
        "description": "# sodiumoxide\n\n`sodiumoxide` is a Rust binding to libsodium cryptography library, designed for easy use and misuse prevention. Provides safe, high-level, idiomatic Rust wrappers for cryptographic primitives with automatic error handling. Follows NaCl design principles for simplicity while offering libsodium performance benefits.",
        "resources": [
          {
            "type": "article",
            "title": "Rust Password Hashing with Argon2id and the Sodiumoxide",
            "url": "https://blue42.net/code/rust/examples/sodiumoxide-password-hashing/post/"
          },
          {
            "type": "article",
            "title": "sodiumoxide/sodiumoxide",
            "url": "https://deepwiki.com/sodiumoxide/sodiumoxide"
          }
        ]
      }
    },
    {
      "id": "w8nxQDxmfoUHkFV66TKiq",
      "name": "ring",
      "resources": {
        "description": "# ring\n\n`ring` is a safe, fast cryptography library for Rust focused on TLS and core cryptographic primitives. It includes RSA, AES, SHA, and other algorithms with compile-time and runtime safety checks. Restricts usage to safe, reviewed algorithms to prevent common cryptographic pitfalls and insecure implementations.",
        "resources": [
          {
            "type": "tutorial",
            "title": "briansmith/ring",
            "url": "https://github.com/briansmith/ring"
          },
          {
            "type": "article",
            "title": "Ring",
            "url": "https://docs.rs/ring/latest/ring/"
          }
        ]
      }
    },
    {
      "id": "2Zyyf9q_CxmOW-z2pipL8",
      "name": "CLI Utilities",
      "resources": {
        "description": "# CLI Utilities\n\nCLI utilities are command-line tools that allow users to interact with their system through text commands. Rust is excellent for building fast, reliable CLI tools due to its memory safety and performance. Popular crates like clap and structopt help parse command-line arguments, handle input validation, and generate help messages, making CLI development efficient.\n\nLearn more from the following links:\n\n- [@official@structopt](https://docs.rs/structopt/latest/structopt/)\n- [@official@clap](https://docs.rs/clap/latest/clap/)\n- [@official@Command-line Apps](https://www.rust-lang.org/what/cli/)\n- [@article@Rust CLI Utilities - GitHub](https://github.com/baldwin-sudo/rusty-utils)",
        "resources": [
          {
            "type": "course",
            "title": "structopt",
            "url": "https://docs.rs/structopt/latest/structopt/"
          },
          {
            "type": "course",
            "title": "clap",
            "url": "https://docs.rs/clap/latest/clap/"
          },
          {
            "type": "course",
            "title": "Command-line Apps",
            "url": "https://www.rust-lang.org/what/cli/"
          },
          {
            "type": "article",
            "title": "Rust CLI Utilities - GitHub",
            "url": "https://github.com/baldwin-sudo/rusty-utils"
          }
        ]
      }
    },
    {
      "id": "AId80IokM7NvGBVutmuGC",
      "name": "clap",
      "resources": {
        "description": "# clap\n\n`clap` is Rust's most popular command-line argument parser library. It provides declarative CLI definition with automatic help generation, subcommands, validation, and error handling. Supports both builder pattern and derive macros for easy CLI app development with comprehensive features.\n\nLearn more from the following links:\n\n- [@official@clap](https://docs.rs/clap/latest/clap/)\n- [@article@Using Clap in Rust for command line (CLI) Argument Parsing](https://blog.logrocket.com/using-clap-rust-command-line-argument-parsing/)",
        "resources": [
          {
            "type": "course",
            "title": "clap",
            "url": "https://docs.rs/clap/latest/clap/"
          },
          {
            "type": "article",
            "title": "Using Clap in Rust for command line (CLI) Argument Parsing",
            "url": "https://blog.logrocket.com/using-clap-rust-command-line-argument-parsing/"
          }
        ]
      }
    },
    {
      "id": "_43912wPdXgLL8v-IMHX_",
      "name": "structopt",
      "resources": {
        "description": "# StructOpt\n\n`StructOpt` is a library for parsing command-line arguments by defining structs where fields represent flags, options, and arguments. Combines `clap`'s parsing power with Rust's type system for declarative CLI definition with automatic help generation, strong typing, and validation.",
        "resources": [
          {
            "type": "course",
            "title": "Defining and Instantiating Structs",
            "url": "https://doc.rust-lang.org/book/ch05-01-defining-structs.html"
          },
          {
            "type": "article",
            "title": "Parsing Command Line Args with StructOpt",
            "url": "https://www.tenderisthebyte.com/blog/2019/05/08/parsing-cli-args-with-structopt/"
          }
        ]
      }
    },
    {
      "id": "YS0igALDqSanGDWva_vls",
      "name": "termion",
      "resources": {
        "description": "# Termion\n\n`termion` is a pure Rust, zero-dependency library for low-level terminal manipulation and information handling. Provides cross-terminal compatibility with features like color support, input handling, and terminal-specific capabilities. Ideal for building cross-platform CLI applications without external bindings.",
        "resources": [
          {
            "type": "course",
            "title": "Termion Documentation",
            "url": "https://docs.rs/termion/latest/termion/"
          },
          {
            "type": "article",
            "title": "Implementing Terminal I/O in Rust | by Packt",
            "url": "https://packt.medium.com/implementing-terminal-i-o-in-rust-4a44652b0f11"
          },
          {
            "type": "article",
            "title": "Making Terminal Applications in Rust with Termion",
            "url": "https://ticki.github.io/blog/making-terminal-applications-in-rust-with-termion/"
          }
        ]
      }
    },
    {
      "id": "uG-EmZVZ-jc3mswOT4-7l",
      "name": "Game Development",
      "resources": {
        "description": "# Game Development\n\nRust's performance and memory safety make it excellent for game development. Popular engines and frameworks include Bevy (ECS-based), Macroquad, ggez, and Fyrox. Rust handles both 2D and 3D games efficiently, with growing ecosystem support for graphics, audio, and physics.",
        "resources": [
          {
            "type": "course",
            "title": "Fyrox - A feature-rich game engine built in Rust",
            "url": "https://fyrox.rs/"
          },
          {
            "type": "article",
            "title": "5 Rust Game Engines to Consider for your Next Project",
            "url": "https://blog.logrocket.com/5-rust-game-engines-consider-next-project/"
          },
          {
            "type": "article",
            "title": "Game Development with Fyrox and Rust",
            "url": "https://bocksdincoding.com/blog/game-development-with-fyrox-and-rust-pt-1"
          }
        ]
      }
    },
    {
      "id": "uyrGki0jB7DXQ0HJe2-vY",
      "name": "bevy",
      "resources": {
        "description": "# bevy\n\nBevy is a modern, data-driven game engine built in Rust featuring an ECS (Entity Component System) architecture. It supports both 2D and 3D games with modular design, custom shaders, and high performance. Bevy emphasizes developer ergonomics and provides comprehensive tools for game development.",
        "resources": [
          {
            "type": "course",
            "title": "Bevy Engine",
            "url": "https://bevy.org/"
          },
          {
            "type": "course",
            "title": "Bevy Documentation",
            "url": "https://docs.rs/bevy/latest/bevy/"
          },
          {
            "type": "tutorial",
            "title": "bevyengine/bevy",
            "url": "https://github.com/bevyengine/bevy"
          }
        ]
      }
    },
    {
      "id": "x9bmK_cLYpX0ebwjZUn4R",
      "name": "fyrox",
      "resources": {
        "description": "# Fyrox\n\nFyrox is a modern, highly optimized 3D game engine designed specifically for Rust. Leverages Rust's safety and concurrency for high performance and reliability. Features advanced lighting, shadowing, support for common 3D formats, and low-level hardware control for performance-critical applications.",
        "resources": [
          {
            "type": "course",
            "title": "Fyrox - A feature-rich game engine built in Rust",
            "url": "https://fyrox.rs/"
          },
          {
            "type": "tutorial",
            "title": "FyroxEngine/Fyrox: 3D and 2D game engine written in Rust",
            "url": "https://github.com/FyroxEngine/Fyrox"
          },
          {
            "type": "article",
            "title": "Game Development with Fyrox and Rust",
            "url": "https://bocksdincoding.com/blog/game-development-with-fyrox-and-rust-pt-1"
          }
        ]
      }
    },
    {
      "id": "qquYnrrzUlyd8738jzj1D",
      "name": "ggez",
      "resources": {
        "description": "# ggez\n\n`ggez` is a lightweight 2D game framework for Rust inspired by Love2D. Provides facilities for graphics rendering, input handling, audio manipulation, and game timing with an easy, Rusty interface. Enables developers to focus on game logic without worrying about low-level implementation details.",
        "resources": [
          {
            "type": "course",
            "title": "ggez: Rust Game Thing",
            "url": "https://ggez.rs/"
          },
          {
            "type": "article",
            "title": "2D Game Renderer in Rust",
            "url": "https://dev.to/trish_07/2d-game-renderer-in-rust-lets-make-a-mini-rpg-a9h"
          }
        ]
      }
    },
    {
      "id": "EtKhe3lgK3NoiBOjXRb2O",
      "name": "macroquad",
      "resources": {
        "description": "# macroquad\n\nMacroquad is a simple, cross-platform 2D game engine for Rust focusing on rapid prototyping and development. Features efficient rendering via miniquad, input handling, coroutine-based async programming, and sound support. Portable across Windows, macOS, Linux, WebAssembly, Android, and iOS.",
        "resources": [
          {
            "type": "course",
            "title": "Macroquad",
            "url": "https://macroquad.rs/"
          },
          {
            "type": "course",
            "title": "Macroquad Documentation",
            "url": "https://macroquad.rs/docs/"
          },
          {
            "type": "article",
            "title": "Rust: Create A Clicker Game With Macroquad",
            "url": "https://dev.to/flavius_the_0th/rust-create-a-clicker-game-with-macroquad-1820"
          }
        ]
      }
    },
    {
      "id": "6wGShK9WEnXiby_Jm8sTO",
      "name": "wgpu-rs",
      "resources": {
        "description": "# wgpu-rs\n\n`wgpu-rs` provides safe, idiomatic Rust graphics programming by abstracting over wgpu-core. Offers high-level convenience with low-level control options. Provides unified access to graphics and compute functionality across Vulkan, Metal, DirectX, and WebGPU backends for cross-platform compatibility.",
        "resources": [
          {
            "type": "course",
            "title": "wgpu: portable graphics library for Rust",
            "url": "https://wgpu.rs/"
          },
          {
            "type": "article",
            "title": "wpgu docs",
            "url": "hhttps://docs.rs/wgpu/latest/wgpu/"
          },
          {
            "type": "tutorial",
            "title": "gfx-rs/wgpu",
            "url": "https://github.com/gfx-rs/wgpu"
          }
        ]
      }
    },
    {
      "id": "T1LlJz5m5wnwBvKAEuGnP",
      "name": "GUI Development",
      "resources": {
        "description": "# GUI Development\n\nRust offers several GUI frameworks for desktop applications including Tauri (web-based), Iced (inspired by Elm), Druid, GTK-rs, and Egui. These provide cross-platform support for creating native desktop applications with modern UI patterns and performance benefits of Rust.",
        "resources": [
          {
            "type": "article",
            "title": "Rust and GUI Development - Comprehensive Guide",
            "url": "https://rustmeup.com/rust-and-gui-development"
          },
          {
            "type": "article",
            "title": "The state of Rust GUI libraries",
            "url": "https://blog.logrocket.com/state-rust-gui-libraries/"
          },
          {
            "type": "article",
            "title": "Building Beautiful and Intuitive GUIs with Rust and egui",
            "url": "https://triophore.com/blogs/content/rust-egui-gui-development/"
          }
        ]
      }
    },
    {
      "id": "Q71MnFDQBkZF1c2hj13pU",
      "name": "tauri",
      "resources": {
        "description": "# Tauri\n\nTauri is a framework for building lightweight, secure desktop applications using web technologies (HTML, CSS, JS) with a Rust backend. It offers smaller bundle sizes than Electron, enhanced security, and cross-platform support for Windows, macOS, and Linux with native system integration.",
        "resources": [
          {
            "type": "course",
            "title": "Tauri",
            "url": "https://tauri.app"
          },
          {
            "type": "course",
            "title": "Tauri Guides",
            "url": "https://v1.tauri.app/v1/guides/"
          },
          {
            "type": "article",
            "title": "How to Build Cross-Platform GUI Applications with Rust & Tauri",
            "url": "https://codezup.com/cross-platform-gui-apps-rust-tauri-guide/"
          }
        ]
      }
    },
    {
      "id": "2Zp3m3Y7j6R1hK3DIVdkH",
      "name": "gtk-rs",
      "resources": {
        "description": "# gtk-rs\n\n`gtk-rs` provides Rust bindings for GTK+3 and related libraries (GObject, Glib, Cairo, Pango) enabling cross-platform GUI application development. These open-source libraries offer a Rust-friendly interface for GTK components, allowing developers to create graphical applications using Rust with native GTK functionality.",
        "resources": [
          {
            "type": "course",
            "title": "Unlocking the GNOME stack for Rust",
            "url": "https://gtk-rs.org/"
          },
          {
            "type": "tutorial",
            "title": "gtk-rs/gtk4-rs: Rust Bindings of GTK 4",
            "url": "https://github.com/gtk-rs/gtk4-rs"
          }
        ]
      }
    },
    {
      "id": "QbdGnUoTLgMHO1NCQINIi",
      "name": "relm",
      "resources": {
        "description": "# Relm\n\n`relm` is a declarative, event-driven GUI framework for Rust built on `gtk-rs` and GTK+3. Uses Model-View-Update architecture with async Futures for complex UI interactions. Features widget identification by name, seamless inter-widget communication, and leverages Rust's safe concurrency for dynamic desktop applications.",
        "resources": [
          {
            "type": "course",
            "title": "Relm",
            "url": "https://relm4.org/"
          },
          {
            "type": "course",
            "title": "Relm Documentation",
            "url": "https://relm4.org/book/stable/"
          },
          {
            "type": "article",
            "title": "Relm, a GUI library, based on GTK+ and futures, written in Rust",
            "url": "https://relm.antoyo.xyz/relm-intro/"
          }
        ]
      }
    },
    {
      "id": "RKXljexmLAceMYwg4D_uP",
      "name": "Embedded and Systems",
      "resources": {
        "description": "# Embedded and Systems\n\nRust excels in embedded systems programming for microcontrollers and real-time applications. Its zero-cost abstractions, memory safety, and low-level control make it ideal for resource-constrained environments. Popular for IoT devices, firmware, and system-level programming without garbage collection overhead.",
        "resources": [
          {
            "type": "course",
            "title": "Embedded Devices",
            "url": "https://www.rust-lang.org/what/embedded"
          },
          {
            "type": "article",
            "title": "Rust for Embedded Systems",
            "url": "https://medium.com/@enravishjeni411/rust-for-embedded-systems-a-beginner-friendly-guide-e8c171cfb359"
          },
          {
            "type": "article",
            "title": "Rust Embedded Systems: Beginner's Guide with Example",
            "url": "https://boxoflearn.com/rust-embedded-systems-guide/"
          }
        ]
      }
    },
    {
      "id": "LzaO2cpDajXERqEYDjMl_",
      "name": "embedded-hal",
      "resources": {
        "description": "# embedded-hal\n\n`embedded-hal` (Hardware Abstraction Layer) provides generic traits for creating portable embedded drivers in Rust. Enables hardware-agnostic code by abstracting digital I/O, UART, I2C, SPI, and other communication protocols into a uniform API, promoting code reuse across different hardware platforms.",
        "resources": [
          {
            "type": "course",
            "title": "HALs - The Embedded Rust Book",
            "url": "https://doc.rust-lang.org/stable/embedded-book/design-patterns/hal/index.html"
          },
          {
            "type": "tutorial",
            "title": "A Hardware Abstraction Layer (HAL) for Embedded Systems",
            "url": "https://github.com/rust-embedded/embedded-hal"
          }
        ]
      }
    },
    {
      "id": "L01rVq2_H4rWzlKygW5kA",
      "name": "rppal",
      "resources": {
        "description": "# rppal\n\n`RPPAL` (Raspberry Pi Peripheral Access Library) provides Rust access to Raspberry Pi GPIO, I2C, PWM, SPI, and UART peripherals. Features comprehensive interrupt handling, software-based PWM, and I2C/SPI buses. Supports all Raspberry Pi models running Raspbian/Debian Stretch or newer.",
        "resources": [
          {
            "type": "course",
            "title": "RPPAL Documentation",
            "url": "https://docs.golemparts.com/rppal/0.11.1/rppal/"
          },
          {
            "type": "tutorial",
            "title": "golemparts/rppal",
            "url": "https://github.com/golemparts/rppal"
          },
          {
            "type": "article",
            "title": "RPPAL â€” Embedded dev in Rust",
            "url": "https://lib.rs/crates/rppal"
          }
        ]
      }
    },
    {
      "id": "ETYrk0s5Wn80XyntNG_t1",
      "name": "nrf-hal",
      "resources": {
        "description": "# nrf-hal\n\n`nrf-hal` is a Rust Peripheral Access Crate for Nordic Semiconductor nRF52 and nRF91 series chips. Provides high-level, semantic interfaces for GPIO, timers, RNG, RTC, I2C/SPI, temperature sensors, and delay routines. Open-source Apache licensed library abstracting direct register access.",
        "resources": [
          {
            "type": "course",
            "title": "nRF-HAL â€” embedded dev in Rust",
            "url": "https://lib.rs/crates/nrf-hal"
          },
          {
            "type": "tutorial",
            "title": "nrf-rs/nrf-hal",
            "url": "https://github.com/nrf-rs/nrf-hal"
          },
          {
            "type": "article",
            "title": "What the HAL? The Quest for Finding a Suitable Embedded Rust HAL",
            "url": "https://dev.to/theembeddedrustacean/what-the-hal-the-quest-for-finding-a-suitable-embedded-rust-hal-2i02"
          }
        ]
      }
    },
    {
      "id": "fusu4ZHH4-cjoouLr4F9U",
      "name": "WebAssembly (WASM)",
      "resources": {
        "description": "# WebAssembly (WASM)\n\nWebAssembly is a binary instruction format that runs at near-native speed in web browsers and other environments. Rust compiles excellently to WASM with tools like `wasm-pack` and `wasm-bindgen`, enabling high-performance web applications and cross-platform deployment.",
        "resources": [
          {
            "type": "course",
            "title": "Embedding WebAssembly in your Rust Application",
            "url": "https://blog.wasmer.io/executing-webassembly-in-your-rust-application-d5cd32e8ce46"
          },
          {
            "type": "article",
            "title": "Writing & Compiling WASM in Rust",
            "url": "https://www.shuttle.dev/blog/2024/03/06/writing-wasm-rust"
          },
          {
            "type": "article",
            "title": "Compiling from Rust to WebAssembly",
            "url": "https://developer.mozilla.org/en-US/docs/WebAssembly/Guides/Rust_to_Wasm"
          },
          {
            "type": "course",
            "title": "wasm-pack",
            "url": "https://lib.rs/crates/wasm-pack"
          },
          {
            "type": "course",
            "title": "wasm-bindgen",
            "url": "https://docs.rs/wasm-bindgen/latest/wasm_bindgen/"
          }
        ]
      }
    },
    {
      "id": "SUtBBqqDeR_yAkr669ZvE",
      "name": "wasm-bindgen",
      "resources": {
        "description": "# wasm-bindgen\n\n`wasm-bindgen` facilitates high-level interactions between Rust and JavaScript in WebAssembly. It generates bindings allowing seamless communication, JavaScript API calls from Rust, and vice versa. Handles memory representations and call semantics for complex data types like strings and objects.",
        "resources": [
          {
            "type": "course",
            "title": "wasm-bindgen",
            "url": "https://docs.rs/wasm-bindgen/latest/wasm_bindgen/"
          },
          {
            "type": "tutorial",
            "title": "rustwasm/wasm-bindgen",
            "url": "https://github.com/rustwasm/wasm-bindgen"
          },
          {
            "type": "article",
            "title": "Compiling from Rust to WebAssembly",
            "url": "https://developer.mozilla.org/en-US/docs/WebAssembly/Guides/Rust_to_Wasm"
          }
        ]
      }
    },
    {
      "id": "TSlj7mMUB5CDTy8uMFzKV",
      "name": "wasm-pack",
      "resources": {
        "description": "# wasm-pack\n\n`wasm-pack` is a command-line tool for assembling and packaging Rust crates targeting WebAssembly. It bridges Rust/WASM and JavaScript, generating necessary files for npm publishing. Ensures proper Rust-to-WASM compilation setup with focus on ergonomics, performance, and correctness.",
        "resources": [
          {
            "type": "course",
            "title": "wasm-pack",
            "url": "https://lib.rs/crates/wasm-pack"
          },
          {
            "type": "article",
            "title": "Writing & Compiling WASM in Rust",
            "url": "https://www.shuttle.dev/blog/2024/03/06/writing-wasm-rust"
          },
          {
            "type": "tutorial",
            "title": "rustwasm/wasm-pack",
            "url": "https://github.com/rustwasm/wasm-pack"
          },
          {
            "type": "article",
            "title": "Compiling from Rust to WebAssembly",
            "url": "https://developer.mozilla.org/en-US/docs/WebAssembly/Guides/Rust_to_Wasm"
          }
        ]
      }
    },
    {
      "id": "iyFHvZj_ntr_dX6WlL4E1",
      "name": "wasmer",
      "resources": {
        "description": "# Wasmer\n\nWasmer is a standalone WebAssembly runtime designed to run WASM files on any platform quickly and efficiently. Features a pluggable system with different compiling strategies, friendly CLI, and embedding APIs for calling WASM functions directly from various programming languages. Lightweight and modular.",
        "resources": [
          {
            "type": "course",
            "title": "Embedding WebAssembly in your Rust Application",
            "url": "https://blog.wasmer.io/executing-webassembly-in-your-rust-application-d5cd32e8ce46"
          },
          {
            "type": "article",
            "title": "Wasmer â€” WebAssembly in Rust",
            "url": "https://lib.rs/crates/wasmer"
          },
          {
            "type": "article",
            "title": "Writing & Compiling WASM in Rust",
            "url": "https://www.shuttle.dev/blog/2024/03/06/writing-wasm-rust"
          },
          {
            "type": "tutorial",
            "title": "wasmerio/wasmer",
            "url": "https://github.com/wasmerio/wasmer"
          },
          {
            "type": "article",
            "title": "Compiling from Rust to WebAssembly",
            "url": "https://developer.mozilla.org/en-US/docs/WebAssembly/Guides/Rust_to_Wasm"
          }
        ]
      }
    },
    {
      "id": "7YKWYxogJq6X35IAUwcZF",
      "name": "Debugging",
      "resources": {
        "description": "# Debugging\n\nRust provides excellent debugging support through `rust-gdb` and `rust-lldb` debuggers, along with built-in macros like `println!`, `dbg!`, and `debug!`. The strict compiler catches many bugs at compile-time, while runtime debugging is enhanced by panic backtraces and comprehensive error messages.",
        "resources": [
          {
            "type": "article",
            "title": "Debugging Rust apps with GDB",
            "url": "https://blog.logrocket.com/debugging-rust-apps-with-gdb/"
          },
          {
            "type": "article",
            "title": "Rust Debugging: Easy Guide with Practical Examples",
            "url": "https://boxoflearn.com/rust-debugging-guide/"
          },
          {
            "type": "article",
            "title": "Testing and Debugging in Rust",
            "url": "https://rustmeup.com/testing-and-debugging-in-rust"
          },
          {
            "type": "article",
            "title": "Mastering Rust Debugging: Tips & Tools",
            "url": "https://medium.com/@AlexanderObregon/rust-debugging-strategies-tools-and-best-practices-b18b92e0a921"
          }
        ]
      }
    },
    {
      "id": "UkHXsAolmbk-MsJFfqObC",
      "name": "rust-gdb",
      "resources": {
        "description": "# rust-gdb\n\n`rust-gdb` is GDB (GNU Project debugger) enhanced for Rust debugging. It provides low-level debugging capabilities including breakpoints, execution tracing, runtime modification, and memory inspection. Designed for command-line debugging with deep system integration for comprehensive Rust application analysis.",
        "resources": [
          {
            "type": "course",
            "title": "Use rust-gdb and rust-lldb for Improved Debugging",
            "url": "https://users.rust-lang.org/t/use-rust-gdb-and-rust-lldb-for-improved-debugging-you-already-have-them/756"
          },
          {
            "type": "article",
            "title": "Debugging Rust apps with GDB",
            "url": "https://blog.logrocket.com/debugging-rust-apps-with-gdb/"
          }
        ]
      }
    },
    {
      "id": "p1w1iljGABgHoJjIRJYLY",
      "name": "rust-lldb",
      "resources": {
        "description": "# rust-lldb\n\n`rust-lldb` is LLDB debugger enhanced with Rust-specific modifications for understanding Rust data structures and concepts. It includes pretty-printers for standard library types and comes bundled with the Rust compiler, providing better debugging experience for Rust applications.",
        "resources": [
          {
            "type": "course",
            "title": "Using rust-lldb for Improved Debugging",
            "url": "https://users.rust-lang.org/t/use-rust-gdb-and-rust-lldb-for-improved-debugging-you-already-have-them/756"
          },
          {
            "type": "article",
            "title": "Debugging Rust apps with GDB",
            "url": "https://blog.logrocket.com/debugging-rust-apps-with-gdb/"
          },
          {
            "type": "article",
            "title": "Debugging Rust with rust-lldb",
            "url": "https://dev.to/bmatcuk/debugging-rust-with-rust-lldb-j1f"
          }
        ]
      }
    },
    {
      "id": "65nbahPj9qAb9y8dF8Jnd",
      "name": "Documenting with `rustdoc`",
      "resources": {
        "description": "# Documenting with rustdoc\n\nRustDoc is an invaluable tool within the Rust ecosystem for generating comprehensive and user-friendly documentation directly from your source code. By leveraging special documentation comments (starting with `///` for regular comments and `//!` for crate-level comments), developers can embed Markdown-formatted text, code examples, and even doctests directly alongside their functions, modules, and types. RustDoc then processes these comments to produce static HTML pages, making it easy for others (and your future self) to understand how to use your libraries and applications. This integrated approach not only promotes good documentation habits but also ensures that the documentation remains in sync with the codebase.",
        "resources": [
          {
            "type": "course",
            "title": "How to Write Documentation",
            "url": "https://doc.rust-lang.org/rustdoc/how-to-write-documentation.html"
          },
          {
            "type": "article",
            "title": "Writing Rust Documentation",
            "url": "https://dev.to/gritmax/writing-rust-documentation-5hn5"
          }
        ]
      }
    },
    {
      "id": "WduD9VIcYSs_JTnuMNyxk",
      "name": "Performance and Profiling",
      "resources": {
        "description": "# Performance and Profiling\n\nPerformance profiling in Rust identifies bottlenecks using tools like `perf`, `cargo bench`, `criterion`, and `flamegraph`. These tools collect statistical data about runtime performance, helping developers optimize code efficiently by targeting actual problem areas rather than guessing.",
        "resources": [
          {
            "type": "article",
            "title": "Profiling - The Rust Performance Book",
            "url": "https://nnethercote.github.io/perf-book/profiling.html"
          },
          {
            "type": "article",
            "title": "How to benchmark Rust code with Criterion",
            "url": "https://bencher.dev/learn/benchmarking/rust/criterion/"
          },
          {
            "type": "article",
            "title": "Optimizing Rust Application Performance with Profiling",
            "url": "https://hemaks.org/posts/optimizing-rust-application-performance-with-profiling/"
          }
        ]
      }
    },
    {
      "id": "clQ26LFV_9AdQ4evnaxUK",
      "name": "Criterion.rs",
      "resources": {
        "description": "# Criterion.rs\n\n`Criterion.rs` is a statistics-driven microbenchmarking library for Rust that provides reliable performance analysis over time. It offers detailed feedback, automatic outlier detection, and statistical methods to compare algorithm performance and track regressions with actionable insights.\n\nLearn more from the following links:\n\n- [@official@Criterion](https://docs.rs/criterion/latest/criterion/)\n- [@article@Rust Benchmarking with Criterion.rs](https://www.rustfinity.com/blog/rust-benchmarking-with-criterion)\n- [@article@Benchmarking Rust Functions Using Criterion](https://www.slingacademy.com/article/benchmarking-rust-functions-using-criterion/)",
        "resources": [
          {
            "type": "course",
            "title": "Criterion",
            "url": "https://docs.rs/criterion/latest/criterion/"
          },
          {
            "type": "article",
            "title": "Rust Benchmarking with Criterion.rs",
            "url": "https://www.rustfinity.com/blog/rust-benchmarking-with-criterion"
          },
          {
            "type": "article",
            "title": "Benchmarking Rust Functions Using Criterion",
            "url": "https://www.slingacademy.com/article/benchmarking-rust-functions-using-criterion/"
          }
        ]
      }
    }
  ],
  "edges": [
    {
      "source": "HU7wZWiES3m3xl1-NYP6F",
      "target": "4U-HZQGH7kaWCB94Xy8Mh"
    },
    {
      "source": "4U-HZQGH7kaWCB94Xy8Mh",
      "target": "6E4pGifNfSAq6SbzfzFNT"
    },
    {
      "source": "6E4pGifNfSAq6SbzfzFNT",
      "target": "X2gB0m-ZKSC4TJyIcwsMx"
    },
    {
      "source": "X2gB0m-ZKSC4TJyIcwsMx",
      "target": "pTC1ucmErVnMbNFnYLJK7"
    },
    {
      "source": "X2gB0m-ZKSC4TJyIcwsMx",
      "target": "LwqOxYY9E9MUDgz2M40uV"
    },
    {
      "source": "X2gB0m-ZKSC4TJyIcwsMx",
      "target": "wQHkBydWsiGEOZMdKmz40"
    },
    {
      "source": "X2gB0m-ZKSC4TJyIcwsMx",
      "target": "Zpowr_NGd-E2DC3g-oW9h"
    },
    {
      "source": "Zpowr_NGd-E2DC3g-oW9h",
      "target": "PkePVzV-b1pgFJP5xID5_"
    },
    {
      "source": "Zpowr_NGd-E2DC3g-oW9h",
      "target": "c_SdccEXEJyh4ymWzvCeX"
    },
    {
      "source": "Zpowr_NGd-E2DC3g-oW9h",
      "target": "Op0-bdMV3kE9Be6Ot1aC6"
    },
    {
      "source": "08qKtgnhJ3tlb5JKfTDf5",
      "target": "pehYc_xLrs6BFUbcpPTiJ"
    },
    {
      "source": "pehYc_xLrs6BFUbcpPTiJ",
      "target": "zLKbYX0nnbfD5n3P_JRaS"
    },
    {
      "source": "zLKbYX0nnbfD5n3P_JRaS",
      "target": "pRDgDtRIVpNM2CdhSOS3Q"
    },
    {
      "source": "zLKbYX0nnbfD5n3P_JRaS",
      "target": "_EicstELZcdesHiXFWJGu"
    },
    {
      "source": "zLKbYX0nnbfD5n3P_JRaS",
      "target": "_hxwo_iAdOwlWBltv7i6i"
    },
    {
      "source": "eTpZXd8E2jVBmk_aSLZYV",
      "target": "Kb7KF7JCMaWFz-GuaQmQV"
    },
    {
      "source": "eTpZXd8E2jVBmk_aSLZYV",
      "target": "KomYBYxj0FTrJDYB3nU5B"
    },
    {
      "source": "KomYBYxj0FTrJDYB3nU5B",
      "target": "n5t3MUqmvrcr36VIIOw0u"
    },
    {
      "source": "KomYBYxj0FTrJDYB3nU5B",
      "target": "duQ1RO1lqq793mfb5w31P"
    },
    {
      "source": "KomYBYxj0FTrJDYB3nU5B",
      "target": "ApjwY_70OGG_dNIC85oBD"
    },
    {
      "source": "KomYBYxj0FTrJDYB3nU5B",
      "target": "yu0f5gALho0e8wzV10yow"
    },
    {
      "source": "yu0f5gALho0e8wzV10yow",
      "target": "3pL0ARqk8uRNimopHSalW"
    },
    {
      "source": "3pL0ARqk8uRNimopHSalW",
      "target": "gcmKSLWfBqx4aPZOmyQsg"
    },
    {
      "source": "gcmKSLWfBqx4aPZOmyQsg",
      "target": "_n7emeqzf5UTxVB5-385G"
    },
    {
      "source": "_n7emeqzf5UTxVB5-385G",
      "target": "Rv_Z-rbtELPZ1Nv0PZQmV"
    },
    {
      "source": "Rv_Z-rbtELPZ1Nv0PZQmV",
      "target": "2Zyyf9q_CxmOW-z2pipL8"
    },
    {
      "source": "2Zyyf9q_CxmOW-z2pipL8",
      "target": "uG-EmZVZ-jc3mswOT4-7l"
    },
    {
      "source": "uG-EmZVZ-jc3mswOT4-7l",
      "target": "T1LlJz5m5wnwBvKAEuGnP"
    },
    {
      "source": "T1LlJz5m5wnwBvKAEuGnP",
      "target": "RKXljexmLAceMYwg4D_uP"
    },
    {
      "source": "RKXljexmLAceMYwg4D_uP",
      "target": "fusu4ZHH4-cjoouLr4F9U"
    },
    {
      "source": "fusu4ZHH4-cjoouLr4F9U",
      "target": "iyFHvZj_ntr_dX6WlL4E1"
    },
    {
      "source": "fusu4ZHH4-cjoouLr4F9U",
      "target": "TSlj7mMUB5CDTy8uMFzKV"
    },
    {
      "source": "fusu4ZHH4-cjoouLr4F9U",
      "target": "SUtBBqqDeR_yAkr669ZvE"
    },
    {
      "source": "fusu4ZHH4-cjoouLr4F9U",
      "target": "7YKWYxogJq6X35IAUwcZF"
    },
    {
      "source": "7YKWYxogJq6X35IAUwcZF",
      "target": "65nbahPj9qAb9y8dF8Jnd"
    },
    {
      "source": "65nbahPj9qAb9y8dF8Jnd",
      "target": "WduD9VIcYSs_JTnuMNyxk"
    },
    {
      "source": "WduD9VIcYSs_JTnuMNyxk",
      "target": "clQ26LFV_9AdQ4evnaxUK"
    },
    {
      "source": "65nbahPj9qAb9y8dF8Jnd",
      "target": "0vLaVNJaJSHZ_bHli6Qzs"
    }
  ]
}