{
  "nodes": [
    {
      "id": "KDd40JOAvZ8O1mfhTYB3K",
      "name": "Introduction to Angular",
      "resources": {
        "description": "# Introduction to Angular\n\nAngular is a popular open-source front-end web application framework developed by Google. It is written in TypeScript and allows developers to build dynamic, single-page web applications with ease. Angular provides a comprehensive set of features for creating interactive and responsive user interfaces, making it a powerful tool for modern web development.",
        "resources": [
          {
            "type": "course",
            "title": "Angular",
            "url": "https://angular.dev/"
          },
          {
            "type": "course",
            "title": "Angular Documentation",
            "url": "https://angular.dev/overview"
          },
          {
            "type": "course",
            "title": "Angular Playground",
            "url": "https://angular.dev/playground"
          },
          {
            "type": "course",
            "title": "Angular API Reference",
            "url": "https://angular.dev/api"
          }
        ]
      }
    },
    {
      "id": "DE3cMpeRYuUPw2ADtfS-3",
      "name": "Angular Architecture",
      "resources": {
        "description": "# Angular Architecture\n\nAngular follows a modular architecture pattern, dividing the application into distinct modules, components, services, and other elements, which enhances code organization and maintainability. The key building blocks include modules, which are containers grouping related components, services, directives, and other elements to ensure proper encapsulation and reusability. Components are the building blocks of Angular applications, representing parts of the user interface with associated logic, consisting of templates, styles, and a class defining behavior. Services encapsulate reusable business logic, data manipulation, and API communication, enabling data and functionality sharing across components.",
        "resources": [
          {
            "type": "course",
            "title": "Angular Coding Style Guide",
            "url": "https://angular.dev/style-guide"
          },
          {
            "type": "article",
            "title": "The Ultimate Guide to Angular Architecture",
            "url": "https://angulardive.com/blog/the-ultimate-guide-to-angular-architecture-best-practices-for-efficient-coding-with-angular-framework/"
          },
          {
            "type": "article",
            "title": "Modern Architectures with Angular Part 1: Strategic design with Sheriff and Standalone Components",
            "url": "https://www.angulararchitects.io/en/blog/modern-architectures-with-angular-part-1-strategic-design-with-sheriff-and-standalone-components/"
          },
          {
            "type": "article",
            "title": "Optimizing the architecture of large web applications with Angular",
            "url": "https://albertobasalo.medium.com/optimizing-the-architecture-of-large-web-applications-with-angular-79d03b01a92b"
          },
          {
            "type": "article",
            "title": "Angular Architecture Concepts and Patterns",
            "url": "https://www.bigscal.com/blogs/frontend/angular-architecture-concepts-and-patterns/"
          },
          {
            "type": "article",
            "title": "Top 10 Angular Architecture Mistakes",
            "url": "https://angularexperts.io/blog/top-10-angular-architecture-mistakes"
          }
        ]
      }
    },
    {
      "id": "EbFRcy4s6yzzIApBqU77Y",
      "name": "Setting up a New Project",
      "resources": {
        "description": "# Setting up a New Project\n\nSetting up a new Angular project is streamlined by the **Angular CLI**, a command-line interface that automates the initial setup. First, ensure Node.js and npm are installed, then globally install the CLI itself via `npm install -g @angular/cli`. With the CLI in place, navigate to your desired directory and initiate a new project using `ng new your-project-name`, where you'll be prompted to configure options like routing and stylesheet format, with the `--standalone` flag being a common addition for modern projects. Once the project is scaffolded and dependencies are installed, change into your new project directory (`cd your-project-name`) and launch the development server with `ng serve`, making your new Angular application accessible in your browser, typically at `http://localhost:4200/`.",
        "resources": [
          {
            "type": "course",
            "title": "Installation",
            "url": "https://angular.dev/installation"
          },
          {
            "type": "course",
            "title": "Setting up the local environment and workspace",
            "url": "https://angular.dev/tools/cli/setup-local"
          },
          {
            "type": "course",
            "title": "Build your first Angular app",
            "url": "https://angular.dev/tutorials/first-app"
          }
        ]
      }
    },
    {
      "id": "hpShWwL0M57ZAzqkB4I8t",
      "name": "Angular and History",
      "resources": {
        "description": "# Angular and History\n\nAngular is a TypeScript-based open-source front-end web framework developed and maintained by Google. It is used for building dynamic, single-page web applications (SPAs). Angular provides comprehensive tools, including dependency injection, data binding, routing, and testing, to create robust and scalable web applications.",
        "resources": [
          {
            "type": "course",
            "title": "What is Angular?",
            "url": "https://angular.dev/overview"
          },
          {
            "type": "course",
            "title": "Understanding Angular",
            "url": "https://angular.io/guide/understanding-angular-overview"
          },
          {
            "type": "article",
            "title": "Getting Started with Angular",
            "url": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Frameworks_libraries/Angular_getting_started"
          }
        ]
      }
    },
    {
      "id": "kGnKzCkQCNFEdgCBRtNuW",
      "name": "Components",
      "resources": {
        "description": "# Angular Components\n\nComponents are the main building block for Angular applications. Each component consists of:\n\n- An HTML template that declares what renders on the page\n- A TypeScript class that defines the behavior\n- A CSS selector that defines how the component is used in a template\n- Optionally, CSS styles applied to the template",
        "resources": [
          {
            "type": "course",
            "title": "Anatomy of a Component",
            "url": "https://angular.dev/guide/components"
          },
          {
            "type": "course",
            "title": "Composing with Components in Angular",
            "url": "https://angular.dev/essentials/components"
          },
          {
            "type": "video",
            "title": "Standalone Components in Angular",
            "url": "https://www.youtube.com/watch?v=x5PZwb4XurU"
          },
          {
            "type": "article",
            "title": "Explore top posts about Angular",
            "url": "https://app.daily.dev/tags/angular?ref=roadmapsh"
          }
        ]
      }
    },
    {
      "id": "Mp056kNnwsRWeEXuhGPy-",
      "name": "Component Anatomy",
      "resources": {
        "description": "# Component Anatomy\n\nAngular components are the foundational building blocks of Angular applications, designed to encapsulate both the UI and\nthe business logic.\n\nEvery component must have:\n\n- A TypeScript class with behaviors\n- An HTML template\n- A CSS selector",
        "resources": [
          {
            "type": "course",
            "title": "Anatomy of a Component",
            "url": "https://angular.dev/guide/components"
          },
          {
            "type": "course",
            "title": "Anatomy of a Component - Interactive Tutorial",
            "url": "https://angular.dev/tutorials/learn-angular/1-components-in-angular"
          }
        ]
      }
    },
    {
      "id": "dOMvz__EQjO-3p-Nzm-7P",
      "name": "Provider",
      "resources": {
        "description": "# Provider\n\nConfigure the injector of component with a token that maps to a provider of a dependency.",
        "resources": [
          {
            "type": "course",
            "title": "Configuring Dependency Providers",
            "url": "https://angular.dev/guide/di/dependency-injection-providers"
          },
          {
            "type": "course",
            "title": "Component API",
            "url": "https://angular.dev/api/core/Component#providers"
          }
        ]
      }
    },
    {
      "id": "uYHy2yhtTm6fQkKpYx3lU",
      "name": "changeDetection",
      "resources": {
        "description": "# changeDetection\n\nThe change-detection strategy to use for this component. When a component is instantiated, Angular creates a change detector, which is responsible for propagating the component's bindings. The strategy is one of:\n\n- `ChangeDetectionStrategy.OnPush` sets the strategy to CheckOnce (on demand).\n- `ChangeDetectionStrategy.Default` sets the strategy to CheckAlways.",
        "resources": [
          {
            "type": "course",
            "title": "Advanced Component Configuration",
            "url": "https://angular.dev/guide/components/advanced-configuration#changedetectionstrategy"
          },
          {
            "type": "course",
            "title": "Component - API",
            "url": "https://angular.dev/api/core/Component#changeDetection"
          }
        ]
      }
    },
    {
      "id": "-gUpm3OLUJl9iAyx6fmHN",
      "name": "Template",
      "resources": {
        "description": "# Template\n\n`template` metadata is a property defined within the `@Component` decorator that specifies the HTML template for the component. It allows you to define the structure and layout of the component's view.",
        "resources": [
          {
            "type": "course",
            "title": "Template Syntax",
            "url": "https://angular.dev/guide/templates"
          },
          {
            "type": "course",
            "title": "Component Template API",
            "url": "https://angular.dev/api/core/Component#template"
          }
        ]
      }
    },
    {
      "id": "RcNHEh6kmbBK1PICbhAwr",
      "name": "Standalone",
      "resources": {
        "description": "# Standalone\n\nA standalone component is a component that sets `standalone: true` in its component metadata. Standalone components directly import other components, directives, and pipes used in their templates",
        "resources": [
          {
            "type": "course",
            "title": "Standalone Components",
            "url": "https://angular.dev/guide/components/importing#standalone-components"
          },
          {
            "type": "course",
            "title": "Component - API",
            "url": "https://angular.dev/api/core/Component#standalone"
          }
        ]
      }
    },
    {
      "id": "doHDoAgp7T59KGSXPpQzZ",
      "name": "viewProvider",
      "resources": {
        "description": "# viewProvider\n\nDefines the set of injectable objects that are visible to its view DOM children.",
        "resources": [
          {
            "type": "course",
            "title": "Using the viewProviders array",
            "url": "https://angular.dev/guide/di/hierarchical-dependency-injection#using-the-viewproviders-array"
          },
          {
            "type": "course",
            "title": "Component - API",
            "url": "https://angular.dev/api/core/Component#viewProviders"
          }
        ]
      }
    },
    {
      "id": "ctigvSYeFa77y3v7m11gk",
      "name": "Encapsulation",
      "resources": {
        "description": "# Encapsulation\n\nAn encapsulation policy for the component's styling. Possible values:\n\n- `ViewEncapsulation.Emulated`: Apply modified component styles in order to emulate a native Shadow DOM CSS\n  encapsulation behavior.\n- `ViewEncapsulation.None`: Apply component styles globally without any sort of encapsulation.\n- `ViewEncapsulation.ShadowDom`: Use the browser's native Shadow DOM API to encapsulate styles.\n\nIf not supplied, the value is taken from the CompilerOptions which defaults to `ViewEncapsulation.Emulated`.\n\nIf the policy is `ViewEncapsulation.Emulated` and the component has no styles nor {@link Component#styleUrls styleUrls},\nthe policy is automatically switched to `ViewEncapsulation.None`.",
        "resources": [
          {
            "type": "course",
            "title": "Style Scoping",
            "url": "https://angular.dev/guide/components/styling#style-scoping"
          },
          {
            "type": "course",
            "title": "Component Encapsulation",
            "url": "https://angular.dev/api/core/Component#encapsulation"
          }
        ]
      }
    },
    {
      "id": "cDN0PGo-zkcLmttxCiAI-",
      "name": "Selector",
      "resources": {
        "description": "# Selector\n\nIn Angular, the `selector` metadata is a crucial property defined within the `@Component` decorator that specifies how the component can be identified and used in HTML templates. It determines the way the component is rendered in the DOM, allowing developers to create reusable and easily identifiable components.",
        "resources": [
          {
            "type": "course",
            "title": "Component Selectors",
            "url": "https://angular.dev/guide/components/selectors"
          },
          {
            "type": "course",
            "title": "Component - API",
            "url": "https://angular.dev/api/core/Component#selector"
          }
        ]
      }
    },
    {
      "id": "4XJKEmSrQfPxggHlAP30w",
      "name": "Styles",
      "resources": {
        "description": "# Styles\n\nThis metadata allows developers to apply CSS styles directly to a component, enhancing its appearance and ensuring that styles are scoped to that particular component.",
        "resources": [
          {
            "type": "course",
            "title": "Styling Components",
            "url": "https://angular.dev/guide/components/styling"
          },
          {
            "type": "course",
            "title": "Component Style - API",
            "url": "https://angular.dev/api/core/Component#styles"
          }
        ]
      }
    },
    {
      "id": "ghbrJhuGvscnNGCtVLh5_",
      "name": "Imports",
      "resources": {
        "description": "# Imports\n\nThe `imports` property specifies the `standalone` component's template dependencies — those directives, components, and\npipes that can be used within its template.",
        "resources": [
          {
            "type": "course",
            "title": "Importing and Using Components",
            "url": "https://angular.dev/guide/components/importing"
          },
          {
            "type": "course",
            "title": "Component - API",
            "url": "https://angular.dev/api/core/Component#imports"
          }
        ]
      }
    },
    {
      "id": "Szgr8dnZNi-z5i6raIJzW",
      "name": "Metadata",
      "resources": {
        "description": "# Metadata\n\nMetadata in Angular components refers to the configuration information that is used to define and configure the behavior of a component. It is specified using decorators, which are functions that add metadata to classes, properties, and methods.",
        "resources": [
          {
            "type": "course",
            "title": "Component API",
            "url": "https://angular.dev/api/core/Component"
          }
        ]
      }
    },
    {
      "id": "19c7D-fWIJ3vYFT6h8ZfN",
      "name": "Communication",
      "resources": {
        "description": "# Communication\n\nAngular components can communicate with each other using `@Input()` and `@Output()` decorators. These decorators facilitate data exchange between parent and child components.\n\n- **@Input()**: This decorator allows a parent component to pass data to a child component, enabling the child to receive and use the data.\n- **@Output()**: This decorator allows a child component to emit events to a parent component, enabling the parent to respond to changes or actions within the child component.",
        "resources": [
          {
            "type": "course",
            "title": "Inputs",
            "url": "https://angular.dev/guide/components/inputs"
          },
          {
            "type": "course",
            "title": "Outputs",
            "url": "https://angular.dev/guide/components/outputs"
          },
          {
            "type": "course",
            "title": "Model Inputs",
            "url": "https://angular.dev/guide/signals/model"
          },
          {
            "type": "course",
            "title": "Custom events with outputs",
            "url": "https://angular.dev/guide/components/outputs"
          },
          {
            "type": "video",
            "title": "Non-Related Component Communication | Angular Component & Directives",
            "url": "https://www.youtube.com/watch?v=aIkGXMJFTzM"
          }
        ]
      }
    },
    {
      "id": "TDyFjKrIZJnCjEZsojPNQ",
      "name": "Parent-Child Interaction",
      "resources": {
        "description": "# Parent-Child Interaction\n\nIn angular parent-child communication is commonly used to share data between two components.",
        "resources": [
          {
            "type": "course",
            "title": "Component Interaction",
            "url": "https://angular.io/guide/component-interaction"
          },
          {
            "type": "article",
            "title": "Medium - Parent-Child Communication",
            "url": "https://jaspritk.medium.com/parent-child-communication-in-angular-888373e0b69e"
          }
        ]
      }
    },
    {
      "id": "v0XaLNZ-YrRqP-xv8wS43",
      "name": "ViewChild",
      "resources": {
        "description": "# ViewChild\n\nView queries retrieve results from the elements in the component's view — the elements defined in the  component's own template.",
        "resources": [
          {
            "type": "course",
            "title": "View queries",
            "url": "https://angular.dev/guide/components/queries#view-queries"
          },
          {
            "type": "course",
            "title": "viewChild - signal",
            "url": "https://angular.dev/guide/signals/queries#viewchild"
          },
          {
            "type": "course",
            "title": "viewChildren - signal",
            "url": "https://angular.dev/guide/signals/queries#viewchildren"
          },
          {
            "type": "course",
            "title": "viewChild - API",
            "url": "https://angular.dev/api/core/viewChild"
          }
        ]
      }
    },
    {
      "id": "oQl9etjoHiU2JgxieUOEH",
      "name": "ContentChild",
      "resources": {
        "description": "# ContentChild\n\nContent queries retrieve results from the elements in the component's content— the elements nested inside the component in the template where it's used.",
        "resources": [
          {
            "type": "course",
            "title": "Content Queries - Signal",
            "url": "https://angular.dev/guide/signals/queries#content-queries"
          },
          {
            "type": "course",
            "title": "Content Queries",
            "url": "https://angular.dev/guide/components/queries#content-queries"
          },
          {
            "type": "course",
            "title": "contentChild - API",
            "url": "https://angular.dev/api/core/contentChild"
          }
        ]
      }
    },
    {
      "id": "nCpfj_35ZvW-NTygg06XZ",
      "name": "Component Lifecycle",
      "resources": {
        "description": "# Lifecycle hooks\n\nA component instance has a lifecycle that starts when Angular instantiates the component class and renders the component view along with its child views. The lifecycle continues with change detection, as Angular checks to see when data-bound properties change, and updates both the view and the component instance as needed. The lifecycle ends when Angular destroys the component instance and removes its rendered template from the DOM. Directives have a similar lifecycle, as Angular creates, updates, and destroys instances in the course of execution.",
        "resources": [
          {
            "type": "course",
            "title": "Component Lifecycle",
            "url": "https://angular.dev/guide/components/lifecycle"
          },
          {
            "type": "article",
            "title": "The Life Cycle Hooks of Angular",
            "url": "https://blog.logrocket.com/angular-lifecycle-hooks/"
          },
          {
            "type": "article",
            "title": "Angular Lifecycle Hooks — Everything you need to know",
            "url": "https://medium.com/@sinanozturk/angular-component-lifecycle-hooks-2f600c48dff3"
          },
          {
            "type": "article",
            "title": "Explore top posts about Angular LifeCycle Hooks",
            "url": "https://dev.to/search?utf8=%E2%9C%93&q=angular+hook"
          }
        ]
      }
    },
    {
      "id": "tC5ETtOuuUcybj1jI4CuG",
      "name": "Dynamic Components",
      "resources": {
        "description": "# Dynamic Components\n\nIn addition to using a component directly in a template, you can also dynamically render components. There are two main ways to dynamically render a component: in a template with `NgComponentOutlet`, or in your TypeScript code with `ViewContainerRef`.",
        "resources": [
          {
            "type": "course",
            "title": "Programmatically Rendering Components",
            "url": "https://angular.dev/guide/components/programmatic-rendering"
          },
          {
            "type": "video",
            "title": "Dynamic Component in Angular (2024)",
            "url": "https://www.youtube.com/watch?v=ncbftt3NWVo"
          },
          {
            "type": "article",
            "title": "New Input Binding for NgComponentOutlet",
            "url": "https://medium.com/ngconf/new-input-binding-for-ngcomponentoutlet-cb18a86a739d"
          },
          {
            "type": "article",
            "title": "Render dynamic components in Angular using ViewContainerRef",
            "url": "https://dev.to/railsstudent/render-dynamic-components-in-angular-using-viewcontainerref-160h"
          },
          {
            "type": "video",
            "title": "Mastering ViewContainerRef for dynamic component loading in Angular17",
            "url": "https://www.youtube.com/watch?v=Ra4PITCt8m0"
          }
        ]
      }
    },
    {
      "id": "b_kdNS9PDupcUftslkf9i",
      "name": "Modules",
      "resources": {
        "description": "# Angular Modules\n\nModules in Angular act like a container where we can group the components, directives, pipes, and services, related to the application.",
        "resources": [
          {
            "type": "course",
            "title": "Importing and Using Components",
            "url": "https://angular.dev/guide/components/importing"
          },
          {
            "type": "course",
            "title": "Introduction to Modules",
            "url": "https://angular.dev/guide/ngmodules"
          },
          {
            "type": "article",
            "title": "Explore top posts about Angular",
            "url": "https://app.daily.dev/tags/angular?ref=roadmapsh"
          }
        ]
      }
    },
    {
      "id": "BCq5sgWQLiw0f7u7ZSAd2",
      "name": "Module Architecture",
      "resources": {
        "description": "# Module Architecture\n\nAngular's **module architecture** uses **NgModules** to organize applications into cohesive units. These modules group related components, directives, pipes, and services, promoting modular development. Key types include the **root module** (entry point), **feature modules** (specific functionality, often lazily loaded), and **shared modules** (reusable code). This approach significantly enhances code organization, scalability, and maintainability.\n\nVisit following resources to learn more:\n\n- [@article@Angular Architecture](https://dev.to/digitaldino/angular-architecture-39no)\n- [@article@Mastering Modular Architecture in Angular - Medium](https://medium.com/@sehban.alam/mastering-modular-architecture-in-angular-4cc2632fc964)",
        "resources": [
          {
            "type": "article",
            "title": "Angular Architecture",
            "url": "https://dev.to/digitaldino/angular-architecture-39no"
          },
          {
            "type": "article",
            "title": "Mastering Modular Architecture in Angular - Medium",
            "url": "https://medium.com/@sehban.alam/mastering-modular-architecture-in-angular-4cc2632fc964"
          }
        ]
      }
    },
    {
      "id": "ex8FOKrUlbu4MuEq2czyW",
      "name": "Creating Components",
      "resources": {
        "description": "# Creating Components\n\nYou can either use Angular CLI to create the Angular components or create it manually.",
        "resources": [
          {
            "type": "course",
            "title": "Build your first Angular App",
            "url": "https://angular.dev/tutorials/first-app"
          },
          {
            "type": "course",
            "title": "Components",
            "url": "https://angular.dev/essentials/components"
          },
          {
            "type": "course",
            "title": "Angular CLI - ng generate components",
            "url": "https://angular.dev/guide/components"
          }
        ]
      }
    },
    {
      "id": "9YhTXybJw2gszlqFeBtW3",
      "name": "Creating Modules",
      "resources": {
        "description": "# Creating Modules\n\nCreating modules in Angular helps organize your application into manageable, cohesive units. Each module can encapsulate related components, directives, pipes, and services. Here's a detailed guide on how to create and use modules in Angular.",
        "resources": [
          {
            "type": "course",
            "title": "Feature Modules",
            "url": "https://angular.dev/guide/ngmodules/feature-modules"
          }
        ]
      }
    },
    {
      "id": "w_BazXvINFyxDCHmlznfy",
      "name": "Feature Modules",
      "resources": {
        "description": "# Feature Modules\n\nFeature modules are `NgModules` for the purpose of organizing code. With feature modules, you can keep code related to a specific functionality or feature separate from other code. Delineating areas of your application helps with collaboration between developers and teams, separating directives, and managing the size of the root module.",
        "resources": [
          {
            "type": "course",
            "title": "Feature Modules",
            "url": "https://angular.dev/guide/ngmodules/feature-modules#how-to-make-a-feature-module"
          },
          {
            "type": "video",
            "title": "Creating a Feature Module | Understanding Angular Modules",
            "url": "https://www.youtube.com/watch?v=VaPhaexVa1U"
          },
          {
            "type": "article",
            "title": "Feature module with lazy loading in Angular 15",
            "url": "https://medium.com/@jaydeepvpatil225/feature-module-with-lazy-loading-in-angular-15-53bb8e15d193"
          }
        ]
      }
    },
    {
      "id": "bLERvEERmNI5AgxtEYokZ",
      "name": "Lazy Loading Modules",
      "resources": {
        "description": "# Lazy Loading Modules\n\nBy default, NgModules are eagerly loaded. This means that as soon as the application loads, so do all the NgModules, whether they are immediately necessary or not. For large applications with lots of routes, consider lazy loading —a design pattern that loads NgModules as needed. Lazy loading helps keep initial bundle sizes smaller, which in turn helps decrease load times.",
        "resources": [
          {
            "type": "course",
            "title": "Lazy Loading",
            "url": "https://angular.dev/guide/ngmodules/lazy-loading"
          },
          {
            "type": "article",
            "title": "Angular Lazy Loading",
            "url": "https://www.bairesdev.com/blog/angular-lazy-loading/"
          },
          {
            "type": "video",
            "title": "Lazy Loading in Angular: Improving Performance and User Experience",
            "url": "https://www.youtube.com/watch?v=mjhi27YfV8Y"
          }
        ]
      }
    },
    {
      "id": "5b590c7s-2XJ0rgdCYxLa",
      "name": "Dependencies",
      "resources": {
        "description": "# Dependencies\n\nA provider is an instruction to the Dependency Injection system on how to obtain a value for a dependency. Most of the time, these dependencies are services that you create and provide.",
        "resources": [
          {
            "type": "course",
            "title": "Providing Dependencies in Modules",
            "url": "https://angular.dev/guide/ngmodules/providers"
          },
          {
            "type": "article",
            "title": "Providers in Angular",
            "url": "https://www.scaler.com/topics/angular/providers-in-angular/"
          },
          {
            "type": "article",
            "title": "Working with providers in Angular",
            "url": "https://sergeygultyayev.medium.com/working-with-providers-in-angular-eeb493151446"
          }
        ]
      }
    },
    {
      "id": "6fhe9xAi_RSVfa-KKbcbV",
      "name": "Templates",
      "resources": {
        "description": "# Angular Templates\n\nA Template is a form of HTML which tells Angular to go towards another component. To create many Angular features, special syntax within the templates is used.",
        "resources": [
          {
            "type": "course",
            "title": "Template Syntax",
            "url": "https://angular.dev/guide/templates"
          },
          {
            "type": "article",
            "title": "Explore top posts about Angular",
            "url": "https://app.daily.dev/tags/angular?ref=roadmapsh"
          }
        ]
      }
    },
    {
      "id": "XHpfHRIlFh19FJIE07u7i",
      "name": "Interpolation",
      "resources": {
        "description": "# Interpolation\n\nInterpolation refers to embedding expressions into marked up text. By default, interpolation uses the double curly braces {{ and }} as delimiters. Angular replaces currentCustomer with the string value of the corresponding component property.",
        "resources": [
          {
            "type": "course",
            "title": "Interpolation",
            "url": "https://angular.dev/guide/templates/interpolation"
          },
          {
            "type": "course",
            "title": "Displaying values with interpolation",
            "url": "https://angular.dev/guide/templates/interpolation"
          }
        ]
      }
    },
    {
      "id": "t2YOeMONlcnKBrVAo0JDc",
      "name": "Template Statements",
      "resources": {
        "description": "# Template statements\n\nTemplate statements are methods or properties that you can use in your HTML to respond to user events. With template statements, your application can engage users through actions such as displaying dynamic content or submitting forms. Enclose the event in `()` which causes Angular to evaluate the right hand side of the assignment as one or more template statements chained together using semicolon `;`.",
        "resources": [
          {
            "type": "course",
            "title": "Template Statements",
            "url": "https://angular.dev/guide/templates/template-statements"
          },
          {
            "type": "course",
            "title": "Understanding Template Statements",
            "url": "https://angular.dev/guide/templates/template-statements#"
          }
        ]
      }
    },
    {
      "id": "WH5wlyOtrqFHBJx7RFJwS",
      "name": "Understand Binding",
      "resources": {
        "description": "# Binding data props attrs events\n\nIn an Angular template, a binding creates a live connection between view and the model and keeps them both in sync.\n\n- **property**: helps you set values for properties of HTML elements or directives.\n- **attributes**: helps you set values for attributes of HTML elements directly.\n- **event**: lets you listen for and respond to user actions such as keystrokes, mouse movements, clicks, and touches.\n- **data**: It's a combination of property and event binding and helps you share data between components.",
        "resources": [
          {
            "type": "course",
            "title": "Binding",
            "url": "https://angular.dev/guide/templates/binding"
          }
        ]
      }
    },
    {
      "id": "5vZkiH7HDwONIABLfNJ06",
      "name": "Data Binding",
      "resources": {
        "description": "# Data Binding\n\nIn an Angular template, a binding creates a live connection between a part of the UI created from a template (a DOM element, directive, or component) and the model (the component instance to which the template belongs). This connection can be used to synchronize the view with the model, to notify the model when an event or user action takes place in the view, or both. Angular's Change Detection algorithm is responsible for keeping the view and the model in sync. Bindings always have two parts: a target which will receive the bound value, and a template expression which produces a value from the model.",
        "resources": [
          {
            "type": "course",
            "title": "Understand Binding",
            "url": "https://angular.dev/guide/templates/binding"
          },
          {
            "type": "article",
            "title": "Data Binding in Angular",
            "url": "https://www.angularminds.com/blog/data-binding-in-angular"
          }
        ]
      }
    },
    {
      "id": "TJOZfHtsLfwA0CZ2bd1b2",
      "name": "Property Binding",
      "resources": {
        "description": "# Property binding\n\nProperty binding helps you set values for properties of HTML elements or directives. To bind to an element's property, enclose it in square brackets `[]` which causes Angular to evaluate the right-hand side of the assignment as a dynamic expression.",
        "resources": [
          {
            "type": "course",
            "title": "Property Binding",
            "url": "https://angular.dev/guide/templates/property-binding"
          }
        ]
      }
    },
    {
      "id": "FgsSyM6To7irpbivtOLEE",
      "name": "Attribute Binding",
      "resources": {
        "description": "# Attribute Binding\n\nAttribute binding in Angular helps you set values for attributes directly. With attribute binding, you can improve accessibility, style your application dynamically, and manage multiple CSS classes or styles simultaneously.",
        "resources": [
          {
            "type": "course",
            "title": "Attribute Binding",
            "url": "https://angular.dev/guide/templates/attribute-binding"
          },
          {
            "type": "article",
            "title": "What is difference between binding to attribute and binding to property in Angular?",
            "url": "https://stackoverflow.com/questions/76967327/what-is-difference-between-binding-to-attribute-and-binding-to-property-in-angul"
          }
        ]
      }
    },
    {
      "id": "bKnpirSvex4oE4lAjiSSV",
      "name": "Event Binding",
      "resources": {
        "description": "# Event Binding\n\nEvent binding lets you listen for and respond to user actions such as keystrokes, mouse movements, clicks, and touches.",
        "resources": [
          {
            "type": "course",
            "title": "Event Binding",
            "url": "https://angular.dev/guide/templates/event-binding"
          },
          {
            "type": "article",
            "title": "Event Handling in Angular",
            "url": "https://medium.com/@theriyasharma24/event-handling-in-angular-a5854a61b4a5"
          }
        ]
      }
    },
    {
      "id": "2UH79nCjgtY1Qz1YjUJYL",
      "name": "Two-way Binding",
      "resources": {
        "description": "# Two-way Binding\n\nTwo-way binding gives components in your application a way to share data. Use two-way binding to listen for events and update values simultaneously between parent and child components. Angular's two-way binding syntax is a combination of square brackets and parentheses, `[()]`, commonly known as `banana in a box`.",
        "resources": [
          {
            "type": "course",
            "title": "Two-way binding",
            "url": "https://angular.dev/guide/templates/two-way-binding"
          },
          {
            "type": "article",
            "title": "How to implement two-way data binding in Angular",
            "url": "https://www.angularminds.com/blog/how-to-implement-two-way-data-binding-in-angular"
          }
        ]
      }
    },
    {
      "id": "VzvB_bads057YtG4ST4a2",
      "name": "Control Flow",
      "resources": {
        "description": "# Control Flow\n\nAngular templates support control flow blocks that let you conditionally show, hide, and repeat elements.",
        "resources": [
          {
            "type": "course",
            "title": "Built-in Control Flow",
            "url": "https://angular.dev/guide/templates/control-flow"
          }
        ]
      }
    },
    {
      "id": "VsU6713jeIjAOEZnF6gWx",
      "name": "@Input & @Output",
      "resources": {
        "description": "# Input output\n\n`@Input()` and `@Output()` give a child component a way to communicate with its parent component. `@Input()` lets a parent component update data in the child component. Conversely, `@Output()` lets the child send data to a parent component.",
        "resources": [
          {
            "type": "course",
            "title": "inputs",
            "url": "https://angular.dev/guide/components/inputs"
          },
          {
            "type": "course",
            "title": "outputs",
            "url": "https://angular.dev/guide/components/outputs"
          }
        ]
      }
    },
    {
      "id": "nyDry6ZWyEUuTq4pw-lU3",
      "name": "Template Ref Vars",
      "resources": {
        "description": "# Reference vars\n\nTemplate reference variables help you use data from one part of a template in another part of the template. A template variable can refer to a DOM element within a template, component or directive. In the template, use the hash symbol, `#`, to declare a template reference variable.",
        "resources": [
          {
            "type": "course",
            "title": "Reference Variables",
            "url": "https://angular.dev/guide/templates/reference-variables"
          }
        ]
      }
    },
    {
      "id": "VsC7UmE_AumsBP8fC6to1",
      "name": "Template Syntax",
      "resources": {
        "description": "# Template Syntax\n\nIn Angular, a *template* is a chunk of HTML. Use special syntax within a template to build on many of Angular's features. Extend the HTML vocabulary of your applications with special Angular syntax in your templates. For example, Angular helps you get and set DOM (Document Object Model) values dynamically with features such as built-in template functions, variables, event listening, and data binding.",
        "resources": [
          {
            "type": "course",
            "title": "Template Syntax",
            "url": "https://angular.dev/guide/templates"
          },
          {
            "type": "article",
            "title": "An Introduction to Angular Template Syntax",
            "url": "https://angularstart.com/modules/basic-angular-concepts/3/"
          },
          {
            "type": "video",
            "title": "Craft Dynamic Templates with Angular's Template Syntax",
            "url": "https://www.youtube.com/watch?v=uSnUTcf8adI"
          }
        ]
      }
    },
    {
      "id": "U1Zy2T-2ki9pDkXn9hn-I",
      "name": "@if",
      "resources": {
        "description": "# @if\n\nThe @if block conditionally displays its content when its condition expression is truthy. Content is added and removed from the DOM based on the evaluation of conditional expressions in the @if and @else blocks.",
        "resources": [
          {
            "type": "course",
            "title": "\\@if",
            "url": "https://angular.dev/api/core/@if"
          },
          {
            "type": "video",
            "title": "Narrow Down signal value type within an if statement",
            "url": "https://egghead.io/lessons/angular-narrow-down-angular-s-signal-value-type-within-an-if-statement"
          }
        ]
      }
    },
    {
      "id": "ORdPDad4HWJAfcZuS-7yM",
      "name": "@else",
      "resources": {
        "description": "# @else\n\nWhile the `@if` block can be helpful in many situations, it's common to also show fallback UI when the condition is not met. When you need a fallback, similar to JavaScript's else clause, add an `@else` block to accomplish the same effect.",
        "resources": [
          {
            "type": "course",
            "title": "Angular Official Docs - @else block",
            "url": "https://angular.dev/guide/templates/control-flow#conditionally-display-content-with-if-else-if-and-else"
          },
          {
            "type": "article",
            "title": "Angular If Else Control Flow Blocks Explained",
            "url": "https://ultimatecourses.com/blog/angular-if-else-control-flow-blocks-explained"
          }
        ]
      }
    },
    {
      "id": "ys5untkSppGMFK-VsfuRt",
      "name": "@else if",
      "resources": {
        "description": "# @else if\n\nWith the new control flow syntax, you gain `@else if` conditional blocks, something that is not possible with `@ngIf`. This addition makes the control flow syntax close to what we would write with just plain JavaScript.",
        "resources": [
          {
            "type": "course",
            "title": "\\@if",
            "url": "https://angular.dev/api/core/@if"
          },
          {
            "type": "article",
            "title": "Angular @if: Complete Guide",
            "url": "https://blog.angular-university.io/angular-if/"
          }
        ]
      }
    },
    {
      "id": "2kYS9w1UzQFZ1zhf01m9L",
      "name": "@for",
      "resources": {
        "description": "# @for\n\nThe @for block repeatedly renders content of a block for each item in a collection.",
        "resources": [
          {
            "type": "course",
            "title": "\\@for",
            "url": "https://angular.dev/api/core/@for"
          }
        ]
      }
    },
    {
      "id": "nZuim4Fjq6jYOXcRTAEay",
      "name": "@switch",
      "resources": {
        "description": "# @switch\n\nThe `@switch` blocks displays content selected by one of the cases matching against the conditional expression. The value of the conditional expression is compared to the case expression using the `===` operator. `@switch` does not have fallthrough, so you do not need an equivalent to a break or return statement.",
        "resources": [
          {
            "type": "course",
            "title": "\\@switch",
            "url": "https://angular.dev/guide/templates/control-flow#switch-block---selection"
          },
          {
            "type": "article",
            "title": "Angular @switch: Complete Guide",
            "url": "https://blog.angular-university.io/angular-switch/"
          }
        ]
      }
    },
    {
      "id": "cHC2MH50CbUSMRZV4QGJI",
      "name": "@case",
      "resources": {
        "description": "# @case\n\nIf no `@case` matches the `@switch` condition and there is no `@default` block, nothing is shown.  Otherwise, the content inside the `@case` that matches the condition will be displayed.",
        "resources": [
          {
            "type": "course",
            "title": "\\@switch",
            "url": "https://angular.dev/guide/templates/control-flow#switch-block---selection"
          },
          {
            "type": "article",
            "title": "Angular @switch: Complete Guide",
            "url": "https://blog.angular-university.io/angular-switch/"
          }
        ]
      }
    },
    {
      "id": "h4MMn0_qUN3YXEdMUJOyd",
      "name": "@default",
      "resources": {
        "description": "# @default\n\nThe `@default` clause is used to render a template when none of the `@case` blocks matches the value of the `@switch` conditional. `@default` is optional and can be omitted.",
        "resources": [
          {
            "type": "course",
            "title": "\\@switch",
            "url": "https://angular.dev/api/core/@switch#description"
          },
          {
            "type": "article",
            "title": "Angular @switch: Complete Guide",
            "url": "https://blog.angular-university.io/angular-switch/"
          }
        ]
      }
    },
    {
      "id": "AwOM0ucg6W7TohdUd7KWT",
      "name": "@let",
      "resources": {
        "description": "# @let\n\n@let allows you to define a local variable and re-use it across the template.",
        "resources": [
          {
            "type": "course",
            "title": "\\@let",
            "url": "https://angular.dev/api/core/@let"
          },
          {
            "type": "article",
            "title": "Angular's next feature let syntax",
            "url": "https://nhannguyendevjs.medium.com/angulars-next-feature-let-syntax-afba6354112b"
          }
        ]
      }
    },
    {
      "id": "ONy-0olujU_FGZM7Wvfr2",
      "name": "@defer",
      "resources": {
        "description": "# @defer\n\nA type of block that can be used to defer load the JavaScript for components, directives and pipes used inside a component template.",
        "resources": [
          {
            "type": "course",
            "title": "\\@defer",
            "url": "https://angular.dev/api/core/@defer"
          },
          {
            "type": "article",
            "title": "Angular Defer Complete Guide",
            "url": "https://blog.angular-university.io/angular-defer/"
          },
          {
            "type": "article",
            "title": "How to use Angular's defer block to improve performance",
            "url": "https://angular.love/en/how-to-use-angulars-defer-block-to-improve-performance"
          }
        ]
      }
    },
    {
      "id": "j99WQxuTzGeBBVoReDp_y",
      "name": "Pipes",
      "resources": {
        "description": "# Builtin pipes\n\nUse pipes to transform strings, currency amounts, dates, and other data for display. Pipes are simple functions to use in template expressions to accept an input value and return a transformed value. Pipes are useful because you can use them throughout your application , some common pipes are `DatePipe` | `UpperCasePipe` | `LowerCasePipe` | `CurrencyPipe` | `DecimalPipe` | `PercentPipe`",
        "resources": [
          {
            "type": "course",
            "title": "Understanding Pipes",
            "url": "https://angular.dev/tutorials/learn-angular/22-pipes"
          },
          {
            "type": "article",
            "title": "BuiltIn Pipes - examples",
            "url": "https://codecraft.tv/courses/angular/pipes/built-in-pipes/"
          }
        ]
      }
    },
    {
      "id": "_-mTs_FMeob-ZGK-bb3j-",
      "name": "Change Detection",
      "resources": {
        "description": "# Change detection\n\nChange detection is the process through which Angular checks to see whether your application state has changed, and if any DOM needs to be updated. At a high level, Angular walks your components from top to bottom, looking for changes. Angular runs its change detection mechanism periodically so that changes to the data model are reflected in an application’s view. Change detection can be triggered either manually or through an asynchronous event",
        "resources": [
          {
            "type": "course",
            "title": "Runtime Performance Optimization",
            "url": "https://angular.dev/best-practices/runtime-performance"
          },
          {
            "type": "course",
            "title": "ChangeDetectionStrategy",
            "url": "https://angular.dev/guide/components/advanced-configuration#changedetectionstrategy"
          },
          {
            "type": "video",
            "title": "4 Runtime Performance Optimizations ( Change detection )",
            "url": "https://www.youtube.com/watch?v=f8sA-i6gkGQ"
          }
        ]
      }
    },
    {
      "id": "i2taHzQ5KLHjkkpbH4Ytd",
      "name": "Common Pipes",
      "resources": {
        "description": "# Common Pipes\n\nAngular provides built-in pipes for typical data transformations, including transformations for internationalization (i18n), which use locale information to format data. The following are commonly used built-in pipes for data formatting:\n\n- DatePipe: Formats a date value according to locale rules.\n- UpperCasePipe: Transforms text to all upper case.\n- LowerCasePipe: Transforms text to all lower case.\n- CurrencyPipe: Transforms a number to a currency string, formatted according to locale rules.\n- DecimalPipe: Transforms a number into a string with a decimal point, formatted according to locale rules.\n- PercentPipe: Transforms a number to a percentage string, formatted according to locale rules.\n- AsyncPipe: Subscribe and unsubscribe to an asynchronous source such as an observable.\n- JsonPipe: Display a component object property to the screen as JSON for debugging.",
        "resources": [
          {
            "type": "course",
            "title": "Pipes",
            "url": "https://angular.dev/guide/pipes"
          },
          {
            "type": "article",
            "title": "Pipes in Angular",
            "url": "https://medium.com/@aqeelabbas3972/pipes-in-angular-6a871589299d"
          }
        ]
      }
    },
    {
      "id": "nZxZnzbQg9dz-SI65UHq9",
      "name": "Pipes Precedence",
      "resources": {
        "description": "# Pipes Precedence\n\nThe pipe operator has a higher precedence than the JavaScript ternary operator.\n\nYou should always use parentheses to be sure Angular evaluates the expression as you intend.\n\n```\n(condition ? a : b) | pipe\n```",
        "resources": [
          {
            "type": "course",
            "title": "Precedence",
            "url": "https://angular.dev/guide/pipes/precedence"
          },
          {
            "type": "article",
            "title": "What is the precedence between pipe and ternary operators?",
            "url": "https://iq.js.org/questions/angular/what-is-the-precedence-between-pipe-and-ternary-operators"
          }
        ]
      }
    },
    {
      "id": "BOYXGfULJRiP-XOo_lNX3",
      "name": "Custom Pipes",
      "resources": {
        "description": "# Custom Pipes\n\nPipes to transform strings, currency amounts, dates, and other data for display. Pipes are simple functions in template expressions to accept an input value and return a transformed value. Pipes are helpful because you can use them throughout your application while only declaring each pipe once. For example, you would use a pipe to show the date as April 15, 1988, rather than the raw string format.",
        "resources": [
          {
            "type": "course",
            "title": "Custom Pipes for New Transforms",
            "url": "https://angular.dev/guide/pipes/transform-data"
          },
          {
            "type": "video",
            "title": "Create a custom pipe video for Beginners",
            "url": "https://www.youtube.com/watch?v=P2587FN4Y0w"
          }
        ]
      }
    },
    {
      "id": "kGzlumFdZFxTRZ3HnCGFO",
      "name": "Directives",
      "resources": {
        "description": "# Built-in directives\n\nSKDirectives are classes that add additional behavior to elements in your Angular applications. Use Angular's built-in directives to manage forms, lists, styles, and what users see.\n\n`NgClass` Adds and removes a set of CSS classes. | `NgStyle` Adds and removes a set of HTML styles. | `NgModel` Adds two-way data binding to an HTML form element.",
        "resources": [
          {
            "type": "course",
            "title": "Built-in directives",
            "url": "https://angular.dev/guide/directives/"
          },
          {
            "type": "article",
            "title": "BuiltIn Directives Types",
            "url": "https://thinkster.io/tutorials/angular-2-directives"
          }
        ]
      }
    },
    {
      "id": "xk3v8p6vf8ntGj5c-IU4U",
      "name": "Structural Directives",
      "resources": {
        "description": "# Structural Directives\n\nStructural directives are directives applied to an `<ng-template>` element that conditionally or repeatedly renders the content of that `<ng-template>`. If you just wrap elements in an `<ng-template>` without applying a structural directive, those elements will not be rendered.\n\nIn Angular, there are three standard structural directives:\n\n- `*ngIf` – conditionally includes a template depending on the value of an expression returned by a Boolean.\n- `*ngFor` – makes it simple to iterate over an array.\n- `*ngSwitch` – renders each matching view.",
        "resources": [
          {
            "type": "course",
            "title": "Structural Directives",
            "url": "https://angular.dev/guide/directives/structural-directives"
          },
          {
            "type": "article",
            "title": "Structural Directives in Angular",
            "url": "https://medium.com/@eugeniyoz/structural-directives-in-angular-61fe522f3427"
          },
          {
            "type": "article",
            "title": "Angular Structural Directive Patterns: What they are and how to use them",
            "url": "https://www.freecodecamp.org/news/angular-structural-directive-patterns-what-they-are-and-how-to-use-them/"
          }
        ]
      }
    },
    {
      "id": "xvwby0FTdIolRrV2j88fY",
      "name": "Attribute Directives",
      "resources": {
        "description": "# Attribute Directives\n\nChange the appearance or behavior of DOM elements and Angular components with attribute directives.\n\nThe most used attribute directives are:\n\n- ngClass\n- ngStyle\n- ngModel",
        "resources": [
          {
            "type": "course",
            "title": "Attribute Directives",
            "url": "https://angular.dev/guide/directives/attribute-directives"
          },
          {
            "type": "article",
            "title": "Angular Attribute Directive",
            "url": "https://www.scaler.com/topics/angular/angular-attribute-directive/"
          }
        ]
      }
    },
    {
      "id": "7GUvTMVzfdVEDBOz-tHUT",
      "name": "Custom Directives",
      "resources": {
        "description": "# Directive\n\nDirectives are the functions that will execute whenever the Angular compiler finds them. Angular Directives enhance the capability of HTML elements by attaching custom behaviors to the DOM.\n\nFrom the core concept, Angular directives are categorized into three categories: Attribute Directives, Structural Directives, and Component Directives.",
        "resources": [
          {
            "type": "course",
            "title": "Built-in directives",
            "url": "https://angular.dev/guide/directives#"
          },
          {
            "type": "video",
            "title": "Create a custom directive video for Beginners",
            "url": "https://www.youtube.com/watch?v=AoN56g6UAsE"
          }
        ]
      }
    },
    {
      "id": "a74v78SvGtWduZpXs7wSq",
      "name": "Routing",
      "resources": {
        "description": "# Routing\n\nRouting in Angular allows the users to create a single-page application with multiple views and allows navigation between them.",
        "resources": [
          {
            "type": "course",
            "title": "Angular Routing",
            "url": "https://angular.dev/guide/routing"
          },
          {
            "type": "course",
            "title": "Common Routing Tasks",
            "url": "https://angular.dev/guide/routing/common-router-tasks"
          }
        ]
      }
    },
    {
      "id": "dbAS-hN1hoCsNJhkxXcGq",
      "name": "Configuration",
      "resources": {
        "description": "# Configuration\n\nThe configuration of routes in an Angular application involves defining route mappings in an array and providing these routes to the Angular router.",
        "resources": [
          {
            "type": "course",
            "title": "Router Reference - Configuration",
            "url": "https://angular.dev/guide/routing/router-reference#configuration"
          },
          {
            "type": "course",
            "title": "Routing Overview",
            "url": "https://angular.dev/guide/routing"
          }
        ]
      }
    },
    {
      "id": "ewbDdPYv2SJl_jW3RVHQs",
      "name": "Lazy Loading",
      "resources": {
        "description": "# Lazy loading\n\nLazy loading is a technique in Angular that allows you to load JavaScript components asynchronously when a specific route is activated. It improves the application load time speed by splitting the application into several bundles. The bundles are loaded as required when the user navigates through the app.",
        "resources": [
          {
            "type": "course",
            "title": "Lazy-loading Feature Modules",
            "url": "https://angular.dev/guide/ngmodules/lazy-loading"
          },
          {
            "type": "video",
            "title": "Angular Tutorial - Lazy Loading",
            "url": "https://www.youtube.com/watch?v=JjIQq9lh-Bw"
          }
        ]
      }
    },
    {
      "id": "1ZwdEL0Gx30Vv_Av3ZTGG",
      "name": "Router Outlets",
      "resources": {
        "description": "# Router outlets\n\nThe router-outlet is a directive that's available from the @angular/router package and is used by the router to mark where in a template, a matched component should be inserted.\n\nThanks to the router outlet, your app will have multiple views/pages and the app template acts like a shell of your application. Any element, you add to the shell will be rendered in each view, only the part marked by the router outlet will be changed between views.",
        "resources": [
          {
            "type": "course",
            "title": "Router Reference - Router Outlet",
            "url": "https://angular.dev/guide/routing/router-reference#router-outlet"
          },
          {
            "type": "course",
            "title": "Router Outlet - API",
            "url": "https://angular.dev/api/router/RouterOutlet"
          }
        ]
      }
    },
    {
      "id": "8lFyuSx4MUcYRY2L8bZrq",
      "name": "Router Links",
      "resources": {
        "description": "# Router links\n\nIn Angular, routerLink when applied to an element in a template, makes that element a link that initiates navigation to a route. Navigation opens one or more routed components in one or more `<router-outlet>` locations on the page.",
        "resources": [
          {
            "type": "course",
            "title": "Router Reference - Router links",
            "url": "https://angular.dev/guide/routing/router-reference#router-links"
          },
          {
            "type": "course",
            "title": "Router Link - API",
            "url": "https://angular.dev/api/router/RouterLink"
          },
          {
            "type": "article",
            "title": "Angular Router: Navigation Using RouterLink, Navigate, or NavigateByUrl",
            "url": "https://www.digitalocean.com/community/tutorials/angular-navigation-routerlink-navigate-navigatebyurl"
          }
        ]
      }
    },
    {
      "id": "YF_sG292HqawIX0siWhrv",
      "name": "Router Events",
      "resources": {
        "description": "# Router Events\n\nThe Angular Router raises events when it navigates from one route to another route. It raises several events such as `NavigationStart`, `NavigationEnd`, `NavigationCancel`, `NavigationError`, `ResolveStart`, etc. You can listen to these events and find out when the state of the route changes. Some of the useful events are route change start (NavigationStart) and route change end (NavigationEnd).",
        "resources": [
          {
            "type": "course",
            "title": "Router Reference - Router events",
            "url": "https://angular.dev/guide/routing/router-reference#router-events"
          },
          {
            "type": "course",
            "title": "Router Event - API",
            "url": "https://angular.dev/api/router/RouterEvent"
          },
          {
            "type": "article",
            "title": "Router events in Angular",
            "url": "https://medium.com/@gurunadhpukkalla/router-events-in-angular-3112a3968660"
          }
        ]
      }
    },
    {
      "id": "PmC4zeaLpa5LoL4FhYXcG",
      "name": "Guards",
      "resources": {
        "description": "# Route Guards\n\nUse route guards to prevent users from navigating to parts of an application without authorization.\n\nAngular route guards are interfaces provided by Angular that, when implemented, allow us \nto control the accessibility of a route based on conditions provided in function implementation of that interface.\n\nSome types of angular guards are `CanActivate`, `CanActivateChild`, `CanDeactivate`, `CanMatch` and `Resolve`.",
        "resources": [
          {
            "type": "course",
            "title": "Preventing Unauthorized Access",
            "url": "https://angular.dev/guide/routing/common-router-tasks#preventing-unauthorized-access"
          },
          {
            "type": "course",
            "title": "Resolve",
            "url": "https://angular.dev/api/router/Resolve"
          }
        ]
      }
    },
    {
      "id": "CpsoIVoCKaZnM_-BbXbCh",
      "name": "Services  & Remote Data",
      "resources": {
        "description": "# Services\n\nServices let you define code or functionalities that are then accessible and reusable in many other components in the Angular project. It also helps you with the abstraction of logic and data that is hosted independently but can be shared across other components.",
        "resources": [
          {
            "type": "course",
            "title": "Creating an Injectable Service",
            "url": "https://angular.dev/guide/di/creating-injectable-service"
          },
          {
            "type": "article",
            "title": "Service for API Calls",
            "url": "https://www.knowledgehut.com/blog/web-development/make-api-calls-angular"
          }
        ]
      }
    },
    {
      "id": "8u9uHCRt9RU57erBy79PP",
      "name": "Dependency Injection",
      "resources": {
        "description": "# Dependency Injection\n\nDependency Injection is one of the fundamental concepts in Angular. DI is wired into the Angular framework and allows classes with Angular decorators, such as Components, Directives, Pipes, and Injectables, to configure dependencies that they need.",
        "resources": [
          {
            "type": "course",
            "title": "Understanding Dependency Injection",
            "url": "https://angular.dev/guide/di/dependency-injection"
          },
          {
            "type": "course",
            "title": "DI in Action",
            "url": "https://angular.dev/guide/di/di-in-action"
          },
          {
            "type": "article",
            "title": "Explore top posts about Dependency Injection",
            "url": "https://app.daily.dev/tags/dependency-injection?ref=roadmapsh"
          }
        ]
      }
    },
    {
      "id": "Q36LQds8k_cSjijvXyWOM",
      "name": "Forms",
      "resources": {
        "description": "# Forms\n\nForms are used to handle user inputs in many applications. It enables users from entering sensitive information to performing several data entry tasks.\n\nAngular provides two approaches to handle user inputs trough forms: reactive and template-driven forms.",
        "resources": [
          {
            "type": "course",
            "title": "Forms in Angular",
            "url": "https://angular.dev/guide/forms"
          },
          {
            "type": "video",
            "title": "Angular Forms Tutorial",
            "url": "https://www.youtube.com/watch?v=-bGgjgx3fGs"
          },
          {
            "type": "video",
            "title": "Building Forms in Angular Apps",
            "url": "https://www.youtube.com/watch?v=hAaoPOx_oIw"
          }
        ]
      }
    },
    {
      "id": "1d3Y4HVnqom8UOok-7EEf",
      "name": "Reactive Forms",
      "resources": {
        "description": "# Reactive Forms\n\nReactive Forms in angular are those which used to handle the inputs coming from the user. We can define controls by using classes such as FormGroup and FormControl.",
        "resources": [
          {
            "type": "course",
            "title": "Reactive Forms - Angular",
            "url": "https://angular.dev/guide/forms/reactive-forms"
          },
          {
            "type": "article",
            "title": "How To Use Reactive Forms in Angular",
            "url": "https://www.digitalocean.com/community/tutorials/angular-reactive-forms-introduction"
          },
          {
            "type": "video",
            "title": "Reactive Form in Angular",
            "url": "https://www.youtube.com/watch?v=8k4ctDmVn7w"
          },
          {
            "type": "article",
            "title": "Explore top posts about General Programming",
            "url": "https://app.daily.dev/tags/general-programming?ref=roadmapsh"
          }
        ]
      }
    },
    {
      "id": "XC_K1Wahl2ySqOXoym4YU",
      "name": "Typed Forms",
      "resources": {
        "description": "# Typed Forms\n\nSince Angular 14, reactive forms are strictly typed by default. You don't have to define extra custom types or add a ton of type annotations to your form declarations to benefit from this extra type safety, as Angular will infer types from the default value of a form control. Non-typed forms are still supported. To use them, you must import the `Untyped` symbols from `@angular/forms`.",
        "resources": [
          {
            "type": "course",
            "title": "Typed Forms",
            "url": "https://angular.dev/guide/forms/typed-forms"
          },
          {
            "type": "article",
            "title": "Angular Strictly Typed Forms (Complete Guide)",
            "url": "https://blog.angular-university.io/angular-typed-forms/"
          },
          {
            "type": "video",
            "title": "Getting started with Typed Reactive Forms in Angular",
            "url": "https://www.youtube.com/watch?v=mT3UR0TdDnU"
          },
          {
            "type": "video",
            "title": "Angular TYPED Forms: Are You Using Them Correctly?",
            "url": "https://www.youtube.com/watch?v=it2BZoIvBPc"
          },
          {
            "type": "video",
            "title": "Knowing this makes Angular typed forms WAY less awkward",
            "url": "https://www.youtube.com/watch?v=xpRlijg6spo"
          }
        ]
      }
    },
    {
      "id": "uDx4lPavwsJFBMzdQ70CS",
      "name": "Template-driven Forms",
      "resources": {
        "description": "# Template Driven Forms\n\nA Template driven form is the simplest form we can build in Angular. It is mainly used for creating simple form application.\n\nIt uses two-way data-binding (ngModel) to create and handle the form components.",
        "resources": [
          {
            "type": "course",
            "title": "Building a Template-driven Form",
            "url": "https://angular.dev/guide/forms/template-driven-forms"
          },
          {
            "type": "article",
            "title": "Template-Driven Forms",
            "url": "https://codecraft.tv/courses/angular/forms/template-driven/"
          },
          {
            "type": "video",
            "title": "Template driven form",
            "url": "https://www.youtube.com/watch?v=whr14XxB8-M"
          },
          {
            "type": "video",
            "title": "Template driven form Validations",
            "url": "https://www.youtube.com/watch?v=cVd4ZCIXprs"
          }
        ]
      }
    },
    {
      "id": "CpufN6DAOj5UNab9vnH0k",
      "name": "Dynamic Forms",
      "resources": {
        "description": "# Dynamic Forms\n\nDynamic forms in Angular are a flexible way to create forms where the structure (such as form fields and validation rules) is generated at runtime, rather than being hardcoded. By using Angular's `FormBuilder` and `FormGroup`, you can dynamically add, remove, or modify form controls based on user input, data fetched from a server, or other logic. This approach allows for creating complex forms that can adapt to different user scenarios, reducing the need for multiple form templates and making the codebase more maintainable and scalable.",
        "resources": [
          {
            "type": "course",
            "title": "Dynamic Forms Documentation",
            "url": "https://angular.dev/guide/forms/dynamic-forms"
          },
          {
            "type": "video",
            "title": "Create a Dynamic Reactive Angular Form with JSON",
            "url": "https://www.youtube.com/watch?v=ByHw_RMjkKM"
          }
        ]
      }
    },
    {
      "id": "kxRtLsB3y_th8j-HjmJgK",
      "name": "Custom Validators",
      "resources": {
        "description": "# Custom Validators\n\nCustom validators in Angular are functions that allow you to define your own validation logic for form controls. They are used when the built-in validators (like `required`, `minLength`, etc.) do not meet your specific validation requirements. A custom validator is a function that returns either `null` if the form control is valid, or an object that represents the validation error if it is invalid. This object typically contains a key-value pair where the key is the error name and the value is a boolean or some details about the error.",
        "resources": [
          {
            "type": "course",
            "title": "Defining custom validators",
            "url": "https://angular.dev/guide/forms/form-validation#defining-custom-validators"
          },
          {
            "type": "video",
            "title": "How to create custom validator in Angular 17",
            "url": "https://youtu.be/3TwmS0Gdg9I?si=1w4EX-HifJ70-CxT"
          }
        ]
      }
    },
    {
      "id": "m5dgKgUR3ZqI9sBAzToev",
      "name": "Control Value Accessor",
      "resources": {
        "description": "# Control Value Accessor\n\nDefines an interface that acts as a bridge between the Angular forms API and a native element in the DOM. Implement this interface to create a custom form control directive that integrates with Angular forms.",
        "resources": [
          {
            "type": "course",
            "title": "ControlValueAccessor",
            "url": "https://angular.dev/api/forms/ControlValueAccessor"
          },
          {
            "type": "article",
            "title": "Mastering Angular Control Value Accessor: A guide for Angular Developer",
            "url": "https://hackernoon.com/mastering-angular-control-value-accessor-a-guide-for-angular-developer"
          },
          {
            "type": "article",
            "title": "Angular Custom Form Controls",
            "url": "https://blog.angular-university.io/angular-custom-form-controls/"
          }
        ]
      }
    },
    {
      "id": "8UY0HAvjY7bdbFpt-MM1u",
      "name": "HTTP Client",
      "resources": {
        "description": "# HTTP Client\n\nMost front-end applications need to communicate with a server over the HTTP protocol, to download or upload data and access other back-end services. Angular provides a client HTTP API for Angular applications, the `HttpClient` service class in `@angular/common/http`.",
        "resources": [
          {
            "type": "course",
            "title": "HTTP Client",
            "url": "https://angular.dev/guide/http"
          },
          {
            "type": "article",
            "title": "Angular HTTP Client - Quickstart Guide",
            "url": "https://blog.angular-university.io/angular-http/"
          },
          {
            "type": "article",
            "title": "Using HTTP Client in modern Angular applications",
            "url": "https://www.thisdot.co/blog/using-httpclient-in-modern-angular-applications"
          }
        ]
      }
    },
    {
      "id": "AKPhbg10xXjccO7UBh5eJ",
      "name": "Setting Up the Client",
      "resources": {
        "description": "# Setting Up the Client\n\nBefore you can use `HttpClient` in your app, you must configure it using dependency injection. `HttpClient` is provided using the `provideHttpClient` helper function, which most apps include in the application providers in `app.config.ts`. If your app is using NgModule-based bootstrap instead, you can include `provideHttpClient` in the providers of your app's `NgModule`.",
        "resources": [
          {
            "type": "course",
            "title": "Setting up HttpClient",
            "url": "https://angular.dev/guide/http/setup"
          },
          {
            "type": "video",
            "title": "Setting up HttpClient in Angular (NgModule)",
            "url": "https://www.youtube.com/watch?v=hBFtim1vO3M"
          }
        ]
      }
    },
    {
      "id": "HjGAv3aV-p4ijYJ8XYIw3",
      "name": "Making Requests",
      "resources": {
        "description": "# Making Requests\n\n`HttpClient` has methods corresponding to the different HTTP verbs used to make requests, both to load data and to apply mutations on the server. Each method returns an RxJS `Observable` which, when subscribed, sends the request and then emits the results when the server responds.",
        "resources": [
          {
            "type": "course",
            "title": "Making Requests",
            "url": "https://angular.dev/guide/http/making-requests"
          },
          {
            "type": "video",
            "title": "How to make HTTP request in Angular 18",
            "url": "https://www.youtube.com/watch?v=3vQpYKlHmS0"
          }
        ]
      }
    },
    {
      "id": "xG7iSVOGcbxJbNv3xbNfc",
      "name": "Writing Interceptors",
      "resources": {
        "description": "# Writing Interceptors\n\nInterceptors are middleware that allows common patterns around retrying, caching, logging, and authentication to be abstracted away from individual requests.",
        "resources": [
          {
            "type": "course",
            "title": "Interceptors",
            "url": "https://angular.dev/guide/http/interceptors"
          },
          {
            "type": "article",
            "title": "Angular Interceptor",
            "url": "https://www.scaler.com/topics/angular/angular-interceptor/"
          },
          {
            "type": "video",
            "title": "Interceptors in Angular",
            "url": "https://www.youtube.com/watch?v=w1_AmHv2LmA"
          }
        ]
      }
    },
    {
      "id": "lfp7PIjwITU5gBITQdirD",
      "name": "RxJS Basics",
      "resources": {
        "description": "# RxJS Basics\n\nReactive Extensions for JavaScript, or RxJS, is a reactive library used to implement reactive programming to deal with async implementation, callbacks, and event-based programs.\n\nThe reactive paradigm can be used in many different languages through the use of reactive libraries. These libraries are downloaded APIs that provide functionalities for reactive tools like observers and operators. It can be used in your browser or with Node.js.",
        "resources": [
          {
            "type": "article",
            "title": "Learn RxJS",
            "url": "https://www.learnrxjs.io/"
          },
          {
            "type": "article",
            "title": "RxJs and Observables for Beginners: A Beginner Friendly Introduction",
            "url": "https://blog.angular-university.io/functional-reactive-programming-for-angular-2-developers-rxjs-and-observables/"
          },
          {
            "type": "video",
            "title": "Beginner's RxJS Tutorial: Dive Deep with RxJS Crash Course!",
            "url": "https://www.youtube.com/watch?v=yJdh1_FbtjU"
          }
        ]
      }
    },
    {
      "id": "krXA6ua7E3m4IIpFkgQZe",
      "name": "Observable Pattern",
      "resources": {
        "description": "# Observer Pattern\n\nThe observer pattern is a software design pattern in which an object, named the subject, maintains a list of its dependents, called observers, and notifies them automatically of any state changes, usually by calling one of their methods.\n\nAngular uses the Observer pattern which simply means — Observable objects are registered, and other objects observe (in Angular using the subscribe method) them and take action when the observable object is acted on in some way.",
        "resources": [
          {
            "type": "article",
            "title": "Angular and Observable",
            "url": "https://medium.com/fuzzycloud/angular-and-observable-4bf890b2a282"
          }
        ]
      }
    },
    {
      "id": "b06Y5YrqBbHhWkK6Ws_1c",
      "name": "Observable Lifecycle",
      "resources": {
        "description": "# Observable lifecycle\n\nAn observable is a function that acts as a wrapper for a data stream. They support to pass messages inside your application. An observable is useless until an observer subscribes to it. An observer is an object which consumes the data emitted by the observable. An observer keeps receiving data values from the observable until the observable is completed, or the observer unsubscribes from the observable. Otherwise observers can receive data values from the observable continuously and asynchronously. So we can perform various operations such as updating the user interface, or passing the JSON response.\n\nThere are 4 stages for a life cycle of an observable.\n\n- Creation\n- Subscription\n- Execution\n- Destruction",
        "resources": [
          {
            "type": "article",
            "title": "Understanding Observable LifeCycle",
            "url": "https://medium.com/analytics-vidhya/understanding-rxjs-observables-ad5b34d9607f"
          }
        ]
      }
    },
    {
      "id": "e1ZmmxPZuogCNgtbPPWmd",
      "name": "RxJS vs Promises",
      "resources": {
        "description": "# RxJS vs Promises\n\nIn a nutshell, the main differences between the Promise and the Observable are as follows:\n\n- The Promise is eager, whereas the Observable is lazy,\n- The Promise is always asynchronous, while the Observable can be either asynchronous or synchronous,\n- The Promise can provide a single value, whereas the Observable is a stream of values (from 0 to multiple values), you can apply RxJS operators to the Observable to get a new tailored stream.",
        "resources": [
          {
            "type": "article",
            "title": "Why RxJS? RxJS vs Promises",
            "url": "https://javascript.plainenglish.io/why-rxjs-rxjs-vs-promises-b28962771d68"
          },
          {
            "type": "article",
            "title": "Explore top posts about RxJS",
            "url": "https://app.daily.dev/tags/rxjs?ref=roadmapsh"
          }
        ]
      }
    },
    {
      "id": "ihsjIcF0tkhjs56458teE",
      "name": "Operators",
      "resources": {
        "description": "# RxJS Operators\n\nRxJS operators are crucial functions that enable the declarative composition of complex asynchronous code. There are two primary types: **Pipeable Operators**, such as `filter()` or `mergeMap()`, which are chained using the `observableInstance.pipe()` method to transform an existing Observable into a new one without altering the original; and **Creation Operators**, like `of()` or `interval()`, which are standalone functions used to generate new Observables from scratch. This modular approach to handling asynchronous data streams greatly enhances code readability and maintainability.",
        "resources": [
          {
            "type": "course",
            "title": "List of Creation Operators",
            "url": "https://www.learnrxjs.io/learn-rxjs/operators/creation"
          },
          {
            "type": "article",
            "title": "Full RxJS Operators Documentation",
            "url": "https://www.learnrxjs.io/learn-rxjs/operators/"
          }
        ]
      }
    },
    {
      "id": "nxUbl0eu3LsSL-Z8X6nP5",
      "name": "Filtering",
      "resources": {
        "description": "# Filtering\n\nRxJS provides a variety of filtering operators that you can use to filter and transform the data in a stream. You can use these operators in combination with other RxJS operators to create powerful and efficient data processing pipelines.",
        "resources": [
          {
            "type": "course",
            "title": "RxJS Operators",
            "url": "https://www.learnrxjs.io/learn-rxjs/operators"
          },
          {
            "type": "article",
            "title": "Understanding RxJS Operators",
            "url": "https://medium.com/@madhavi792002/understanding-rxjs-operators-a-friendly-guide-to-reactive-programming-part-1-305dbc0c6e72"
          }
        ]
      }
    },
    {
      "id": "bJbbayFQ9WSJT9-qy0H5l",
      "name": "Rate Limiting",
      "resources": {
        "description": "# Rate limiting\n\nRate limiting in RxJS refers to the practice of restricting the rate at which events or data can be emitted from an observable. This can be useful in situations where the rate of incoming data is higher than the rate at which it can be processed, or where there are limits on the number of requests that can be made to a server. There are a few different operators in RxJS that can be used for rate limiting, such as throttleTime and sampleTime. These operators can be used to limit the rate of emissions from an observable by discarding emissions that occur too frequently. Another operator is auditTime it emits the last value from the source Observable during periodic time windows.",
        "resources": [
          {
            "type": "article",
            "title": "throttleTime",
            "url": "https://www.learnrxjs.io/learn-rxjs/operators/filtering/throttletime"
          },
          {
            "type": "article",
            "title": "auditTime",
            "url": "https://www.learnrxjs.io/learn-rxjs/operators/filtering/audittime"
          },
          {
            "type": "article",
            "title": "Blogs and Tutorials on RxJS",
            "url": "https://blog.angular-university.io/functional-reactive-programming-for-angular-2-developers-rxjs-and-observables/"
          }
        ]
      }
    },
    {
      "id": "kdMJHljMzGA3oRlh8Zvos",
      "name": "Transformation",
      "resources": {
        "description": "# Transformation\n\nIn RxJS, \"transformation\" refers to the process of modifying or manipulating the data emitted by an Observable. There are a variety of methods available in RxJS that can be used to transform the data emitted by an Observable, including:\n\n- **map**: applies a function to each item emitted by the Observable and emits the resulting value\n- **mergeMap**: applies a function to each item emitted by the Observable, and then merges the resulting Observables into a single Observable\n- **switchMap**: applies a function to each item emitted by the Observable, and then switches to the latest resulting Observable\n- **concatMap**: applies a function to each item emitted by the Observable, and then concatenates the resulting Observables into a single Observable\n- **exhaustMap**: applies a function to each item emitted by the Observable, but ignores subsequent emissions until the current Observable completes",
        "resources": [
          {
            "type": "course",
            "title": "The RxJS Library",
            "url": "https://v17.angular.io/guide/rx-library"
          },
          {
            "type": "course",
            "title": "Merge",
            "url": "https://www.learnrxjs.io/learn-rxjs/operators/combination/merge"
          },
          {
            "type": "course",
            "title": "Concat",
            "url": "https://www.learnrxjs.io/learn-rxjs/operators/combination/concat"
          },
          {
            "type": "course",
            "title": "Zip",
            "url": "https://www.learnrxjs.io/learn-rxjs/operators/combination/zip"
          },
          {
            "type": "course",
            "title": "switchMap",
            "url": "https://www.learnrxjs.io/learn-rxjs/operators/transformation/switchmap"
          },
          {
            "type": "course",
            "title": "concatMap",
            "url": "https://www.learnrxjs.io/learn-rxjs/operators/transformation/concatMap"
          },
          {
            "type": "course",
            "title": "exhaustMap",
            "url": "https://www.learnrxjs.io/learn-rxjs/operators/transformation/exhaustMap"
          },
          {
            "type": "video",
            "title": "switchMap vs mergeMap vs concatMap vs exhaustMap practical guide",
            "url": "https://youtu.be/40pC5wHowWw"
          }
        ]
      }
    },
    {
      "id": "IgUHqfVhiGpwxT9tY8O88",
      "name": "Combination",
      "resources": {
        "description": "# Combination\n\nRxJS combination operators merge multiple observables into a single one using various strategies. Key operators include: `Merge` (emits items from all sources as they arrive), `Concat` (emits items from sources sequentially, one after another), `Zip` (pairs emissions from sources based on index), `CombineLatest` (emits based on the latest values from all sources whenever any source emits), `WithLatestFrom` (combines the value of one observable with the latest values of others when the first observable emits), and `ForkJoin` (emits the last value from each source only after all sources complete).",
        "resources": [
          {
            "type": "course",
            "title": "The RxJS Library",
            "url": "https://v17.angular.io/guide/rx-library"
          },
          {
            "type": "course",
            "title": "Merge",
            "url": "https://www.learnrxjs.io/learn-rxjs/operators/combination/merge"
          },
          {
            "type": "course",
            "title": "Concat",
            "url": "https://www.learnrxjs.io/learn-rxjs/operators/combination/concat"
          },
          {
            "type": "course",
            "title": "Zip",
            "url": "https://www.learnrxjs.io/learn-rxjs/operators/combination/zip"
          },
          {
            "type": "course",
            "title": "CombineLatest",
            "url": "https://www.learnrxjs.io/learn-rxjs/operators/combination/combineLatest"
          },
          {
            "type": "course",
            "title": "WithLatestFrom",
            "url": "https://www.learnrxjs.io/learn-rxjs/operators/combination/withLatestFrom"
          },
          {
            "type": "course",
            "title": "ForkJoin",
            "url": "https://www.learnrxjs.io/learn-rxjs/operators/combination/forkJoin"
          }
        ]
      }
    },
    {
      "id": "u1TG8i145o0RKhOR_5epf",
      "name": "Signals",
      "resources": {
        "description": "# Signals\n\nAngular Signals is a system that granularly tracks how and where your state is used throughout an application, allowing the framework to optimize rendering updates.",
        "resources": [
          {
            "type": "course",
            "title": "Signals",
            "url": "https://angular.dev/guide/signals"
          },
          {
            "type": "video",
            "title": "Signals Unleashed: The Full Guide",
            "url": "https://www.youtube.com/watch?v=6W6gycuhiN0&t=169s"
          },
          {
            "type": "article",
            "title": "Angular Signals Complete Guide",
            "url": "https://blog.angular-university.io/angular-signals/"
          }
        ]
      }
    },
    {
      "id": "KAdtebWvgvMifIwd52yc4",
      "name": "RxJS Interop",
      "resources": {
        "description": "# RxJS Interop\n\nAngular's `@angular/core/rxjs-interop` package provides useful utilities to integrate Angular Signals with RxJS Observables. Use a `toSignal` function to create a signal that tracks the value of an Observable. Use the `toObservable` utility to create an Observable which tracks the value of a signal.",
        "resources": [
          {
            "type": "course",
            "title": "RxJS Interop",
            "url": "https://angular.dev/guide/signals/rxjs-interop"
          },
          {
            "type": "article",
            "title": "Angular Signals RxJS Interop from a Practical example",
            "url": "https://angular.love/en/angular-signals-rxjs-interop-from-a-practical-example"
          },
          {
            "type": "video",
            "title": "Angular Signals RxJs Interoperability: toObservable() (Guess the Behavior)",
            "url": "https://www.youtube.com/watch?v=cam39UyVbpI"
          }
        ]
      }
    },
    {
      "id": "LcJyAfv9hjyUNXUVyPRP4",
      "name": "Inputs as Signals",
      "resources": {
        "description": "# Inputs as Signals\n\nSignal inputs allow values to be bound from parent components. Those values are exposed using a Signal and can change during the lifecycle of your component.  Angular supports two variants of inputs: `Optional` and `Required`.",
        "resources": [
          {
            "type": "course",
            "title": "Inputs as Signals",
            "url": "https://angular.dev/guide/signals/inputs"
          },
          {
            "type": "article",
            "title": "Angular Signal Inputs: Complete Guide to input\\(\\)",
            "url": "https://blog.angular-university.io/angular-signal-inputs/"
          },
          {
            "type": "video",
            "title": "Angular's New Signal Inputs",
            "url": "https://www.youtube.com/watch?v=yjCeaiWXC0U"
          }
        ]
      }
    },
    {
      "id": "9HS9C3yq9EUcUy0ZUZk_H",
      "name": "Queries as Signals",
      "resources": {
        "description": "# Queries as Signals\n\nA component or directive can define queries that find child elements and read values from their injectors. Developers most commonly use queries to retrieve references to components, directives, DOM elements, and more. There are two categories of query: view queries and content queries.",
        "resources": [
          {
            "type": "course",
            "title": "Queries as Signals",
            "url": "https://angular.dev/guide/signals/queries"
          },
          {
            "type": "article",
            "title": "Querying made easy: exploring Angular's query signals",
            "url": "https://netbasal.com/querying-made-easy-exploring-angulars-query-signals-ca850b5db892"
          },
          {
            "type": "video",
            "title": "Angular Signal Queries with the viewChild() and contentChild() functions",
            "url": "https://www.youtube.com/watch?v=b35ts9OinBc"
          }
        ]
      }
    },
    {
      "id": "IeU6ClS_yp6BYKdkQOJVf",
      "name": "Model Inputs",
      "resources": {
        "description": "# Model Inputs\n\nModel inputs are a special type of input that enable a component to propagate new values back to another component.  Use model inputs in components that exist to modify a value based on user interaction.",
        "resources": [
          {
            "type": "course",
            "title": "Model Inputs",
            "url": "https://angular.dev/guide/signals/model"
          },
          {
            "type": "video",
            "title": "Angular's New Model Inputs: Two-way Communication with your Child Components",
            "url": "https://www.youtube.com/watch?v=frXIBKqzTK0"
          },
          {
            "type": "article",
            "title": "Angular Model Inputs: Two-way binding inputs with signals",
            "url": "https://www.codemotion.com/magazine/frontend/angular-model-inputs-two-way-binding-inputs-with-signals/"
          },
          {
            "type": "article",
            "title": "Model Inputs: Reactive two-way binding ",
            "url": "https://dev.to/this-is-angular/model-inputs-reactive-two-way-binding-2538"
          }
        ]
      }
    },
    {
      "id": "Mqe_s-nwBqAL6X7OGRHEN",
      "name": "State Management",
      "resources": {
        "description": "# State Management\n\nApplication state management is the process of maintaining knowledge of an application's inputs across multiple related data flows that form a complete business transaction -- or a session -- to understand the condition of the app at any given moment. In computer science, an input is information put into the program by the user and state refers to the condition of an application according to its stored inputs -- saved as variables or constants. State can also be described as the collection of preserved information that forms a complete session.",
        "resources": [
          {
            "type": "article",
            "title": "What is State Management?",
            "url": "https://www.techtarget.com/searchapparchitecture/definition/state-management"
          },
          {
            "type": "article",
            "title": "Angular state management made simple with NgRx",
            "url": "https://blog.logrocket.com/angular-state-management-made-simple-with-ngrx/"
          },
          {
            "type": "article",
            "title": "Angular State Management with NgRx",
            "url": "https://www.syncfusion.com/blogs/post/angular-state-management-with-ngrx.aspx"
          },
          {
            "type": "article",
            "title": "State Management and the Facade pattern in Angular",
            "url": "https://thefullstack.engineer/full-stack-development-series-part-10-state-management-and-the-facade-pattern-in-angular"
          }
        ]
      }
    },
    {
      "id": "N9ZCPgFnFIUv4jMv1w5qK",
      "name": "NGXS",
      "resources": {
        "description": "# Ngxs\n\nNgxs is a state management pattern for the Angular framework. It acts as a single source of truth for our application. Ngxs is very simple and easily implementable. It reduce lots of boilerplate code . It is a replacement for Ngrx. In Ngrx we are creating state, action, reducer, and effects but in Ngxs, we are creating only state and actions instead of all of this. Like Ngrx, Ngxs is also asynchronous and when we dispatch any action we can get a response back.",
        "resources": [
          {
            "type": "course",
            "title": "What is NGXS?",
            "url": "https://www.ngxs.io/"
          },
          {
            "type": "article",
            "title": "Details about NGXS",
            "url": "https://medium.com/@knoldus/introduction-to-ngxs-state-management-pattern-library-for-angular-ec76f681ceba"
          },
          {
            "type": "video",
            "title": "Practice of NGXS",
            "url": "https://www.youtube.com/watch?v=SGj11j4hxmg"
          }
        ]
      }
    },
    {
      "id": "ir94IdkF1tVAA8ZTD9r0N",
      "name": "NgRx",
      "resources": {
        "description": "# NgRx\n\nNgRx is a framework for building reactive applications in Angular. NgRx simplifies managing application state by enforcing unidirectional data flow and providing tools like NgRx Store, NgRx Effects, NgRx Router Store, NgRx Signals, NgRx Entity, and NgRx Operators.",
        "resources": [
          {
            "type": "course",
            "title": "What is NGRX?",
            "url": "https://ngrx.io/docs"
          },
          {
            "type": "article",
            "title": "Angular NgRx Store and Effects Crash Course",
            "url": "https://blog.angular-university.io/angular-ngrx-store-and-effects-crash-course/"
          },
          {
            "type": "video",
            "title": "Angular State Management with NgRx",
            "url": "https://www.youtube.com/watch?v=a3_GW3RBqn0"
          },
          {
            "type": "video",
            "title": "Angular NgRx Signal Store Crash Course (For NgRx Beginners)",
            "url": "https://www.youtube.com/watch?v=HqxY0JPlh54"
          },
          {
            "type": "video",
            "title": "NgRx Best Practices",
            "url": "https://youtu.be/yYiO-kjmLAc?si=7J_JkOdbyocfb5m_"
          },
          {
            "type": "video",
            "title": "Angular Course with NgRx - Building Angular Project From Scratch",
            "url": "https://www.youtube.com/watch?v=vcfZ0EQpYTA"
          }
        ]
      }
    },
    {
      "id": "rgPUcSKxG9DvXicLfC2Ay",
      "name": "Elf",
      "resources": {
        "description": "# Elf\n\nElf is a reactive immutable state management solution built on top of RxJS. It uses custom RxJS operators to query the state and pure functions to update it. Elf encourages simplicity. It saves you the hassle of creating boilerplate code and offers powerful tools with a moderate learning curve, suitable for experienced and inexperienced developers alike.",
        "resources": [
          {
            "type": "course",
            "title": "What is Elf?",
            "url": "https://ngneat.github.io/elf/"
          },
          {
            "type": "tutorial",
            "title": "Elf",
            "url": "https://github.com/ngneat/elf"
          },
          {
            "type": "tutorial",
            "title": "Elf NG Router Store",
            "url": "https://github.com/ngneat/elf-ng-router-store"
          },
          {
            "type": "article",
            "title": "Case Study: Elf",
            "url": "https://medium.com/@gronichomer/case-study-elf-%EF%B8%8F%EF%B8%8F-part-1-fe5e87c31c89"
          }
        ]
      }
    },
    {
      "id": "m4WBnx_9h01Jl6Q1sxi4Y",
      "name": "Zones",
      "resources": {
        "description": "# Zones\n\nZone.js is a signaling mechanism that Angular uses to detect when an application state might have changed. It captures asynchronous operations like setTimeout, network requests, and event listeners. Angular schedules change detection based on signals from Zone.js.",
        "resources": [
          {
            "type": "course",
            "title": "Resolving Zone Pollution",
            "url": "https://angular.dev/best-practices/zone-pollution"
          },
          {
            "type": "course",
            "title": "Angular without ZoneJS (Zoneless)",
            "url": "https://angular.dev/guide/experimental/zoneless"
          },
          {
            "type": "course",
            "title": "NgZone - API",
            "url": "https://angular.dev/api/core/NgZone"
          },
          {
            "type": "video",
            "title": "WTF is \"Zone.js\" and is it making your app slow?",
            "url": "https://www.youtube.com/watch?v=lmrf_gPIOZU"
          }
        ]
      }
    },
    {
      "id": "1x5pT607aKE-S-NCWB810",
      "name": "Zoneless Applications",
      "resources": {
        "description": "# Zoneless Applications\n\nAngular 18 introduced an experimental feature called zoneless change detection. This technology removes the need for `Zone.js`, a library that was previously used for change detection in Angular from the beginning. By eliminating `Zone.js`, Angular applications can have faster initial renders, smaller bundle sizes, and simpler debugging.",
        "resources": [
          {
            "type": "course",
            "title": "Zoneless",
            "url": "https://angular.dev/guide/experimental/zoneless"
          },
          {
            "type": "article",
            "title": "Zoneless Change Detection Angular 18",
            "url": "https://blog.logrocket.com/zoneless-change-detection-angular-18/"
          },
          {
            "type": "article",
            "title": "From Zone JS to Zoneless Angular and back: How it all works",
            "url": "https://angularindepth.com/posts/1513/from-zone-js-to-zoneless-angular-and-back-how-it-all-works"
          },
          {
            "type": "article",
            "title": "A New Era for Angular: Zoneless Change Detection",
            "url": "https://justangular.com/blog/a-new-era-for-angular-zoneless-change-detection"
          },
          {
            "type": "video",
            "title": "Zoneless Angular Applications in V18",
            "url": "https://www.youtube.com/watch?v=MZ6s5EL7hKk"
          },
          {
            "type": "video",
            "title": "I tested Angular 18 Zoneless mode and this is what I found out!",
            "url": "https://www.youtube.com/watch?v=vHNeAqgNM4o"
          }
        ]
      }
    },
    {
      "id": "EbJib-XfZFF9bpCtL3aBs",
      "name": "Developer Tools",
      "resources": {
        "description": "# Developer Tools\n\nAngular offers a suite of powerful developer tools designed to streamline and enhance the development process. These include the Angular CLI for efficient project setup and management, the Angular DevTools extension for advanced debugging and profiling, and the Angular Language Service for improved code editing and completion. Leveraging these tools will significantly improve your ability to write high-quality Angular code.",
        "resources": [
          {
            "type": "course",
            "title": "Angular Devtools",
            "url": "https://angular.dev/tools/devtools"
          },
          {
            "type": "course",
            "title": "Angular CLI",
            "url": "https://angular.dev/tools/cli"
          },
          {
            "type": "course",
            "title": "Language Service Docs",
            "url": "https://angular.dev/tools/language-service"
          },
          {
            "type": "tutorial",
            "title": "VS Code NG Language Service",
            "url": "https://github.com/angular/vscode-ng-language-service"
          }
        ]
      }
    },
    {
      "id": "4YSk6I63Ew--zoXC3xmrC",
      "name": "Angular CLI",
      "resources": {
        "description": "# Angular CLI\n\nThe Angular CLI is a command-line interface tool that you use to initialize, develop, scaffold, and maintain Angular applications directly from a command shell. we can install angular latest CLI using the following command:\n\n`npm install -g @angular/cli`",
        "resources": [
          {
            "type": "course",
            "title": "CLI Reference",
            "url": "https://angular.dev/cli"
          },
          {
            "type": "course",
            "title": "The Angular CLI",
            "url": "https://angular.dev/tools/cli"
          },
          {
            "type": "video",
            "title": "Angular CLI - Setup",
            "url": "https://www.youtube.com/watch?v=mZnzX3J5XKI"
          },
          {
            "type": "article",
            "title": "Explore top posts about Angular",
            "url": "https://app.daily.dev/tags/angular?ref=roadmapsh"
          }
        ]
      }
    },
    {
      "id": "FVH0lnbIZ2m5EfF2EJ2DW",
      "name": "Local Setup",
      "resources": {
        "description": "# Local Setup\n\nTo install Angular CLI on your local system, you need to install `Node.js`. Angular requires an active LTS or maintenance LTS version of Node. Angular CLI uses Node and its associated package manager, npm, to install and run JavaScript tools outside the browser.  Once you have Node installed, you can run `npm install -g @angular/cli` to install the Angular CLI.",
        "resources": [
          {
            "type": "course",
            "title": "Local set-up",
            "url": "https://angular.dev/tools/cli/setup-local"
          },
          {
            "type": "course",
            "title": "Version Compatibility Guide",
            "url": "https://angular.dev/reference/versions"
          },
          {
            "type": "video",
            "title": "How To Install Angular CLI In Windows 10 | In Under 2 Minutes!",
            "url": "https://www.youtube.com/watch?v=vjgACKkPENg"
          },
          {
            "type": "video",
            "title": "How to Install Multiple Versions of Angular in Your Development Environment",
            "url": "https://www.youtube.com/watch?v=LYNG3kcKRQ8"
          }
        ]
      }
    },
    {
      "id": "1fVi9AK6aLjt5QgAFbnGX",
      "name": "Deployment",
      "resources": {
        "description": "# Deployment\n\nThe Angular CLI command `ng deploy` executes the deploy CLI builder associated with your project. A number of third-party builders implement deployment capabilities to different platforms. You can add any of them to your project with `ng add`.",
        "resources": [
          {
            "type": "course",
            "title": "Deployment",
            "url": "https://angular.dev/tools/cli/deployment"
          },
          {
            "type": "course",
            "title": "Firebase Hosting",
            "url": "https://firebase.google.com/docs/hosting"
          },
          {
            "type": "course",
            "title": "Vercel: Angular Solutions",
            "url": "https://vercel.com/solutions/angular"
          },
          {
            "type": "course",
            "title": "Netlify",
            "url": "https://docs.netlify.com/frameworks/angular/"
          },
          {
            "type": "course",
            "title": "Cloudflare Pages",
            "url": "https://developers.cloudflare.com/pages/framework-guides/deploy-an-angular-site/#create-a-new-project-using-the-create-cloudflare-cli-c3"
          },
          {
            "type": "course",
            "title": "AWS Amplify",
            "url": "https://docs.amplify.aws/angular/"
          },
          {
            "type": "tutorial",
            "title": "NGX AWS Deploy",
            "url": "https://github.com/Jefiozie/ngx-aws-deploy"
          },
          {
            "type": "tutorial",
            "title": "Angular CLI GitHub Pages",
            "url": "https://github.com/angular-schule/angular-cli-ghpages"
          }
        ]
      }
    },
    {
      "id": "yhNGhduk__ow8VTLc6inZ",
      "name": "End-to-End Testing",
      "resources": {
        "description": "# End-to-End Testing\n\nEnd-to-end or (E2E) testing is a form of testing used to assert your entire application works as expected from start to finish or \"end-to-end\". E2E testing differs from unit testing in that it is completely decoupled from the underlying implementation details of your code. It is typically used to validate an application in a way that mimics the way a user would interact with it. The `ng e2e` command will first check your project for the \"e2e\" target. If it can't locate it, the CLI will then prompt you which e2e package you would like to use and walk you through the setup.",
        "resources": [
          {
            "type": "course",
            "title": "End to End Testing",
            "url": "https://angular.dev/tools/cli/end-to-end"
          },
          {
            "type": "course",
            "title": "Your First Test with Cypress",
            "url": "https://docs.cypress.io/guides/end-to-end-testing/writing-your-first-end-to-end-test"
          },
          {
            "type": "course",
            "title": "Writing Tests: Introduction",
            "url": "https://nightwatchjs.org/guide/writing-tests/introduction.html"
          },
          {
            "type": "course",
            "title": "Getting Started",
            "url": "https://webdriver.io/docs/gettingstarted/"
          },
          {
            "type": "course",
            "title": "Puppeteer Angular Schematic",
            "url": "https://pptr.dev/guides/ng-schematics/#getting-started"
          }
        ]
      }
    },
    {
      "id": "Uvr0pRk_fOzwRwqn0dQ6N",
      "name": "Schematics",
      "resources": {
        "description": "# Schematics\n\nA schematic is a template-based code generator that supports complex logic. It is a set of instructions for transforming a software project by generating or modifying code.",
        "resources": [
          {
            "type": "course",
            "title": "Generating Code using Schematics",
            "url": "https://angular.dev/tools/cli/schematics"
          },
          {
            "type": "article",
            "title": "Angular Blog",
            "url": "https://blog.angular.io/schematics-an-introduction-dc1dfbc2a2b2?gi=ad9571373944"
          }
        ]
      }
    },
    {
      "id": "Ax-s_xw3FO3Ocv-AnLbQD",
      "name": "Build Environments",
      "resources": {
        "description": "# Build Environments\n\nYou can define different named build configurations for your project, such as `development` and `production`, with different defaults. Each named configuration can have defaults for any of the options that apply to the various builder targets, such as `build`, `serve`, and `test`. The Angular CLI can replace files for each environment if you pass a `--configuration` flag with the named configuration when running a CLI command.",
        "resources": [
          {
            "type": "course",
            "title": "Build Environments",
            "url": "https://angular.dev/tools/cli/environments#using-environment-specific-variables-in-your-app"
          },
          {
            "type": "article",
            "title": "Building an Angular application in various environments using Angular CLI and server",
            "url": "https://medium.com/yavar/building-an-angular-application-in-various-environments-using-angular-cli-and-server-18f94067154b"
          }
        ]
      }
    },
    {
      "id": "TeWEy9I-hU6SH02Sy2S2S",
      "name": "CLI Builders",
      "resources": {
        "description": "# CLI Builders\n\nA number of Angular CLI commands run a complex process on your code, such as building, testing, or serving your application. The commands use an internal tool called `Architect` to run CLI builders, which invoke another tool (bundler, test runner, server) to accomplish the desired task. Custom builders can perform an entirely new task or to change which third-party tool is used by an existing command.",
        "resources": [
          {
            "type": "course",
            "title": "CLI Builders",
            "url": "https://angular.dev/tools/cli/cli-builder"
          },
          {
            "type": "video",
            "title": "Angular Builders – Creating Custom Builder from Scratch",
            "url": "https://www.youtube.com/watch?v=QbDkDLnXAZE"
          },
          {
            "type": "tutorial",
            "title": "Angular Builders",
            "url": "https://github.com/just-jeb/angular-builders"
          }
        ]
      }
    },
    {
      "id": "MwtM1UAIfj4FJ-Y4CKDsP",
      "name": "AoT Compilation",
      "resources": {
        "description": "# AoT Compilation\n\nAngular applications require a compilation process before they can run in a browser. The Angular ahead-of-time (AOT) compiler converts your Angular HTML and TypeScript code into efficient JavaScript code during the build phase before the browser downloads and runs that code. Compiling your application during the build process provides a faster rendering in the browser.",
        "resources": [
          {
            "type": "course",
            "title": "Ahead-of-time (AOT) compilation",
            "url": "https://angular.dev/tools/cli/aot-compiler"
          },
          {
            "type": "tutorial",
            "title": "Angular Compiler Output",
            "url": "https://github.com/JeanMeche/angular-compiler-output"
          },
          {
            "type": "article",
            "title": "Understanding Angular's ahead of time compliation",
            "url": "https://blog.nashtechglobal.com/understanding-angulars-ahead-of-time-aot-compilation/"
          }
        ]
      }
    },
    {
      "id": "T3MmS3bvMMgCUbOk3ktU7",
      "name": "DevTools",
      "resources": {
        "description": "# DevTools\n\nAngular DevTools is a browser extension that provides debugging and profiling capabilities for Angular applications.  You can view component trees and change detection cycles.",
        "resources": [
          {
            "type": "course",
            "title": "Angular Devtools",
            "url": "https://angular.dev/tools/devtools"
          },
          {
            "type": "course",
            "title": "Chrome Web Store",
            "url": "https://chromewebstore.google.com/detail/angular-devtools/ienfalfjdbdpebioblfackkekamfmbnh"
          },
          {
            "type": "course",
            "title": "Firefox Add-ons",
            "url": "https://addons.mozilla.org/en-US/firefox/addon/angular-devtools/"
          },
          {
            "type": "video",
            "title": "Did you try the LATEST Angular developer tools?",
            "url": "https://www.youtube.com/watch?v=tAfe33fVW4w"
          }
        ]
      }
    },
    {
      "id": "ql7SyxrRmjpiXJ9hQeWPq",
      "name": "Language Service",
      "resources": {
        "description": "# Language Service\n\nThe Angular Language Service provides code editors with a way to get completions, errors, hints, and navigation inside Angular templates (external and in-line). Anytime you open an Angular application for the first time, an installation prompt will occur.\n\nVisit the following links to learn more:\n\n- [@official@Language Service Docs](https://angular.dev/tools/language-service)\n- [@opensource@VS Code NG Language Service](https://github.com/angular/vscode-ng-language-service)",
        "resources": [
          {
            "type": "course",
            "title": "Language Service Docs",
            "url": "https://angular.dev/tools/language-service"
          },
          {
            "type": "tutorial",
            "title": "VS Code NG Language Service",
            "url": "https://github.com/angular/vscode-ng-language-service"
          }
        ]
      }
    },
    {
      "id": "cl89U8atD6gw5rMGUm4Ix",
      "name": "Libraries",
      "resources": {
        "description": "# Library\n\nUse the Angular CLI and the npm package manager to build and publish your library as an npm package.",
        "resources": [
          {
            "type": "course",
            "title": "Libraries",
            "url": "https://angular.dev/tools/libraries/creating-libraries"
          },
          {
            "type": "course",
            "title": "Angular CLI",
            "url": "https://angular.dev/tools/cli"
          }
        ]
      }
    },
    {
      "id": "YHV5oFwLwphXf1wJTDZuG",
      "name": "Using Libraries",
      "resources": {
        "description": "# Using Libraries\n\nLibraries are published as `npm packages`, usually together with schematics that integrate them with the Angular CLI. To integrate reusable library code into an application, you need to install the package and import the provided functionality in the location you use it. For most published Angular libraries, use the `ng add <lib_name>` Angular CLI command. A published library typically provides a `README` file or other documentation on how to add that library to your application. A library is able to be updated by the publisher, and also has individual dependencies which need to be kept current. To check for updates to your installed libraries, use the `ng update` Angular CLI command.",
        "resources": [
          {
            "type": "course",
            "title": "Using Libraries",
            "url": "https://angular.dev/tools/libraries/using-libraries"
          },
          {
            "type": "course",
            "title": "npm",
            "url": "https://www.npmjs.com/"
          }
        ]
      }
    },
    {
      "id": "A1mYMg7cbcj6p_VkDf-Tz",
      "name": "Creating Libraries",
      "resources": {
        "description": "# Creating Libraries\n\nIf you have developed features that are suitable for reuse, you can create your own libraries. These libraries can be used locally in your workspace, or you can publish them as npm packages to share with other projects or other Angular developers. Putting code into a separate library is more complex than simply putting everything in one application. It requires more of an investment in time and thought for managing, maintaining, and updating the library. This complexity can pay off when the library is being used in multiple applications.",
        "resources": [
          {
            "type": "course",
            "title": "Creating Libraries",
            "url": "https://angular.dev/tools/libraries/creating-libraries"
          },
          {
            "type": "course",
            "title": "File Structure: Library project files",
            "url": "https://angular.dev/reference/configs/file-structure#library-project-files"
          },
          {
            "type": "tutorial",
            "title": "NG Packagr",
            "url": "https://github.com/ng-packagr/ng-packagr"
          }
        ]
      }
    },
    {
      "id": "jfHaS8TqE4tcAo59K8Nkn",
      "name": "SSR",
      "resources": {
        "description": "# SSR in Angular\n\nA normal Angular application executes in the browser, rendering pages in the DOM in response to user actions. Angular Universal executes on the server, generating static application pages that later get bootstrapped on the client. This means that the application generally renders more quickly, giving users a chance to view the application layout before it becomes fully interactive.",
        "resources": [
          {
            "type": "course",
            "title": "Server-side Rendering",
            "url": "https://angular.dev/guide/ssr"
          },
          {
            "type": "article",
            "title": "Rendering on the Web",
            "url": "https://web.dev/rendering-on-the-web/"
          },
          {
            "type": "article",
            "title": "Explore top posts about Angular",
            "url": "https://app.daily.dev/tags/angular?ref=roadmapsh"
          }
        ]
      }
    },
    {
      "id": "b-0yQ74zHtAxI9aRLBohc",
      "name": "SSG",
      "resources": {
        "description": "# Angular SSG\n\nSSG (Static Site Generator) helps in building the HTML full website during the process of building and serving that HTML page. This method helps to generate the HTML website on the client side before it's served on the server side. Therefore, whenever a user requests a HTML page, the HTML page will be rendered, and secondly, the Angular app will be rendered. The SSG can be used only if your website is static or its content doesn't change frequently.",
        "resources": [
          {
            "type": "course",
            "title": "Prerendering (SSG)",
            "url": "https://angular.dev/guide/prerendering"
          },
          {
            "type": "video",
            "title": "Angular 16 Pre Rendering Static Pages - Static Site Generation SSG",
            "url": "https://www.youtube.com/watch?v=vmOWJvm3apA"
          },
          {
            "type": "article",
            "title": "Angular Air with Alyssa Nicoll - SSR, SSG, ISR, & SOS",
            "url": "https://www.youtube.com/watch?v=b0pUU7RJbBQ"
          }
        ]
      }
    },
    {
      "id": "kauQofxCmpktXPcnzid17",
      "name": "AnalogJS",
      "resources": {
        "description": "# AnalogJS\n\nAnalogJS is a full-stack meta-framework powered by Vite and Nitro for Angular. Analog supports both Server-Side Rendering (SSR) and Static Site Generation (SSG). Analog uses file-based routing and supports API (server) routes.",
        "resources": [
          {
            "type": "course",
            "title": "AnalogJS",
            "url": "https://analogjs.org/"
          },
          {
            "type": "course",
            "title": "AnalogJS Documentation",
            "url": "https://analogjs.org/docs"
          },
          {
            "type": "tutorial",
            "title": "analogjs/analog",
            "url": "https://github.com/analogjs/analog"
          },
          {
            "type": "video",
            "title": "Robin Goetz - AnalogJS - The Vite powered Angular meta-framework",
            "url": "https://www.youtube.com/watch?v=BSgpvP4eAGk"
          },
          {
            "type": "video",
            "title": "Full-stack Angular (SSR, file-based routing, + more) with AnalogJS",
            "url": "https://www.youtube.com/watch?v=VSCXOTCJpiI"
          },
          {
            "type": "video",
            "title": "Is AnalogJS good enough for my blog site?",
            "url": "https://www.youtube.com/watch?v=xTzEDQULo6s"
          }
        ]
      }
    },
    {
      "id": "mm6c7GLQEwoQdAHdAYzGh",
      "name": "Security",
      "resources": {
        "description": "# Security\n\nThis topic describes Angular's built-in protections against common web-application vulnerabilities and attacks such as cross-site scripting attacks. It doesn't cover application-level security, such as authentication and authorization.",
        "resources": [
          {
            "type": "course",
            "title": "Security",
            "url": "https://angular.dev/best-practices/security"
          },
          {
            "type": "course",
            "title": "Open Web Application Security Project (OWASP)",
            "url": "https://owasp.org/"
          }
        ]
      }
    },
    {
      "id": "umUX4Hxk7srHlFR_Un-u7",
      "name": "Cross-site Scripting",
      "resources": {
        "description": "# Cross-site Scripting\n\nCross-site scripting (XSS) enables attackers to inject malicious code into web pages. Such code can then, for example, steal user and login data, or perform actions that impersonate the user.\nThis has been one of the biggest web security vulnerabilities for over a decade. To systematically block XSS bugs, Angular treats all values as untrusted by default. When a value is inserted into the DOM from a template binding, or interpolation, Angular sanitizes and escapes untrusted values.",
        "resources": [
          {
            "type": "course",
            "title": "Preventing cross-site Scripting (XSS)",
            "url": "https://angular.dev/best-practices/security#preventing-cross-site-scripting-xss"
          },
          {
            "type": "article",
            "title": "Mitigate cross-site scripting (XSS)",
            "url": "https://web.dev/articles/strict-csp"
          }
        ]
      }
    },
    {
      "id": "cgI9oeUHufA-ky_W1zENe",
      "name": "Sanitization",
      "resources": {
        "description": "# Sanitization\n\nSanitization is the inspection of an untrusted value, turning it into a value that's safe to insert into the DOM. In many cases, sanitization doesn't change a value at all. Sanitization depends on context: A value that's harmless in CSS is potentially dangerous in a URL.\n\nAngular sanitizes untrusted values for HTML and URLs. Sanitizing resource URLs isn't possible because they contain arbitrary code. In development mode, Angular prints a console warning when it has to change a value during sanitization.",
        "resources": [
          {
            "type": "course",
            "title": "Sanitization and Security Contexts",
            "url": "https://angular.dev/best-practices/security#sanitization-and-security-contexts"
          }
        ]
      }
    },
    {
      "id": "XoYSuv1salCCHoI1cJkxv",
      "name": "Trusting Safe Values",
      "resources": {
        "description": "# Trusting Safe Values\n\nSometimes applications genuinely need to include executable code, display an `<iframe>` from some URL, or construct potentially dangerous URLs. To prevent automatic sanitization in these situations, tell Angular that you inspected a value, checked how it was created, and made sure it is secure. Do be careful. If you trust a value that might be malicious, you are introducing a security vulnerability into your application. If in doubt, find a professional security reviewer.",
        "resources": [
          {
            "type": "course",
            "title": "Trusting Safe Values",
            "url": "https://angular.dev/best-practices/security#trusting-safe-values"
          }
        ]
      }
    },
    {
      "id": "5h7U0spwEUhB-hbjSlaeB",
      "name": "Enforce Trusted Types",
      "resources": {
        "description": "# Enforce Trusted Types\n\nIt is recommended that you use Trusted Types as a way to help secure your applications from cross-site scripting attacks. Trusted Types is a web platform feature that can help you prevent cross-site scripting attacks by enforcing safer coding practices. Trusted Types can also help simplify the auditing of application code.",
        "resources": [
          {
            "type": "course",
            "title": "Enforcing Trusted Types",
            "url": "https://angular.dev/best-practices/security#enforcing-trusted-types"
          },
          {
            "type": "course",
            "title": "W3C - Trusted Types",
            "url": "https://w3c.github.io/trusted-types/dist/spec/"
          },
          {
            "type": "course",
            "title": "Trusted Types API",
            "url": "https://developer.mozilla.org/en-US/docs/Web/API/Trusted_Types_API"
          },
          {
            "type": "article",
            "title": "How to use Trusted Types",
            "url": "https://web.dev/articles/trusted-types#how-to-use-trusted-types"
          }
        ]
      }
    },
    {
      "id": "xH3RHPhsaqD9zIMms5OmX",
      "name": "HTTP Vulnerabilities",
      "resources": {
        "description": "# HTTP Vulnerabilities\n\nAngular has built-in support to help prevent two common HTTP vulnerabilities, cross-site request forgery (CSRF or XSRF) and cross-site script inclusion (XSSI). Both of these must be mitigated primarily on the server side, but Angular provides helpers to make integration on the client side easier.",
        "resources": [
          {
            "type": "course",
            "title": "Angular Security",
            "url": "https://angular.dev/best-practices/security"
          },
          {
            "type": "article",
            "title": "Angular | HackTricks",
            "url": "https://book.hacktricks.xyz/network-services-pentesting/pentesting-web/angular"
          }
        ]
      }
    },
    {
      "id": "Z1DZBbFI4oU6-KQg3wqMm",
      "name": "Cross-site Request Forgery",
      "resources": {
        "description": "# Cross-site Request Forgery\n\nCross-site request forgery, also known as one-click attack or session riding and abbreviated as CSRF or XSRF, is a type of malicious exploit of a website or web application where unauthorized commands are submitted from a user that the web application trusts. There are many ways in which a malicious website can transmit such commands; specially-crafted image tags, hidden forms, and JavaScript fetch or XMLHttpRequests, for example, can all work without the user's interaction or knowledge. Unlike cross-site scripting (XSS), which exploits the trust a user has for a particular site, CSRF exploits the trust that a site has in a user's browser.",
        "resources": [
          {
            "type": "course",
            "title": "Cross Site Request Forgery",
            "url": "https://angular.dev/best-practices/security#cross-site-request-forgery"
          },
          {
            "type": "course",
            "title": "HttpClientXsrfModule",
            "url": "https://angular.dev/api/common/http/HttpClientXsrfModule"
          },
          {
            "type": "article",
            "title": "Prevent Cross-Site Request Forgery (XSRF/CSRF) Attack",
            "url": "https://learn.microsoft.com/en-us/aspnet/core/security/anti-request-forgery?view=aspnetcore-9.0"
          },
          {
            "type": "video",
            "title": "Configure the CSRF Protection With Spring Security 6 and Angular",
            "url": "https://www.youtube.com/watch?v=tgjLsEmxcuY"
          },
          {
            "type": "video",
            "title": "Angular Security - CSRF prevention using Double Submit Cookie",
            "url": "https://www.youtube.com/watch?v=lZfF4MOTeNM"
          }
        ]
      }
    },
    {
      "id": "m2aw8vb4rz4IjshpoMyNx",
      "name": "HttpClient CSRF",
      "resources": {
        "description": "# HttpClient CSRF\n\nHttpClient includes a built-in mechanism to prevent XSRF attacks. When making HTTP requests, an interceptor reads a token from a cookie (default name: XSRF-TOKEN) and sets it as an HTTP header (X-XSRF-TOKEN). Since only code running on your domain can read this cookie, the backend can verify that the HTTP request originates from your client application and not from an attacker.\n\nHowever, HttpClient only handles the client-side aspect of XSRF protection. Your backend service must be configured to set the cookie for your page and verify that the header is present on all relevant requests. Without this backend configuration, Angular’s default XSRF protection will not be effective.",
        "resources": [
          {
            "type": "course",
            "title": "Angular Security",
            "url": "https://angular.dev/best-practices/security#httpclient-xsrf-csrf-security"
          },
          {
            "type": "article",
            "title": "How can you protect Angular Web app from cross site request forgery?",
            "url": "https://www.linkedin.com/advice/3/how-can-you-protect-angular-web-app-from-cross-site-pyqwc"
          },
          {
            "type": "article",
            "title": "Cross Site Request Forgery: XSRF protection in Angular",
            "url": "https://borstch.com/blog/development/cross-site-request-forgery-xsrf-protection-in-angular"
          }
        ]
      }
    },
    {
      "id": "ni00edsphJd7uBLCn7-Vw",
      "name": "XSRF protection",
      "resources": {
        "description": "# XSRF Protection\n\nCross-Site Request Forgery (XSRF or CSRF) protection is a critical security measure designed to prevent a type of malicious exploit where an attacker tricks a web browser into sending an unauthorized request to a trusted site on behalf of a logged-in user. Unlike phishing, which tries to steal credentials, XSRF exploits a user's active session.",
        "resources": [
          {
            "type": "article",
            "title": "Prevent Cross-Site Request Forgery (XSRF/CSRF) Attack",
            "url": "https://learn.microsoft.com/en-us/aspnet/core/security/anti-request-forgery?view=aspnetcore-9.0"
          },
          {
            "type": "video",
            "title": "Configure the CSRF Protection With Spring Security 6 and Angular",
            "url": "https://www.youtube.com/watch?v=tgjLsEmxcuY"
          },
          {
            "type": "video",
            "title": "Angular Security - CSRF prevention using Double Submit Cookie",
            "url": "https://www.youtube.com/watch?v=lZfF4MOTeNM"
          }
        ]
      }
    },
    {
      "id": "zd7YJGlcMFNFbsKUiW_XC",
      "name": "Cross-site Script Inclusion",
      "resources": {
        "description": "# Cross-site Script Inclusion\n\nCross-site script inclusion, also known as JSON vulnerability, can allow an attacker's website to read data from a JSON API. The attack works on older browsers by overriding built-in JavaScript object constructors, and then including an API URL using a `<script>` tag. Angular's HttpClient library recognizes this convention and automatically strips the string \")]}',\\n\" from all responses before further parsing.",
        "resources": [
          {
            "type": "course",
            "title": "Cross Site Script Inclusion",
            "url": "https://angular.dev/best-practices/security#cross-site-script-inclusion-xssi"
          },
          {
            "type": "article",
            "title": "XSSI Cross Site Script Inclusion",
            "url": "https://book.hacktricks.xyz/pentesting-web/xssi-cross-site-script-inclusion"
          },
          {
            "type": "article",
            "title": "Testing for Cross Site Script Inclusion",
            "url": "https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/11-Client_Side_Testing/13-Testing_for_Cross_Site_Script_Inclusion"
          }
        ]
      }
    },
    {
      "id": "VNG9DdXlS6R1OJ6Lrn4Lt",
      "name": "Accessibility",
      "resources": {
        "description": "# Accessibility\n\nThe web is used by a wide variety of people, including those who have visual or motor impairments. A variety of assistive technologies are available that make it much easier for these groups to interact with web-based software applications. Also, designing an application to be more accessible generally improves the user experience for all users.",
        "resources": [
          {
            "type": "course",
            "title": "Accessibility",
            "url": "https://angular.dev/best-practices/a11y"
          },
          {
            "type": "article",
            "title": "Learn Accessibility",
            "url": "https://web.dev/learn/accessibility/"
          },
          {
            "type": "article",
            "title": "Angular a11y: 11 tips on how to make your apps more accessible",
            "url": "https://angularindepth.com/posts/1152/angular-a11y-11-tips-on-how-to-make-your-apps-more-accessible"
          }
        ]
      }
    },
    {
      "id": "0FvH7KPs9ag02QkD1HEJ-",
      "name": "Attributes",
      "resources": {
        "description": "# Attributes\n\nBuilding accessible web experience often involves setting Accessible Rich Internet Applications (ARIA) attributes to provide semantic meaning where it might otherwise be missing. Use attribute binding template syntax to control the values of accessibility-related attributes.",
        "resources": [
          {
            "type": "course",
            "title": "Accessibility Attributes",
            "url": "https://angular.dev/best-practices/a11y#accessibility-attributes"
          },
          {
            "type": "article",
            "title": "ARIA HTML",
            "url": "https://web.dev/learn/accessibility/aria-html/"
          },
          {
            "type": "article",
            "title": "Comprehensive accessibility strategies for Angular apps leveraging aria-label for dynamic content",
            "url": "https://yasikahivin.medium.com/comprehensive-accessibility-strategies-for-angular-apps-leveraging-aria-label-for-dynamic-content-fdf114834317"
          }
        ]
      }
    },
    {
      "id": "CZ1YRyai8Ds-ry4A8jVbr",
      "name": "UI Components",
      "resources": {
        "description": "# UI Components\n\nThe Angular Material library, which is maintained by the Angular team, is a suite of reusable UI components that aims to be fully accessible. The Component Development Kit (CDK) includes the a11y package that provides tools to support various areas of accessibility.",
        "resources": [
          {
            "type": "course",
            "title": "UI Components",
            "url": "https://angular.dev/best-practices/a11y#angular-ui-components"
          },
          {
            "type": "course",
            "title": "Angular a11y overview",
            "url": "https://material.angular.io/cdk/a11y/overview"
          }
        ]
      }
    },
    {
      "id": "0s-QhN5aZh2F3tLJFKEyR",
      "name": "Containers",
      "resources": {
        "description": "# Containers\n\nSome Angular Material UI components cannot take children, such as an input, so you need to use container elements to customize the UI component.",
        "resources": [
          {
            "type": "course",
            "title": "Using Containers for Native Elements",
            "url": "https://angular.dev/best-practices/a11y#using-containers-for-native-elements"
          }
        ]
      }
    },
    {
      "id": "8i_JD1P4gIhY1rdldwLC2",
      "name": "Routing",
      "resources": {
        "description": "# Routing\n\nTracking and controlling focus in a UI is an important consideration in designing for accessibility. When using Angular routing, you should decide where page focus goes upon navigation.",
        "resources": [
          {
            "type": "course",
            "title": "a11y routing",
            "url": "https://angular.dev/best-practices/a11y#routing"
          },
          {
            "type": "article",
            "title": "Accessibility - Focus",
            "url": "https://web.dev/learn/accessibility/focus/"
          },
          {
            "type": "article",
            "title": "Router events in Angular",
            "url": "https://medium.com/@gurunadhpukkalla/router-events-in-angular-3112a3968660"
          }
        ]
      }
    },
    {
      "id": "5-RCB8AiDbkdIFYNXKWge",
      "name": "Link Identification",
      "resources": {
        "description": "# Link Identification\n\nCSS classes applied to active `RouterLink` elements, such as `RouterLinkActive`, provide a visual cue to identify the active link. Unfortunately, a visual cue doesn't help blind or visually impaired users. Applying the `aria-current` attribute to the element can help identify the active link.",
        "resources": [
          {
            "type": "course",
            "title": "Accessibility - Active links identification",
            "url": "https://angular.dev/best-practices/a11y#active-links-identification"
          },
          {
            "type": "article",
            "title": "ARIA Current",
            "url": "https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-current"
          }
        ]
      }
    },
    {
      "id": "STEHxJpwBZxFdQl0zUKxo",
      "name": "Performance",
      "resources": {
        "description": "# Performance\n\nAngular’s performance is enhanced through key strategies such as Deferable Views for improved initial load times, Image Optimization techniques to reduce loading overhead, and mitigation of Zone Pollution to streamline change detection. Additionally, addressing Slow Computations enhances runtime efficiency, while Hydration techniques support faster, more interactive server-side rendered applications.",
        "resources": [
          {
            "type": "course",
            "title": "Performance Overview",
            "url": "https://angular.dev/best-practices/runtime-performance"
          },
          {
            "type": "article",
            "title": "The Complete Angular Performance Guide",
            "url": "https://danielk.tech/home/complete-angular-performance-guide"
          },
          {
            "type": "video",
            "title": "From Good to Great: Optimizing Angular Performance",
            "url": "https://www.youtube.com/watch?v=tMxrY7IL-Ac"
          }
        ]
      }
    },
    {
      "id": "CYjsXIOWtP5DJmYS-qR-s",
      "name": "Deferrable Views",
      "resources": {
        "description": "# Deferrable Views\n\nDeferrable views can be used in component template to defer the loading of select dependencies within that template. Those dependencies include components, directives, and pipes, and any associated CSS. To use this feature, you can declaratively wrap a section of your template in a @defer block which specifies the loading conditions.",
        "resources": [
          {
            "type": "course",
            "title": "Deferrable Views",
            "url": "https://angular.dev/guide/defer"
          },
          {
            "type": "article",
            "title": "Unlocking Performance with Deferrable views",
            "url": "https://medium.com/@kashif_khan/exploring-angular-17-unlocking-performance-with-deferrable-views-580b1977f430"
          },
          {
            "type": "video",
            "title": "Angular 17 Defer Block",
            "url": "https://www.youtube.com/watch?v=h2rEGoqwr6o"
          },
          {
            "type": "article",
            "title": "Learn how to unit test deferrable views",
            "url": "https://angular.love/en/learn-how-to-unit-test-the-deferrable-views"
          }
        ]
      }
    },
    {
      "id": "1WIKjn3nxYDMIhBL17aYQ",
      "name": "Image Optimization",
      "resources": {
        "description": "# Image Optimization\n\nThe NgOptimizedImage directive makes it easy to adopt performance best practices for loading images.",
        "resources": [
          {
            "type": "course",
            "title": "Image Optimization",
            "url": "https://angular.dev/guide/image-optimization"
          },
          {
            "type": "article",
            "title": "Automatic Adjustments in Angular's optimized images",
            "url": "https://medium.com/ngconf/automatic-adjustments-in-angulars-optimized-images-0034335e0374"
          },
          {
            "type": "article",
            "title": "Boost your application's performance with NgOptimizedImage",
            "url": "https://angular.love/en/boost-your-applications-performance-with-ngoptimizedimage"
          }
        ]
      }
    },
    {
      "id": "pRSR5PEbkJXAJ1LPyK-EE",
      "name": "Zone Pollution",
      "resources": {
        "description": "# Zone Pollution\n\n`Zone.js` is a signaling mechanism that Angular uses to detect when an application state might have changed. In some cases, scheduled tasks or microtasks don’t make any changes in the data model, which makes running change detection unnecessary. Common examples are `requestAnimationFrame`, `setTimeout` and `setInterval`. You can identify change detection with Angular DevTools, and you can run code outside the Angular zone to avoid unnecessary change detection calls.",
        "resources": [
          {
            "type": "course",
            "title": "Zone Pollution",
            "url": "https://angular.dev/best-practices/zone-pollution"
          },
          {
            "type": "course",
            "title": "Angular DevTools",
            "url": "https://angular.dev/tools/devtools"
          },
          {
            "type": "video",
            "title": "NgZone in Angular - Improve Performance by Running Code Outside Angular",
            "url": "https://www.youtube.com/watch?v=7duYY9IFIuw"
          },
          {
            "type": "video",
            "title": "4 Runtime Performance Optimizations",
            "url": "https://www.youtube.com/watch?v=f8sA-i6gkGQ"
          }
        ]
      }
    },
    {
      "id": "yxUtSBzJPRcS-IuPsyp-W",
      "name": "Slow Computations",
      "resources": {
        "description": "# Slow Computations\n\nOn every change detection cycle, Angular synchronously evaluates all template expressions in components based on their detection strategy and executes the `ngDoCheck`, `ngAfterContentChecked`, `ngAfterViewChecked`, and `ngOnChanges` lifecycle hooks. To remove slow computations, you can optimize algorithms, cache data with pure pipes or memoization, and limit lifecycle hook usage.",
        "resources": [
          {
            "type": "course",
            "title": "Slow Computations",
            "url": "https://angular.dev/best-practices/slow-computations"
          },
          {
            "type": "article",
            "title": "Angular Performance Optimization",
            "url": "https://davembush.medium.com/angular-performance-optimization-5ec630d2b8f1"
          }
        ]
      }
    },
    {
      "id": "NY_MfBNgNmloiRGcIvfJ1",
      "name": "Hydration",
      "resources": {
        "description": "# Hydration\n\nHydration is the process that restores the server-side rendered application on the client. This includes things like reusing the server rendered DOM structures, persisting the application state, transferring application data that was retrieved already by the server, and other processes. Hydration can be enabled for server-side rendered (SSR) applications only. You can enable hydration manually by visiting your main application component or module and importing `provideClientHydration` from `@angular/platform-browser`.",
        "resources": [
          {
            "type": "course",
            "title": "Hydration",
            "url": "https://angular.dev/guide/hydration"
          },
          {
            "type": "course",
            "title": "provideClientHydration",
            "url": "https://angular.dev/api/platform-browser/provideClientHydration"
          },
          {
            "type": "article",
            "title": "Angular Hydration",
            "url": "https://www.bacancytechnology.com/blog/angular-hydration"
          },
          {
            "type": "video",
            "title": "Angular SSR Deep Dive (With Client HYDRATION)",
            "url": "https://www.youtube.com/watch?v=U1MP4uCuUVI"
          }
        ]
      }
    },
    {
      "id": "lLa-OnHV6GzkNFZu29BIT",
      "name": "Testing",
      "resources": {
        "description": "# Testing Angular Apps\n\nIn any software development process, testing the application plays a vital role. If bugs and crashes are not figured out and solved they can defame the development company as well as hurt the clients too. But, Angular’s architecture comes with built-in testability features. As soon as you create a new project with Angular CLI, two essential testing tools are installed. They are: Jasmine and Karma. Jasmine is the testing library which structures individual tests into specifications (“specs”) and suites. And Karma is the test runner, which enables the different browsers to run the tests mentioned by Jasmine and the browsers will finally report the test results back.",
        "resources": [
          {
            "type": "course",
            "title": "Testing Angular Apps",
            "url": "https://angular.dev/guide/testing"
          },
          {
            "type": "course",
            "title": "Jasmine Docs",
            "url": "https://jasmine.github.io/"
          },
          {
            "type": "course",
            "title": "Karma Docs",
            "url": "https://karma-runner.github.io/latest/index.html"
          },
          {
            "type": "article",
            "title": "Testing Angular - A Guide to Robust Angular Applications",
            "url": "https://testing-angular.com/"
          },
          {
            "type": "video",
            "title": "Introduction | Angular Unit Testing Made Easy: A Comprehensive Introduction",
            "url": "https://www.youtube.com/watch?v=emnwsVy8wRs"
          }
        ]
      }
    },
    {
      "id": "HU1eTYB321C93qh_U7ioF",
      "name": "Testing Services",
      "resources": {
        "description": "# Testing Services\n\nTo ensure your services function as expected, you can write dedicated tests for them. Services are typically the easiest files to unit test. You can instantiate the service within a `beforeEach` block, invoke its methods, and assert the results.",
        "resources": [
          {
            "type": "course",
            "title": "Testing Services",
            "url": "https://angular.dev/guide/testing/services"
          },
          {
            "type": "video",
            "title": "Step by Step implementation of the Calculator Service with Jasmine Specification",
            "url": "https://www.youtube.com/watch?v=yoJDYEq8vSs"
          }
        ]
      }
    },
    {
      "id": "rH13NBFG02hnn5eABSNCY",
      "name": "Testing Pipes",
      "resources": {
        "description": "# Testing pipes\n\nAn Angular Pipe is a special function that is called from a Component template. Its purpose is to transform a value: You pass a value to the Pipe, the Pipe computes a new value and returns it.",
        "resources": [
          {
            "type": "course",
            "title": "Testing Pipes",
            "url": "https://angular.dev/guide/testing/pipes"
          },
          {
            "type": "article",
            "title": "Testing Pipes Examples",
            "url": "https://testing-angular.com/testing-pipes/"
          },
          {
            "type": "article",
            "title": "Explore top posts about Testing",
            "url": "https://app.daily.dev/tags/testing?ref=roadmapsh"
          }
        ]
      }
    },
    {
      "id": "4xt0m5jkUqB4Z-krcFBuL",
      "name": "Testing Requests",
      "resources": {
        "description": "# Testing Requests\n\nAs for any external dependency, you must mock the HTTP backend so your tests can simulate interaction with a remote server. The `@angular/common/http/testing` library provides tools to capture requests made by the application, make assertions about them, and mock the responses to emulate your backend's behavior.",
        "resources": [
          {
            "type": "course",
            "title": "Testing Requests",
            "url": "https://angular.dev/guide/http/testing"
          },
          {
            "type": "video",
            "title": "Import Http Client Testing Module and make Test call with the HttpClient",
            "url": "https://www.youtube.com/watch?v=Sgy_RRXC9As"
          },
          {
            "type": "video",
            "title": "HTTP | Angular Unit Testing Made Easy: Comprehensive Guide to HTTP Testing",
            "url": "https://www.youtube.com/watch?v=7rlwryYhGzs"
          }
        ]
      }
    },
    {
      "id": "TGRZBizDy83JKg_MhnRdX",
      "name": "Services with Dependencies",
      "resources": {
        "description": "# Testing services with dependencies\n\nWhen you add a dependency to your service, you must also include it in your tests. For isolated tests, pass an instance of the injectable dependency class into the service’s constructor. Using the `inject` function can add complexity. Injecting the real service is often impractical because dependent services can be difficult to create and control. Instead, mock the dependency, use a dummy value, or create a spy on the relevant service method. By using the TestBed testing utility, you can let Angular’s dependency injection handle service creation and manage constructor argument order.",
        "resources": [
          {
            "type": "course",
            "title": "Testing Services",
            "url": "https://angular.dev/guide/testing/services"
          },
          {
            "type": "article",
            "title": "Testing-Angular.com",
            "url": "https://testing-angular.com/testing-services/"
          },
          {
            "type": "video",
            "title": "Testing the Service which has another service injected through Dependency Injection",
            "url": "https://www.youtube.com/watch?v=ACb8wqwgOV4"
          },
          {
            "type": "video",
            "title": "Testing Services which has HttpClient as dependency by using Jasmine Spy",
            "url": "https://www.youtube.com/watch?v=15othucRXcI"
          },
          {
            "type": "video",
            "title": "Angular Unit Tests with the inject() function",
            "url": "https://www.youtube.com/watch?v=Tvsa4OMUGXs"
          }
        ]
      }
    },
    {
      "id": "cXVy1lx2XqY_j8gxz-y60",
      "name": "Component Bindings",
      "resources": {
        "description": "# Testing component bindings\n\nAngular processes all data bindings once for each JavaScript event cycle, from the root of the application component tree through all child components. Data binding plays an important role in communication between a template and its component, and is also important for communication between parent and child components.",
        "resources": [
          {
            "type": "course",
            "title": "Component",
            "url": "https://angular.dev/guide/components"
          },
          {
            "type": "course",
            "title": "Basics of Testing Components",
            "url": "https://angular.io/guide/testing-components-basics"
          },
          {
            "type": "course",
            "title": "Component Testing Scenarios • Angular",
            "url": "https://angular.dev/guide/testing/components-scenarios"
          },
          {
            "type": "article",
            "title": "Explore top posts about Testing",
            "url": "https://app.daily.dev/tags/testing?ref=roadmapsh"
          }
        ]
      }
    },
    {
      "id": "SGqb5k6OmWit8PA6ZT3js",
      "name": "Testing Directives",
      "resources": {
        "description": "# Testing directives\n\nDirectives are classes that add new behavior or modify the existing behavior to the elements in the template. Basically directives are used to manipulate the DOM, for example adding/removing the element from DOM or changing the appearance of the DOM elements.",
        "resources": [
          {
            "type": "course",
            "title": "Attribute Directives",
            "url": "https://angular.dev/guide/testing/attribute-directives"
          },
          {
            "type": "article",
            "title": "Testing Directives",
            "url": "https://testing-angular.com/testing-directives/"
          },
          {
            "type": "article",
            "title": "Explore top posts about Testing",
            "url": "https://app.daily.dev/tags/testing?ref=roadmapsh"
          }
        ]
      }
    },
    {
      "id": "f5v74Uw54LsB4FgdN6eCd",
      "name": "Debugging Tests",
      "resources": {
        "description": "# Debugging Tests\n\nIf your tests aren't working as you expect them to, you can inspect and debug them in the browser. Be sure to set breakpoints to track your application's execution.",
        "resources": [
          {
            "type": "course",
            "title": "Debugging Tests",
            "url": "https://angular.dev/guide/testing/debugging"
          },
          {
            "type": "course",
            "title": "Devtools",
            "url": "https://angular.dev/tools/devtools"
          },
          {
            "type": "video",
            "title": "Debug Like a Pro: Essential Breakpoint Techniques in Angular",
            "url": "https://www.youtube.com/watch?v=Be9Q1cchurQ"
          },
          {
            "type": "video",
            "title": "Debug Angular 17 Code in VS Code with Break Points and Extensions",
            "url": "https://www.youtube.com/watch?v=r50UXhT9hc0"
          }
        ]
      }
    },
    {
      "id": "0dYWO_Zvh9J5_6cRjRjvI",
      "name": "Component Templates",
      "resources": {
        "description": "# Testing component templates\n\nWith a component template , you can save and reuse component processes and properties and create components from them; template-based components inherit the template's properties and process.",
        "resources": [
          {
            "type": "course",
            "title": "Component Testing Scenarios",
            "url": "https://angular.dev/guide/testing/components-scenarios"
          },
          {
            "type": "article",
            "title": "Explore top posts about Testing",
            "url": "https://app.daily.dev/tags/testing?ref=roadmapsh"
          }
        ]
      }
    },
    {
      "id": "bqA2bxPcZrqQ-6QE-YDK1",
      "name": "Code Coverage",
      "resources": {
        "description": "# Code Coverage\n\nThe Angular CLI can run unit tests and create code coverage reports. Code coverage reports show you any parts of your code base that might not be properly tested by your unit tests.",
        "resources": [
          {
            "type": "course",
            "title": "Code Coverage",
            "url": "https://angular.dev/guide/testing/code-coverage"
          },
          {
            "type": "article",
            "title": "Measuring Code Coverage",
            "url": "https://testing-angular.com/measuring-code-coverage/"
          }
        ]
      }
    },
    {
      "id": "Xxyx3uzy5TpNhgR1IysMN",
      "name": "Internationalization",
      "resources": {
        "description": "# Internationalization\n\nInternationalization, sometimes referenced as i18n, is the process of designing and preparing your project for use in different locales around the world. Localization is the process of building versions of your project for different locales.",
        "resources": [
          {
            "type": "course",
            "title": "Internationalization",
            "url": "https://angular.dev/guide/i18n"
          },
          {
            "type": "article",
            "title": "Angular i18n",
            "url": "https://lokalise.com/blog/angular-i18n/"
          },
          {
            "type": "tutorial",
            "title": "Transloco",
            "url": "https://github.com/jsverse/transloco"
          },
          {
            "type": "tutorial",
            "title": "Ngx Translate",
            "url": "https://github.com/ngx-translate/core"
          },
          {
            "type": "video",
            "title": "Angular 18 Multi-Language Support",
            "url": "https://www.youtube.com/watch?v=hIz0OglmT0Q"
          }
        ]
      }
    },
    {
      "id": "W8OwpEw00xn0GxidlJjdc",
      "name": "Localize Package",
      "resources": {
        "description": "# Localize Package\n\nTo take advantage of the localization features of Angular, use the Angular CLI to add the `@angular/localize` package to your project. If `@angular/localize` is not installed and you try to build a localized version of your project (for example, while using the i18n attributes in templates), the Angular CLI will generate an error, which would contain the steps that you can take to enable i18n for your project.",
        "resources": [
          {
            "type": "course",
            "title": "Add the localize package",
            "url": "https://angular.dev/guide/i18n/add-package"
          },
          {
            "type": "video",
            "title": "Learn to Internationalize Your Angular Apps with @angular/localize",
            "url": "https://www.youtube.com/watch?v=5h7HPY1OMfU"
          },
          {
            "type": "video",
            "title": "Multi-Language Support in Angular: A Guide to Localization and Internationalization",
            "url": "https://www.youtube.com/watch?v=ouI21AyJ9tE"
          }
        ]
      }
    },
    {
      "id": "dVKl3Z2Rnf6IB064v19Mi",
      "name": "Locales by ID",
      "resources": {
        "description": "# Locales by ID\n\nAngular uses the Unicode locale identifier (Unicode locale ID) to find the correct locale data for internationalization of text strings. A locale ID specifies the language, country, and an optional code for further variants or subdivisions. A locale ID consists of the language identifier, a hyphen (-) character, and the locale extension. By default, Angular uses `en-US` as the source locale of your project.",
        "resources": [
          {
            "type": "course",
            "title": "Refer to Locales by ID",
            "url": "https://angular.dev/guide/i18n/locale-id"
          },
          {
            "type": "tutorial",
            "title": "Angular locales",
            "url": "https://github.com/angular/angular/tree/main/packages/common/locales"
          },
          {
            "type": "article",
            "title": "Codes arranged alphabetically by alpha-3/ISO 639-2 Code",
            "url": "https://www.loc.gov/standards/iso639-2/php/code_list.php"
          },
          {
            "type": "article",
            "title": "Unicode CLDR Specifications",
            "url": "https://cldr.unicode.org/index/cldr-spec"
          }
        ]
      }
    },
    {
      "id": "jL5amGV1BAX_V5cyTIH7d",
      "name": "Translation Files",
      "resources": {
        "description": "# Translation Files\n\nAfter you prepare a component for translation, use the `extract-i18n` Angular CLI command to extract the marked text in the component into a source language file. The marked text includes text marked with `i18n`, attributes marked with `i18n`-attribute, and text tagged with `$localize`. The `extract-i18n` command creates a source language file named `messages.xlf` in the root directory of your project.  If you have multiple language files, add the locale to the file name, like `messages.{locale}.xlf`.",
        "resources": [
          {
            "type": "course",
            "title": "Translation Files",
            "url": "https://angular.dev/guide/i18n/translation-files"
          },
          {
            "type": "course",
            "title": "Extract i18n",
            "url": "https://angular.dev/cli/extract-i18n"
          },
          {
            "type": "article",
            "title": "Angular i18n: internationalization & localization with examples",
            "url": "https://lokalise.com/blog/angular-i18n/"
          }
        ]
      }
    },
    {
      "id": "9ISvaaJ815_cr_KW9vQhT",
      "name": "Multiple Locales",
      "resources": {
        "description": "# Multiple Locales\n\nTo deploy an Angular application with multiple locales, follow these steps:\n\n1. Place different versions of your app in locale-specific directories\n2. Use the HTML `<base>` tag with the `href` attribute to set the base URL for relative links.\n3. Deploy each language version in a different subdirectory. Redirect users to their preferred language based on the `Accept-Language` HTTP header.",
        "resources": [
          {
            "type": "course",
            "title": "Deploy Multiple Locales",
            "url": "https://angular.dev/guide/i18n/deploy"
          },
          {
            "type": "video",
            "title": "How Make Multi-Language Angular Websites - Full Guidance On Angular Localization",
            "url": "https://www.youtube.com/watch?v=vSwYuyH4kMA"
          }
        ]
      }
    },
    {
      "id": "rYJq59Q0YdfK6n3x740Em",
      "name": "Animation",
      "resources": {
        "description": "# Animation\n\nAngular's animation system is built on CSS functionality, which means you can animate any property that the browser considers animatable. This includes positions, sizes, transforms, colors, borders, and more.",
        "resources": [
          {
            "type": "course",
            "title": "Animation",
            "url": "https://angular.dev/guide/animations"
          },
          {
            "type": "article",
            "title": "Angular Animations - A Beginner's Guide",
            "url": "https://www.angularminds.com/blog/angular-animations-a-beginners-guide"
          },
          {
            "type": "tutorial",
            "title": "Angular Animations Explorer",
            "url": "https://github.com/williamjuan027/angular-animations-explorer"
          },
          {
            "type": "article",
            "title": "In-Depth guide into animations in Angular",
            "url": "https://angularindepth.com/posts/1285/in-depth-guide-into-animations-in-angular"
          }
        ]
      }
    },
    {
      "id": "Iv2d4sgODqMPzA9gH6RAw",
      "name": "Transitions & Triggers",
      "resources": {
        "description": "# Transitions & Triggers\n\nIn Angular, transition states can be defined explicitly through the `state()` function, or using the predefined `*` wildcard and `void` states. An asterisk `*` or wildcard matches any animation state. This is useful for defining transitions that apply regardless of the HTML element's start or end state. Use the `void` state to configure transitions for an element that is entering or leaving a page.",
        "resources": [
          {
            "type": "course",
            "title": "Transition and Triggers",
            "url": "https://angular.dev/guide/animations/transition-and-triggers"
          },
          {
            "type": "video",
            "title": "Angular Animations: Learn the basics",
            "url": "https://www.youtube.com/watch?v=CGBcIz1tYec"
          },
          {
            "type": "video",
            "title": "How to use trigger function in Angular Animations",
            "url": "https://www.youtube.com/watch?v=3_B4OV5M_Ag"
          }
        ]
      }
    },
    {
      "id": "Unjknmb4b2LY-nUVvvF7_",
      "name": "Complex Sequences",
      "resources": {
        "description": "# Complex Sequences\n\nAngular lets you animate coordinated sequences, such as an entire grid or list of elements as they enter and leave a page. You can choose to run multiple animations in parallel, or run discrete animations sequentially, one following another.\n\nThe functions that control complex animation sequences are:\n\n- `query()`: Finds one or more inner HTML elements.\n- `stagger()`: Applies a cascading delay to animations for multiple elements.\n- `group()`: Runs multiple animation steps in parallel.\n- `sequence()`: Runs animation steps one after another.",
        "resources": [
          {
            "type": "course",
            "title": "Complex Sequences",
            "url": "https://angular.dev/guide/animations/complex-sequences"
          },
          {
            "type": "video",
            "title": "Angular Animations: Animating multiple items in parallel",
            "url": "https://www.youtube.com/watch?v=RPdR7HzNQIw"
          }
        ]
      }
    },
    {
      "id": "M1CU2Yq6dLp4yOuGV0fhF",
      "name": "Reusable Animations",
      "resources": {
        "description": "# Reusable Animations\n\nTo create a reusable animation, use the `animation()` function to define an animation in a separate .ts file and declare this animation definition as a const export variable. You can then import and reuse this animation in any of your application components using the `useAnimation()` function.",
        "resources": [
          {
            "type": "course",
            "title": "Reusable Animations",
            "url": "https://angular.dev/guide/animations/reusable-animations"
          },
          {
            "type": "article",
            "title": "Reusable Animations with Angular",
            "url": "https://catalincodes.com/posts/reusable-animations-with-angular"
          },
          {
            "type": "video",
            "title": "Angular Animations: Creating reusable animations!",
            "url": "https://www.youtube.com/watch?v=ObYCutiBOTo"
          }
        ]
      }
    },
    {
      "id": "x91jWP81oCTeVEwzX8FbK",
      "name": "Route Transitions",
      "resources": {
        "description": "# Route Transitions\n\nWhen a user navigates from one route to another, the Angular router maps the URL path to a relevant component and displays its view. Animating this route transition can greatly enhance the user experience.",
        "resources": [
          {
            "type": "course",
            "title": "Route transition animations",
            "url": "https://angular.dev/guide/animations/route-animations"
          },
          {
            "type": "article",
            "title": "Add Router Animation Transitions for navigation in Angular 17",
            "url": "https://dev.to/this-is-angular/add-router-animation-transitions-for-navigation-in-angular-17-2m5a"
          },
          {
            "type": "video",
            "title": "Angular Animations: Router transitions",
            "url": "https://www.youtube.com/watch?v=7d8UDEKT1pU"
          }
        ]
      }
    }
  ],
  "edges": [
    {
      "source": "",
      "target": "GV_zWF6rSWg5bqgiXhOEf"
    },
    {
      "source": "",
      "target": "GV_zWF6rSWg5bqgiXhOEf"
    },
    {
      "source": "",
      "target": "GV_zWF6rSWg5bqgiXhOEf"
    },
    {
      "source": "iogwMmOvub2ZF4zgg6WyF",
      "target": "DAwKHBng7Tytlcd2_8GOR"
    },
    {
      "source": "DAwKHBng7Tytlcd2_8GOR",
      "target": "KDd40JOAvZ8O1mfhTYB3K"
    },
    {
      "source": "KDd40JOAvZ8O1mfhTYB3K",
      "target": "EbFRcy4s6yzzIApBqU77Y"
    },
    {
      "source": "KDd40JOAvZ8O1mfhTYB3K",
      "target": "hpShWwL0M57ZAzqkB4I8t"
    },
    {
      "source": "KDd40JOAvZ8O1mfhTYB3K",
      "target": "DE3cMpeRYuUPw2ADtfS-3"
    },
    {
      "source": "KDd40JOAvZ8O1mfhTYB3K",
      "target": "zv1y-I1fIEXtTkb8tOQU0"
    },
    {
      "source": "zv1y-I1fIEXtTkb8tOQU0",
      "target": "kGnKzCkQCNFEdgCBRtNuW"
    },
    {
      "source": "kGnKzCkQCNFEdgCBRtNuW",
      "target": "b_kdNS9PDupcUftslkf9i"
    },
    {
      "source": "b_kdNS9PDupcUftslkf9i",
      "target": "6fhe9xAi_RSVfa-KKbcbV"
    },
    {
      "source": "6fhe9xAi_RSVfa-KKbcbV",
      "target": "kGzlumFdZFxTRZ3HnCGFO"
    },
    {
      "source": "kGzlumFdZFxTRZ3HnCGFO",
      "target": "a74v78SvGtWduZpXs7wSq"
    },
    {
      "source": "a74v78SvGtWduZpXs7wSq",
      "target": "CpsoIVoCKaZnM_-BbXbCh"
    },
    {
      "source": "CpsoIVoCKaZnM_-BbXbCh",
      "target": "8u9uHCRt9RU57erBy79PP"
    },
    {
      "source": "CpsoIVoCKaZnM_-BbXbCh",
      "target": "Q36LQds8k_cSjijvXyWOM"
    },
    {
      "source": "Q36LQds8k_cSjijvXyWOM",
      "target": "8UY0HAvjY7bdbFpt-MM1u"
    },
    {
      "source": "8UY0HAvjY7bdbFpt-MM1u",
      "target": "AKPhbg10xXjccO7UBh5eJ"
    },
    {
      "source": "8UY0HAvjY7bdbFpt-MM1u",
      "target": "lfp7PIjwITU5gBITQdirD"
    },
    {
      "source": "lfp7PIjwITU5gBITQdirD",
      "target": "krXA6ua7E3m4IIpFkgQZe"
    },
    {
      "source": "u1TG8i145o0RKhOR_5epf",
      "target": "Mqe_s-nwBqAL6X7OGRHEN"
    },
    {
      "source": "Mqe_s-nwBqAL6X7OGRHEN",
      "target": "m4WBnx_9h01Jl6Q1sxi4Y"
    },
    {
      "source": "EbJib-XfZFF9bpCtL3aBs",
      "target": "jfHaS8TqE4tcAo59K8Nkn"
    },
    {
      "source": "jfHaS8TqE4tcAo59K8Nkn",
      "target": "b-0yQ74zHtAxI9aRLBohc"
    },
    {
      "source": "b-0yQ74zHtAxI9aRLBohc",
      "target": "kauQofxCmpktXPcnzid17"
    },
    {
      "source": "EbJib-XfZFF9bpCtL3aBs",
      "target": "T3MmS3bvMMgCUbOk3ktU7"
    },
    {
      "source": "b-0yQ74zHtAxI9aRLBohc",
      "target": "mm6c7GLQEwoQdAHdAYzGh"
    },
    {
      "source": "mm6c7GLQEwoQdAHdAYzGh",
      "target": "VNG9DdXlS6R1OJ6Lrn4Lt"
    },
    {
      "source": "VNG9DdXlS6R1OJ6Lrn4Lt",
      "target": "0FvH7KPs9ag02QkD1HEJ-"
    },
    {
      "source": "VNG9DdXlS6R1OJ6Lrn4Lt",
      "target": "CZ1YRyai8Ds-ry4A8jVbr"
    },
    {
      "source": "VNG9DdXlS6R1OJ6Lrn4Lt",
      "target": "0s-QhN5aZh2F3tLJFKEyR"
    },
    {
      "source": "VNG9DdXlS6R1OJ6Lrn4Lt",
      "target": "8i_JD1P4gIhY1rdldwLC2"
    },
    {
      "source": "VNG9DdXlS6R1OJ6Lrn4Lt",
      "target": "5-RCB8AiDbkdIFYNXKWge"
    },
    {
      "source": "lLa-OnHV6GzkNFZu29BIT",
      "target": "Xxyx3uzy5TpNhgR1IysMN"
    },
    {
      "source": "Xxyx3uzy5TpNhgR1IysMN",
      "target": "9ISvaaJ815_cr_KW9vQhT"
    },
    {
      "source": "rYJq59Q0YdfK6n3x740Em",
      "target": "x91jWP81oCTeVEwzX8FbK"
    },
    {
      "source": "rYJq59Q0YdfK6n3x740Em",
      "target": "GV_zWF6rSWg5bqgiXhOEf"
    }
  ]
}