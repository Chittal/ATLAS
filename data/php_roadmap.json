{
  "nodes": [
    {
      "id": "_hYN0gEi9BL24nptEtXWU",
      "name": "Introduction to PHP",
      "resources": {
        "description": "# Introduction to PHP\n\nPHP, also known as Hypertext Preprocessor, is a powerful scripting language used predominantly for creating dynamic web pages and applications. It provides seamless interaction with databases, easier control of content, session tracking, and cookies. Being an open-source language, it's favored by developers for its flexibility, speed, and security. \n\nHere's a simple PHP code to print a text: \n\n```php   \n  <?php\n   echo \"Hello, World!\";\n  ?>\n```\n\nHere the \"echo\" command in PHP helps to output one or more strings.",
        "resources": [
          {
            "type": "course",
            "title": "PHP",
            "url": "https://www.php.net/"
          },
          {
            "type": "course",
            "title": "PHP Documentation",
            "url": "https://www.php.net/docs.php"
          },
          {
            "type": "article",
            "title": "PHP Tutorial",
            "url": "https://www.phptutorial.net/"
          },
          {
            "type": "article",
            "title": "Learn PHP Interactively",
            "url": "https://www.learn-php.org/about"
          },
          {
            "type": "video",
            "title": "Introduction to PHP",
            "url": "https://www.youtube.com/watch?v=KBT2gmAfav4"
          },
          {
            "type": "video",
            "title": "PHP Tutorial - Full Course",
            "url": "https://www.youtube.com/watch?v=OK_JCtrrv-c"
          }
        ]
      }
    },
    {
      "id": "b2CuLrhsUNnb4OxI6RRAS",
      "name": "Evolution and History",
      "resources": {
        "description": "# Evolution and History\n\nPHP, originally standing for Personal Home Page, is a popular scripting language used commonly for web development. Rasmus Lerdorf created it in 1994, and since then, it has evolved significantly from a simple set of CGI binaries written in C, to a full-featured language. PHP's journey includes several versions, with PHP 3 introducing a re-written parser and a better approach to object-oriented programming. PHP 8.0, introduced several optimizations, JIT compilation, and union types, among other improvements.",
        "resources": [
          {
            "type": "course",
            "title": "History of PHP",
            "url": "https://www.php.net/history"
          }
        ]
      }
    },
    {
      "id": "6sHRQTcoKL3TlgNJlwyx8",
      "name": "PHP Versions and Features",
      "resources": {
        "description": "# PHP Versions and Features\n\nPHP (Hypertext Preprocessor) versions are critically important as each release comes with new features, improvements, and bug fixes. PHP versions start from PHP 1.0 released in 1995 and have improved over the years. The more recent version as of writing is PHP 8.0, which introduced features like the JIT compiler, named arguments, match expressions, and more. Remember, sticking to officially supported versions, like PHP 7.4 or 8.0, ensures security updates and performance improvements. For instance, the code `echo \"Current PHP version: \" . phpversion();` would tell you the PHP version in use.",
        "resources": [
          {
            "type": "course",
            "title": "Versions and Features",
            "url": "https://www.php.net/manual/en/history.php.php"
          }
        ]
      }
    },
    {
      "id": "_LhLDVZjLt1DoAP1NuUES",
      "name": "What is PHP?",
      "resources": {
        "description": "# What is PHP?\n\nPHP, an acronym for Hypertext Preprocessor, is a popular server-side scripting language favored for web development. It's versatile, dynamic, and can be embedded seamlessly into HTML code. PHP scripts are executed on the server, and the result is sent back to the browser as plain HTML.",
        "resources": [
          {
            "type": "course",
            "title": "What is PHP?",
            "url": "https://www.php.net/manual/en/introduction.php"
          },
          {
            "type": "article",
            "title": "Introduction to PHP",
            "url": "https://www.phptutorial.net/php-tutorial/what-is-php/"
          }
        ]
      }
    },
    {
      "id": "3_TuxOSzBuktBlBF05r_z",
      "name": "Installing PHP",
      "resources": {
        "description": "# Installing PHP\n\nInstalling PHP is an essential process to start developing PHP applications. PHP can be installed on Windows, macOS, and various distributions of Linux. Places to get PHP include the official PHP website, package managers like APT for Linux and Homebrew for macOS, or bundled solutions like XAMPP or WAMP that provide PHP along with a web server and database. After successful installation, you can run a simple PHP script to verify the installation. Here's an example, `<?php echo 'Hello, World!'; ?>`,  which should display \"Hello, World!\" when accessed in a web browser.",
        "resources": [
          {
            "type": "course",
            "title": "Installation Guide",
            "url": "https://www.php.net/manual/en/install.php"
          }
        ]
      }
    },
    {
      "id": "36Y1HkHxhuxh2qVQB8NVE",
      "name": "WAMP",
      "resources": {
        "description": "# WAMP\n\nWAMP is a popular software stack used for developing PHP web applications on Windows systems. Acting as an abbreviation for Windows, Apache, MySQL, and PHP, WAMP provides all the components necessary to set up a local web server. Apache is used to handle HTTP requests, MySQL manages the databases, and PHP serves as the programming language. The benefit of using WAMP lies in its convenience as it pre-packages all these components, saving time for the developer. You can download WAMP from its official website, then after installation, testing of your PHP scripts can be done locally without needing an internet connection.",
        "resources": [
          {
            "type": "course",
            "title": "Windows Installation",
            "url": "https://www.php.net/manual/en/install.windows.manual.php"
          }
        ]
      }
    },
    {
      "id": "-wniKEBwbF0Fi1fHpF-Gc",
      "name": "XAMPP",
      "resources": {
        "description": "# XAMPP\n\nXAMPP is an open-source development environment that stands for Cross-Platform (X), Apache server (A), MariaDB (M), PHP (P), and Perl (P). If you're working with PHP, it's a handy tool because it creates a local web server for testing or development purposes. It's especially useful if you plan to use a database in your project, as it includes MariaDB. It integrates seamlessly with PHP, enabling you to manage your server, scripting language, and database from a unified platform with less hassle. A code sample isn't really applicable here as XAMPP is more about setup and management. For more information, you can visit the official PHP documentation: .",
        "resources": [
          {
            "type": "course",
            "title": "Installing Apache2",
            "url": "https://www.php.net/manual/en/install.windows.apache2.php"
          },
          {
            "type": "course",
            "title": "XAMPP",
            "url": "https://www.apachefriends.org/"
          }
        ]
      }
    },
    {
      "id": "t7p7TU2khaxsZPYAdwFAA",
      "name": "MAMP",
      "resources": {
        "description": "# MAMP\n\nMAMP stands for Macintosh, Apache, MySQL, and PHP. It is a popular software stack that enables developers to run a local server environment. While other technology stacks might be more relevant to different languages or platform-specific development, MAMP is highly beneficial for PHP development. MAMP allows PHP developers to run their code in a localhost environment on their systems, making testing and debugging more straightforward. MAMP bundles all the required software packages (Apache, MySQL, PHP) into one convenient installation, supporting developers in creating a reliable, consistent development environment without tussle. However, as an assistant, I cannot provide a code sample for this topic since it's not directly related to coding in PHP.",
        "resources": [
          {
            "type": "course",
            "title": "MAMP",
            "url": "https://www.mamp.info/en/"
          }
        ]
      }
    },
    {
      "id": "7LjxtrmgJtTJc0_kP83Tr",
      "name": "LAMP",
      "resources": {
        "description": "# LAMP\n\nLAMP refers to the combined use of Linux OS, Apache HTTP Server, MySQL relational database management system, and PHP; it's a popular stack for creating and hosting websites. For PHP, LAMP is a robust, open-source web development platform that supports a wide range of dynamic websites and applications. Suppose you plan to develop a content management system (CMS), forums, or e-commerce shops. In that case, PHP, as a part of the LAMP stack, helps provide a flexible development environment. Here, PHP works hand-in-hand with MySQL to access and manage databases, get queried results, and embed them into HTML pages by the Apache HTTP Server before sending them to the client side.",
        "resources": [
          {
            "type": "course",
            "title": "PHP Lamp",
            "url": "https://www.php.net/manual/en/introduction.php"
          }
        ]
      }
    },
    {
      "id": "hzBUHSuFwLYNooF_vEmrs",
      "name": "Basic PHP Syntax",
      "resources": {
        "description": "# Basic PHP Syntax\n\nPHP syntax is generally considered similar to C-style syntax, where code blocks are defined with curly braces, variables start with a dollar sign ($), and statements end with a semicolon (;), making it relatively easy to learn for programmers familiar with C-like languages; PHP scripts are embedded within HTML using opening tags \"<?php\" and closing tags \"?>\" to mark where PHP code should be executed within a web page.",
        "resources": [
          {
            "type": "course",
            "title": "Basic Syntax",
            "url": "https://www.php.net/manual/en/langref.php"
          }
        ]
      }
    },
    {
      "id": "D0BtyxyjIBcpfn5wP23WC",
      "name": "Variables and Scope",
      "resources": {
        "description": "# Variables and Scope\n\nVariables are a central part of PHP, allowing you to store data that can be used later in your scripts. Their values can be of various types including strings, integers, arrays, and objects. PHP has both local and global scope when it comes to variables. Local scope refers to variables that are only accessible within the function they are defined, while global scope means a variable is accessible to any part of the script. However, to use a global variable inside a function, you need to declare it as global. Here's a brief example: \n\n```php\n$x = 10; //global variable\nfunction test() {\n    global $x; // accessing the global variable\n    echo $x;\n}\ntest(); //prints 10\n```",
        "resources": [
          {
            "type": "course",
            "title": "Variables and Scope",
            "url": "https://www.php.net/manual/en/language.variables.scope.php"
          }
        ]
      }
    },
    {
      "id": "srIHPZabaCGdB5VvUXaMa",
      "name": "Data Types",
      "resources": {
        "description": "# Data Types\n\nPHP is a flexible and widely-used language that supports several types of data. These types include integers, floating-point numbers, strings, arrays, objects, NULL, and many more. The different data types allow developers to efficiently manage and handle data in their applications. For example, an integer data type in PHP can be a non-decimal number between -2,147,483,648 and 2,147,483,647. Here's a small sample PHP code snippet that assigns different data types to variables: \n\n```php\n$text = \"Hello world!\";  // String\n$number = 1234;  // Integer\n$decimalNumber = 12.34;  // Floating-point number\n$boolean = true; // Boolean\n```",
        "resources": [
          {
            "type": "course",
            "title": "Data Types",
            "url": "https://www.php.net/manual/en/language.types.php"
          }
        ]
      }
    },
    {
      "id": "2ykzBBdYhWuM-neGf0AWP",
      "name": "echo",
      "resources": {
        "description": "# echo\n\n'echo' is a language construct in PHP, and it is commonly used to output one or more strings to the browser. This command doesn't behave like a function, hence it doesn't require parentheses unless it's necessary to avoid confusion. It's also worth mentioning that 'echo' also supports multiple parameters. Check out a simple example below where we are using echo to output a simple string:\n\n```php\necho \"Hello, world!\";\n```",
        "resources": [
          {
            "type": "course",
            "title": "echo",
            "url": "https://www.php.net/manual/en/function.echo.php"
          }
        ]
      }
    },
    {
      "id": "NQUmO90sqe7fnzod3Ia8H",
      "name": "print",
      "resources": {
        "description": "# print\n\nThe 'print' statement in PHP is an in-built function used for outputting one or more strings. Unlike 'echo', it is not a language construct and has a return value. However, it is slower because it uses expressions. The text or numeric data that 'print' outputs can be shown directly or stored in a variable. For instance, to print a string you may use `print(\"Hello, World!\");`, and for using it with a variable, `echo $variable;` is suitable.",
        "resources": [
          {
            "type": "course",
            "title": "print",
            "url": "https://www.php.net/manual/en/function.print.php"
          }
        ]
      }
    },
    {
      "id": "JCCeVC0hOrvIeyfg1ScKA",
      "name": "var_dump",
      "resources": {
        "description": "# var_dump\n\nVar_dump is a built-in PHP function that's incredibly handy for debugging as it outputs the data type and value of a given variable. This includes array elements and object properties, if given such types. If you're wrangling with your PHP code and finding your variables aren't behaving as you expect, using var_dump can quickly show you what you're working with. Check out a simple usage example below:\n\n```php\n$myVar = array( \"Hello\", \"World!\");\nvar_dump($myVar);\n```\n\nThis will output the size of array and details of each element in the array.",
        "resources": [
          {
            "type": "course",
            "title": "var_dump",
            "url": "https://www.php.net/manual/en/function.var-dump.php"
          }
        ]
      }
    },
    {
      "id": "wsC7OGXOyfCY4pLLNrR2v",
      "name": "print_r",
      "resources": {
        "description": "# print_r\n\nThe print_r function in PHP is used to print human-readable information about a variable, ranging from simple values to more complex, multi-dimensional arrays and objects. It's exceptionally helpful while debugging, providing more information about the variable's contents than the echo or print functions. For example, in the code `$array = array('apple', 'banana', 'cherry'); print_r($array);`, it will display Array ( [0] => apple [1] => banana [2] => cherry ).",
        "resources": [
          {
            "type": "course",
            "title": "print_r",
            "url": "https://www.php.net/manual/en/function.print-r.php"
          }
        ]
      }
    },
    {
      "id": "pzReF4C0mcCWAnpfIJbwl",
      "name": "Casting Data Types",
      "resources": {
        "description": "# Casting Data Types\n\nPHP, as a loose typing language, allows us to change the type of a variable or to transform an instance of one data type into another. This operation is known as Casting. When to use casting, however, depends on the situation - it is recommendable when you want explicit control over the data type for an operation. The syntax involves putting the intended type in parentheses before the variable. For example, if you wanted to convert a string to an integer, you'd use: `$myVar = \"123\"; $intVar = (int) $myVar;`. Here, `$intVar` would be an integer representation of `$myVar`. Remember, the original variable type remains unchanged. \n\nHere's an example of type casting in PHP:\n\n```php\n<?php\n$foo = 10;   // $foo is an integer\n$bar = (bool) $foo;   // $bar is a boolean\n?>\n```",
        "resources": [
          {
            "type": "course",
            "title": "Type Casting",
            "url": "https://www.php.net/manual/en/language.types.type-juggling.php"
          }
        ]
      }
    },
    {
      "id": "IhKjvT6CjRz4dsSU7SNQo",
      "name": "Arrays",
      "resources": {
        "description": "# Arrays\n\nArrays in PHP are fundamental data structures that store multiple elements in a particular key-value pair collection. PHP offers extensive support for arrays, making them convenient for storing sets of data or complex collections.",
        "resources": [
          {
            "type": "course",
            "title": "Arrays",
            "url": "https://www.php.net/manual/en/language.types.array.php"
          }
        ]
      }
    },
    {
      "id": "j2S8dP3HlAOOoZdpj-7Dx",
      "name": "Indexed Arrays",
      "resources": {
        "description": "# Indexed Arrays\n\nIndexed arrays in PHP store values that are accessed through numerical indexes, which start at 0 by default. This might be particularly useful when you have a list of items in a specific order. For example, you might use an indexed array to represent a list of your favorite books, where each book is numbered starting from 0. Each individual item in the array, book in this case, can be accessed by their specific index. You can use the array() function or the short array syntax [] to declare an indexed array.\n\nHere's an Example:\n\n```php\n$books = [\"The Great Gatsby\", \"Moby Dick\", \"To Kill a Mockingbird\"];\necho $books[0]; //Outputs \"The Great Gatsby\"\n```",
        "resources": [
          {
            "type": "course",
            "title": "Indexed Arrays",
            "url": "https://www.php.net/manual/en/language.types.array.php"
          }
        ]
      }
    },
    {
      "id": "i_NRsOJNNp7AOqMgu5Jg8",
      "name": "Associative Arrays",
      "resources": {
        "description": "# Associative Arrays\n\nAssociative arrays in PHP are a type of array that uses named keys instead of numeric ones. This provides a more human-readable way to store data where each value can be accessed by its corresponding string key. An example of an associative array could be storing names as keys and their corresponding ages as values. Here's a brief example:\n\n```php\n$ages = [\n   \"Peter\" => 35,\n   \"John\" => 42,\n   \"Mary\" => 27\n];\n```\n\nIn this case, to find out John's age, you would simply use `echo $ages['John']` where 'John' is the key. Associative arrays are also easy to loop through using the `foreach` construct.",
        "resources": [
          {
            "type": "course",
            "title": "PHP Documentation - Associative Arrays",
            "url": "https://www.php.net/manual/en/language.types.array.php"
          }
        ]
      }
    },
    {
      "id": "uARTOZ-ZwugSmbCJoRS5Y",
      "name": "Multi-dimensional Arrays",
      "resources": {
        "description": "# Multi-dimensional Arrays\n\nMulti-dimensional arrays in PHP are a type of array that contains one or more arrays. Essentially, it's an array of arrays. This allows you to store data in a structured manner, much like a table or a matrix. The fundamental idea is that each array value can, in turn, be another array. For instance, you can store information about various users, where each user (a primary array element) contains several details about them (in a secondary array like email, username etc.).\n\nHere's an example:\n\n```php\n$users = [\n       [\"John\", \"john@example.com\", \"john123\"],\n       [\"Jane\", \"jane@example.com\", \"jane123\"],\n       [\"Doe\", \"doe@example.com\", \"doe123\"]\n];\n```",
        "resources": [
          {
            "type": "course",
            "title": "Multi-dimensional Arrays",
            "url": "https://www.php.net/manual/en/language.types.array.php"
          }
        ]
      }
    },
    {
      "id": "38YksjvhXCbgnHqkl57Cz",
      "name": "Conditionals",
      "resources": {
        "description": "# Conditionals\n\nConditionals in PHP, much like in other programming languages, allow for branching in code, meaning your program can choose to execute specific parts of code based on the state of variables or expressions. The most common conditional statements in PHP are \"if\", \"else\", and \"elseif\".",
        "resources": [
          {
            "type": "course",
            "title": "Control Structures",
            "url": "https://www.php.net/manual/en/language.control-structures.php"
          }
        ]
      }
    },
    {
      "id": "-McOv-ZPTGayX7Mx2Thw1",
      "name": "if/else",
      "resources": {
        "description": "# if/else\n\nIn PHP, the if/else conditional statements are fundamental components that control the flow of the program based on specific conditions. When the 'if' condition is true, a block of code will execute. If that condition is not met (or false), the program proceeds to the 'else' statement (if provided), executing its block of code. This allows you to handle different situations dynamically. A simple example of this concept in action would be:\n\n```php\n$number = 10;\nif ($number > 5) {\n    echo \"The number is greater than 5\";\n} else {\n    echo \"The number is not greater than 5\";\n}\n```\n\nIn this example, the output will be \"The number is greater than 5\" because the condition evaluated to true.",
        "resources": [
          {
            "type": "course",
            "title": "if-else",
            "url": "https://www.php.net/manual/en/control-structures.elseif.php"
          }
        ]
      }
    },
    {
      "id": "bgJ9-m6Fiu3VCc-NZlbpn",
      "name": "switch",
      "resources": {
        "description": "# switch\n\nThe switch statement is a special conditional statement in PHP that can simplify code and improve readability when you need to compare one value with multiple different possibilities. It is an alternative to using a chain of \"if...else\" conditions, and is particularly useful when you have many different cases to compare. The switch expression is evaluated only once, and its value is compared to each case. When a match is found, PHP executes the associated code block. \n\nHere's a basic switch statement:\n\n```php\n$fruit = \"apple\";\nswitch ($fruit) {\n  case \"apple\":\n    echo \"You chose apple.\";\n    break;\n  case \"banana\":\n    echo \"You chose banana.\";\n    break;\n  default:\n    echo \"Invalid choice.\";\n}\n// Outputs: You chose apple.\n```\n\nSwitch statements can make your code cleaner and easier to manage, especially when dealing with multiple conditions.",
        "resources": [
          {
            "type": "course",
            "title": "switch",
            "url": "https://www.php.net/manual/en/control-structures.switch.php"
          }
        ]
      }
    },
    {
      "id": "3gNzX-bw2iqur7U7-_W38",
      "name": "match",
      "resources": {
        "description": "# match\n\nMatch expressions are an integral feature of PHP, introduced in PHP 8.0 as an alternative to the switch statement. Compared to the switch statement, match expressions are safer since they don't require break statements and are more concise. The match expression can be an excellent tool for pattern matching. Here's an example:\n\n```php\n$message = match ($statusCode) {\n  200, 300 => 'OK',\n  400 => 'error',\n  default => 'unknown status code',\n};\n```\nIn this code, based on the value of `$statusCode`, the `match` expression assigns a specific text to the `$message`. If `$statusCode` is not 200, 300, or 400, the `default` case applies. After running the code, the `$message` variable contains the result of the `match` expression.",
        "resources": [
          {
            "type": "course",
            "title": "match",
            "url": "https://www.php.net/manual/en/control-structures.match.php"
          }
        ]
      }
    },
    {
      "id": "w0ntgFBhgGd5RUFd-qlPK",
      "name": "Null Coalescing Operator",
      "resources": {
        "description": "# Null Coalescing Operator\n\nThe Null Coalescing Operator (??) in PHP is a simple and useful tool for handling variables that might not be set. It allows developers to provide a default value when the variable happens not to have a value. It is similar to the ternary operator, but instead of checking whether a variable is true or false, it checks if it is set or null. This makes it a handy tool for handling optional function arguments or form inputs. Here's an example: `$username = $_POST['username'] ?? 'Guest';`. In this line, if 'username' was set in the POST array, $username will be set to that value. If not, it will be set to 'Guest'.",
        "resources": [
          {
            "type": "course",
            "title": "Null Coalescing Operator",
            "url": "https://www.php.net/manual/en/migration70.new-features.php#migration70.new-features.null-coalesce-op"
          }
        ]
      }
    },
    {
      "id": "1NXSk8VZDr89jQTTkOL7x",
      "name": "Null Safe Operator",
      "resources": {
        "description": "# Null Safe Operator\n\nThe Null Safe Operator is a handy feature in PHP which deals with an issue that often pops up when working with objects: trying to access properties or methods on an object that might be null. Instead of a fatal error, the PHP Null Safe Operator (indicated by ?->) allows null values to be returned safely, making your code more robust. Here's a quick example, consider $session?->user?->name. If $session or user is null, PHP will stop further execution and simply return null. This makes PHP more resilient when processing unpredictable data.",
        "resources": [
          {
            "type": "course",
            "title": "The Basics - Manual",
            "url": "https://www.php.net/manual/en/language.oop5.basic.php"
          },
          {
            "type": "course",
            "title": "PHP RFC: Nullsafe operator",
            "url": "https://wiki.php.net/rfc/nullsafe_operator"
          }
        ]
      }
    },
    {
      "id": "qwt8xN4vuTrY-D0czYITI",
      "name": "Loops",
      "resources": {
        "description": "# Loops\n\nPHP incorporates the use of loops, which are a vital part of programming. They allow a block of code to be executed repeatedly based on a certain condition or until a specific condition is met. In PHP, there are four types of loops - 'while', 'do-while', 'for' and 'foreach'. The 'while' loop continues executing its nested code as long as the condition remains true. The 'do-while' loop executes a block of code at least once, and then either continues executing it or stops, based on the condition. The 'for' loop is often used when the number of iterations is known. The 'foreach' loop works with arrays and is used to loop through each key/value pair in an array. Here's a simple example of a 'for' loop in PHP:\n\n```php\n<?php\nfor ($i = 0; $i < 5; $i++) {\n    echo $i;\n}\n?>\n```\n\nIn this example, the loop will execute five times, with $i increasing by one each time, outputting the numbers from 0 to 4.",
        "resources": [
          {
            "type": "course",
            "title": "Loops",
            "url": "https://www.php.net/manual/en/language.control-structures.php"
          }
        ]
      }
    },
    {
      "id": "VLRLymQmLfscrBfzXKvHi",
      "name": "Constants",
      "resources": {
        "description": "# Constants\n\nConstants in PHP are fixed values that do not change during the execution of the script. They can be handy for values that need to be reused often like a website's URL, a company's name, or even a hardcoded database connection string. Unlike variables, once a constant is defined, it cannot be undefined or reassigned. Constants are case-sensitive by default but this can be overridden. They are defined using the define() function or the const keyword. For instance, you can create a constant to hold the value of Pi and call it in your script like this:\n\n```php\ndefine(\"PI\", 3.14);\necho PI; // Outputs: 3.14\n```",
        "resources": [
          {
            "type": "course",
            "title": "Constants",
            "url": "https://www.php.net/manual/en/language.constants.php"
          }
        ]
      }
    },
    {
      "id": "WiGv7vi7Mtw-YqPMcnnyw",
      "name": "Functions",
      "resources": {
        "description": "# Functions\n\nFunctions in PHP are self-contained blocks of code that carry out specific tasks and can be reused throughout your application. A function is defined with the word \"function\" followed by a name, and it should return a value using the \"return\" statement. To use a function, you simply need to call it by its name. You can also pass parameters to functions to influence how they work. Here's a simple function:\n\n```php\nfunction greet($name) {\n    return \"Hello, \" . $name;\n}\n\necho greet(\"John\"); // Outputs: Hello, John\n```\n\nIn the code above, \"greet\" is a function that takes one parameter \"name\". It concatenates \"Hello, \" with the name and returns the result.",
        "resources": [
          {
            "type": "course",
            "title": "Functions",
            "url": "https://www.php.net/manual/en/language.functions.php"
          }
        ]
      }
    },
    {
      "id": "1nODJchgSuWbcvSlxnWeE",
      "name": "Function Declaration",
      "resources": {
        "description": "# Function Declaration\n\nFunction is the block of code that performs a specific task. It is a reusable code that can be called multiple times. In PHP, a function is declared using the `function` keyword followed by the function name and parentheses. The function name should be unique and descriptive. The parentheses may contain parameters that are passed to the function. The function body is enclosed within curly braces `{}`.\n\n```php\nfunction greeting($name) {\n    echo \"Hello, \" . $name;\n}\n```\n\nIn this case, 'greeting' is the function name, '$name' is the parameter, and 'echo \"Hello, \" . $name;' is the operation.",
        "resources": [
          {
            "type": "course",
            "title": "User Defined Functions",
            "url": "https://www.php.net/manual/en/functions.user-defined.php"
          }
        ]
      }
    },
    {
      "id": "mpQKoBzsOa-5iWo08sOhQ",
      "name": "Parameters / Return Values",
      "resources": {
        "description": "# Parameters / Return Values\n\nParameters in PHP functions specify the input that the function expects to receive when it is called. They can be of various types like strings, integers, arrays, or even objects. PHP also supports default values for parameters and passing by reference. In PHP, the 'return' statement is often used to end the execution of a function and send back a value. Return values can be any data type. Here's a simple example:\n\n```php\nfunction addNumbers($num1, $num2) {\n  $sum = $num1 + $num2;\n  return $sum;\n}\n\necho addNumbers(3, 4);  // Outputs: 7\n```\n\nIn the above code, `$num1` and `$num2` are parameters, and the sum of these numbers is the return value.",
        "resources": [
          {
            "type": "course",
            "title": "Parameters / Return Values",
            "url": "https://www.php.net/manual/en/functions.arguments.php"
          }
        ]
      }
    },
    {
      "id": "RgVP99rJJ8FVecIA45w20",
      "name": "Default / Optional Params",
      "resources": {
        "description": "# Default / Optional Params\n\nIn PHP, you can assign default values to your function parameters. These are called default or optional parameters. This is exceptionally useful when you want to make the function argument optional so if a value is not provided when the function is called, then the default value is used instead. Here's a simple code example:\n\n```php\nfunction greet($name = \"guest\") {\n  echo \"Hello, $name!\";\n}\n\ngreet(); // Outputs: Hello, guest!\ngreet(\"John\"); // Outputs: Hello, John!\n```\n\nIn this example, the `greet` function has a default value of \"guest\" for the `$name` parameter. So, if no argument is given while calling `greet`, it defaults to greet a \"guest\". If an argument is provided, like `John`, it overrides the default value.\n\n- [@official@Default Parameters](https://www.php.net/manual/en/functions.arguments.php#functions.arguments.default)",
        "resources": [
          {
            "type": "course",
            "title": "Default Parameters",
            "url": "https://www.php.net/manual/en/functions.arguments.php#functions.arguments.default"
          }
        ]
      }
    },
    {
      "id": "RkNjYva8o_jXp9suz5YdG",
      "name": "Named Arguments",
      "resources": {
        "description": "# Named Arguments\n\nNamed arguments in PHP, introduced with PHP 8.0, allow you to specify the values of required parameters by their names, instead of their position in the function call, thus making your code more readable, reducing mistakes, and allowing for unimportant arguments to be skipped. Here's an array_fill() function using named arguments:\n\n```php\n<?php\n$a = array_fill(start_index: 0, count: 100, value: 50);\n```\n\nIn this code snippet, the parameters are passed by their names ('start_index', 'count', 'value'), not by their order in the function definition.",
        "resources": [
          {
            "type": "course",
            "title": "Named Arguments",
            "url": "https://www.php.net/manual/en/functions.arguments.php#functions.named-arguments"
          }
        ]
      }
    },
    {
      "id": "Nr5m6wQLp7VyG3AucrSc8",
      "name": "Anonymous Functions",
      "resources": {
        "description": "# Anonymous Functions\n\nAnonymous functions in PHP, also known as closures, are functions that do not have a specified name. They are most frequently used as a value for callback parameters, but can be used in many other ways. When creating an anonymous function, you can also inherit variables from the parent scope. Here's a basic usage example:\n\n```php\n$greet = function($name)\n{\n    printf(\"Hello %s\\r\\n\", $name);\n};\n\n$greet('World');\n$greet('PHP');\n```\n\nIn this example, we're creating an anonymous function and assigning it to the variable `$greet`. We then call this anonymous function using $greet with 'World' and 'PHP' as arguments.",
        "resources": [
          {
            "type": "course",
            "title": "Anonymous Functions",
            "url": "https://www.php.net/manual/en/functions.anonymous.php"
          }
        ]
      }
    },
    {
      "id": "mP1BIkqbWVVTU-zZv1ZL6",
      "name": "Arrow Functions",
      "resources": {
        "description": "# Arrow Functions\n\nArrow functions provide a more concise syntax to create anonymous functions. The feature enthusiastically borrowed from modern Javascript significantly improves PHP's functional programming credibility. The primary difference between regular PHP closures and PHP Arrow functions is the automatic capturing of variables from the parent scope.",
        "resources": [
          {
            "type": "course",
            "title": "Arrow Functions",
            "url": "https://www.php.net/manual/en/functions.arrow.php"
          }
        ]
      }
    },
    {
      "id": "x7hA2KAzJIjc-prgCEw6V",
      "name": "Callback Functions",
      "resources": {
        "description": "# Callback Functions\n\nA callback function in PHP is a function that is passed as an argument to another function. The receiving function can then invoke this function as needed. Callback functions are often used to define flexible or reusable code because they allow you to customize the behavior of a function without changing its structure.",
        "resources": [
          {
            "type": "course",
            "title": "Callback Functions",
            "url": "https://www.php.net/manual/en/language.types.callable.php"
          }
        ]
      }
    },
    {
      "id": "D9ybK5INH5zSOcYMb5ZPi",
      "name": "Recursion",
      "resources": {
        "description": "# Recursion\n\nRecursion, as it applies to PHP, refers to a function that calls itself to solve a problem. A recursive function distinguishes itself by solving small parts of the problem until it resolves the main issue. Think of it as breaking down a task into smaller tasks that are easier to solve. However, careful design is needed to ensure the recursive function has a clear stopping point, or else it can result in an infinite loop. Here's a quick example of a simple recursive function in PHP:\n\n```php\nfunction countDown($count) {\n    echo $count;\n    if($count > 0) {\n        countDown($count - 1);\n    }\n}\ncountDown(5);\n```\n\nIn this example, the function `countDown` calls itself until the count hits zero, displaying numbers from 5 to 0.",
        "resources": [
          {
            "type": "course",
            "title": "Functions - Recursion",
            "url": "https://www.php.net/manual/en/language.functions.php"
          }
        ]
      }
    },
    {
      "id": "rtmytETfyyLdcXUC0QyzL",
      "name": "Variadic Functions",
      "resources": {
        "description": "# Variadic Functions\n\nVariadic functions in PHP are functions that can accept any number of arguments. This gives you greater flexibility, as it allows for an undetermined number of arguments. You can create a variadic function by adding '...' before the function argument. Any number of arguments you provide when calling the function are treated as an array, which can be processed using common array functions. \n\nA simple code example: \n\n```php\nfunction sum(...$numbers) {\n    return array_sum($numbers);\n}\necho sum(1, 2, 3, 4);\n``` \n\nThis prints \"10\". The function accepts any number of arguments and adds them together.",
        "resources": [
          {
            "type": "course",
            "title": "Variadic Functions",
            "url": "https://www.php.net/manual/en/functions.arguments.php#functions.variable-arg-list"
          }
        ]
      }
    },
    {
      "id": "Kaaqu-mN7xvHN6CbIn616",
      "name": "require",
      "resources": {
        "description": "# require\n\nThe 'require' statement is a built-in feature of PHP used to include and evaluate a specific file while executing the code. This is a crucial part of file handling in PHP because it enables the sharing of functions, classes, or elements across multiple scripts, promoting code reusability and neatness. Keep in mind, if the required file is missing, PHP will produce a fatal error and stop the code execution. The basic syntax is `require 'filename';`.",
        "resources": [
          {
            "type": "course",
            "title": "require",
            "url": "https://www.php.net/manual/en/function.require.php"
          }
        ]
      }
    },
    {
      "id": "-CyJbsg2ho3RvfzKnJj5C",
      "name": "require_once",
      "resources": {
        "description": "# require_once\n\nPHP uses the 'require_once' statement as an efficient way to include a PHP file into another one. There's an interesting quirk to this function: PHP checks if the file was previously included, and if so, it doesn't include the file again. This helps avoid problems with redundant function declarations, variable value reassignments, or coding loops. However, do remember that 'require_once' is distinct from 'include_once'. The key difference lies in error handling: if the file specified in 'require_once' cannot be found, PHP will emit a fatal error and halt script execution. Whereas, 'include_once', will only generate a warning. \n\nHere's how you can utilize 'require_once': \n\n```php\n<?php\nrequire_once('somefile.php');\n?>\n```\n\nThis code fetches all the functions and codes from 'somefile.php' and includes them in the current file.",
        "resources": [
          {
            "type": "course",
            "title": "require_once",
            "url": "https://www.php.net/manual/en/function.require-once.php"
          }
        ]
      }
    },
    {
      "id": "hKfv7V6bl2LXssq9Ffi7C",
      "name": "include",
      "resources": {
        "description": "# include\n\nThe 'include' statement in PHP is a useful method for inserting code written in one file into another. It's mainly used when the same code needs to be used in multiple files, avoiding redundancy and making code maintenance easier. If it cannot find the file, PHP will emit a warning but continue to execute the rest of the script. Here's a simple example:\n\n```php\n<?php\n    include 'filename.php';\n?>\n```\n\nIn this code snippet, 'filename.php' is the file containing the code that you want to insert. Just replace 'filename.php' with the actual file path you want to include.",
        "resources": [
          {
            "type": "course",
            "title": "include",
            "url": "https://www.php.net/manual/en/function.include.php"
          }
        ]
      }
    },
    {
      "id": "SwtLDgyPmDry20qS4FBfH",
      "name": "include_once",
      "resources": {
        "description": "# include_once\n\nThe `include_once` statement is a part of PHP's file-handling toolkit, allowing developers to include a PHP file within another PHP file, but only for a one-time execution. This way, you can ensure that functions or objects defined in the included file are not duplicated leading to errors. It helps keep your code DRY (Don't Repeat Yourself) and clean. Here is a small example:\n\n```php\ninclude_once 'database.php';\n\n$db = new Database();\n```\n\nIn this simple code snippet, we include the `database.php` file once, giving us access to the `Database` class.",
        "resources": [
          {
            "type": "course",
            "title": "include_once",
            "url": "https://www.php.net/manual/en/function.include-once.php"
          }
        ]
      }
    },
    {
      "id": "two4UycJaCfSp6jQqtTAb",
      "name": "Writing Files",
      "resources": {
        "description": "# Writing Files\n\nWriting files plays a crucial part in PHP, allowing you to store data and modify it later. This process involves opening the file, writing the desired data, and then closing it. Writing can be done using different functions, but `fwrite()` is the most commonly used one. It requires two arguments the file pointer and the string of data to be written. Here's a brief snippet of code for instance:\n\n```php\n$file = 'data.txt';\n$current = file_get_contents($file);\n$current .= \"New Data\\n\";\nfile_put_contents($file, $current);\n```\n\nIn this code, `file_get_contents()` is used to get the current data, then new data is appended, and `file_put_contents()` is used to write back to the file.",
        "resources": [
          {
            "type": "course",
            "title": "Writing Files",
            "url": "https://www.php.net/manual/en/function.fwrite.php"
          }
        ]
      }
    },
    {
      "id": "S9wTlkbv9-R6dohhZ47hs",
      "name": "Reading Files",
      "resources": {
        "description": "# Reading Files\n\nReading files is a common task in PHP and it provides a range of functions for this purpose. You can use the `fopen()` function with the 'r' mode to open a file for reading. The `fgets()` function lets you read a file line by line, while `fread()` reads a specified number of bytes. For reading the entire file in one go, use `file_get_contents()`. Remember to always close the file after you're done with `fclose()`. \n\nHere's a small example using `fgets()`:\n\n```php\n$file = fopen(\"example.txt\", \"r\"); \nif ($file) {\n    while (($line = fgets($file)) !== false) {\n        echo $line;\n    }\n    fclose($file);\n} else {\n    echo 'Error opening file';\n}\n```",
        "resources": [
          {
            "type": "course",
            "title": "Filesystem Operations",
            "url": "https://www.php.net/manual/en/book.filesystem.php"
          }
        ]
      }
    },
    {
      "id": "tgIyG6vHWpe9sz6lHmj5a",
      "name": "File Permissions",
      "resources": {
        "description": "# File Permissions\n\nFile permissions in PHP control who can read, write, and execute a file. They're crucial for the security and proper functioning of your PHP applications. When working with files, you can use functions like `chmod()`, `is_readable()`, and `is_writable()` to manage permissions. Typically, you would use `chmod()` to change the permissions of a file. The first parameter is the name of the file and the second parameter is the mode. For instance, `chmod($file, 0755)` would assign owner permissions to read, write, and execute, while everyone else would only have read and execute permissions. To know if a file is readable or writable, use `is_readable()` or `is_writable()` respectively.",
        "resources": [
          {
            "type": "course",
            "title": "Filesystem Functions",
            "url": "https://www.php.net/manual/en/ref.filesystem.php"
          }
        ]
      }
    },
    {
      "id": "DB2cxZE58WCCavW2PNwmf",
      "name": "JSON Processing",
      "resources": {
        "description": "# JSON Processing\n\nJSON Processing in PHP refers to the handling, reading, and manipulation of JSON formatted data. JSON, or JavaScript Object Notation, is a versatile data format used worldwide due to its easy readability and robustness. PHP natively supports JSON and includes built-in functions like `json_encode()` and `json_decode()`. The `json_encode()` function returns a JSON representation of a value, particularly useful when you need to pass arrays or objects to a script. On the other hand, `json_decode()` is used to extract data from a JSON file or a JSON-encoded string, converting it into a PHP variable. Here's a quick example: \n\n```php\n// Create an array\n$data = array('a' => 1, 'b' => 2, 'c' => 3);\n\n// Encode the array into a JSON string\n$json = json_encode($data);\necho $json;\n\n// Output: {\"a\":1,\"b\":2,\"c\":3}\n\n// Decode the JSON string back into an array\n$decoded = json_decode($json, true);\nprint_r($decoded);\n\n// Output: Array ( [a] => 1 [b] => 2 [c] => 3 )\n```",
        "resources": [
          {
            "type": "course",
            "title": "JSON Manual",
            "url": "https://www.php.net/manual/en/book.json.php"
          }
        ]
      }
    },
    {
      "id": "MRDjEjbkMpk7shcWAoPOF",
      "name": "CSV Processing",
      "resources": {
        "description": "# CSV Processing\n\nCSV processing refers to handling CSV (Comma Separated Values) files in PHP, an operation significantly useful for managing tabular data. PHP provides a few key functions to handle CSV files effectively. For example, `fgetcsv()` allows you to read CSV file line by line, `fputcsv()` lets you write line by line into a CSV file, and `str_getcsv()` allows you to parse a CSV string into an array. A quick example of reading a CSV file:\n\n```php\nif (($handle = fopen(\"sample.csv\", \"r\")) !== FALSE) {\n    while (($data = fgetcsv($handle, 1000, \",\")) !== FALSE) {\n        print_r($data);\n    }\n    fclose($handle);\n}\n```\n\nIn this snippet, PHP reads through each line of the `sample.csv` file, converting each into an array with `fgetcsv()`.",
        "resources": [
          {
            "type": "course",
            "title": "CSV Processing",
            "url": "https://php.net/manual/en/ref.fileinfo.php"
          }
        ]
      }
    },
    {
      "id": "ggkWo0DRSSDDkHpbiyUyf",
      "name": "XML Processing",
      "resources": {
        "description": "# XML Processing\n\nXML processing in PHP allows manipulation and interpretation of XML documents. PHP's XML Parser extension helps to parse XML data from strings and files, providing event-driven processing capabilities. This is especially useful during large XML parsing. To process XML in PHP, you first create an XML parser, set functionality through handler functions for the start and end of elements, character data, etc., and then parse the XML data. The `xml_parser_create()`, `xml_set_element_handler()`, `xml_parse()`, and `xml_parser_free()` functions come into play here. Here's a brief snippet showing XML parsing in PHP:\n\n```php\n$parser = xml_parser_create();\nxml_set_element_handler($parser, \"startElement\", \"endElement\");\nxml_parse($parser, $xml_data);\nxml_parser_free($parser);\n```",
        "resources": [
          {
            "type": "course",
            "title": "XML Processing",
            "url": "https://www.php.net/manual/en/book.xml.php"
          }
        ]
      }
    },
    {
      "id": "tn_iIfaJZVtPK6vFds7FH",
      "name": "HTTP Methods",
      "resources": {
        "description": "# HTTP Methods\n\nPHP allows for handling HTTP methods, which are a way of defining the action to be performed on the resource identified by a given URL. In PHP, the $_SERVER superglobal array can be used to identify the HTTP method of a specific request, typically a GET, POST, PUT, DELETE or HEAD. For example, to identify if a request is a POST request, you can use `if ($_SERVER['REQUEST_METHOD'] == 'POST') { // your code here }`. More advanced handling can be done by utilizing built-in PHP libraries or third-party packages.",
        "resources": [
          {
            "type": "course",
            "title": "HTTP Methods",
            "url": "https://www.php.net/manual/en/reserved.variables.server.php"
          }
        ]
      }
    },
    {
      "id": "GFYGFVfxkOoPI5mI4zSt1",
      "name": "$_GET",
      "resources": {
        "description": "# $_GET\n\n$_GET is a pre-defined array in PHP, that's used to collect form-data sent through HTTP GET method. It's useful whenever you need to process or interact with data that has been passed in via a URL's query string. For an example if you have a form with a GET method, you can get the values of the form elements through this global $_GET array. Heres an example: \n\n```html\n<form method=\"get\" action=\"test.php\">\n  Name: <input type=\"text\" name=\"fname\">\n  <input type=\"submit\">\n</form>\n```\n\nUsing $_GET in `test.php`, you can fetch the 'fname' value from the URL:\n\n```php\necho \"Name is: \" . $_GET['fname'];\n```",
        "resources": [
          {
            "type": "course",
            "title": "$_GET",
            "url": "https://www.php.net/manual/en/reserved.variables.get.php"
          }
        ]
      }
    },
    {
      "id": "qNG-a4iIO-puZsMwAMzYC",
      "name": "$_POST",
      "resources": {
        "description": "# $_POST\n\n`$_POST` is a superglobal variable in PHP that's used to collect form data submitted via HTTP POST method. Your PHP script can access this data through `$_POST`. Let's say you have a simple HTML form on your webpage. When the user submits this form, the entered data can be fetched using `$_POST`. Here's a brief example:\n\n```php\n<?php\nif ($_SERVER[\"REQUEST_METHOD\"] == \"POST\") {\n    $name = $_POST[\"name\"];\n}\n?>\n```\n\nIn this code, `$_POST[\"name\"]` fetches the value entered in the 'name' field of the form. Always be cautious when using `$_POST` as it may contain user input which is a common source of vulnerabilities. Always validate and sanitize data from `$_POST` before using it.",
        "resources": [
          {
            "type": "course",
            "title": "$_POST",
            "url": "https://www.php.net/manual/en/reserved.variables.post.php"
          }
        ]
      }
    },
    {
      "id": "A6rfW4uJhyfAX2b18_EEC",
      "name": "$_REQUEST",
      "resources": {
        "description": "# $_REQUEST\n\n$_REQUEST is a PHP superglobal variable that contains the contents of both $_GET, $_POST, and $_COOKIE. It is used to collect data sent via both the GET and POST methods, as well as cookies. $_REQUEST is useful if you do not care about the method used to send data, but its usage is generally discouraged as it could lead to security vulnerabilities. Here's a simple example:\n\n```php\n$name = $_REQUEST['name'];\n```\n\nThis statement will store the value of the 'name' field sent through either a GET or POST method. Always remember to sanitize user input to avoid security problems.",
        "resources": [
          {
            "type": "course",
            "title": "$_REQUEST",
            "url": "https://www.php.net/manual/en/reserved.variables.request.php"
          }
        ]
      }
    },
    {
      "id": "7Ja2at_N9tRTlvSGahrqn",
      "name": "$_SERVER",
      "resources": {
        "description": "# $_SERVER\n\nThe `$_SERVER` is a superglobal in PHP, holding information about headers, paths, and script locations. $_SERVER is an associative array containing server variables created by the web server. This can include specific environmental configurations, the server signature, your PHP script's paths and details, client data, and the active request/response sequence. Among its many uses, `$_SERVER['REMOTE_ADDR']` can help get the visitor's IP while `$_SERVER['HTTP_USER_AGENT']` offers information about their browser. Don't forget to sanitize the content before use to prevent security exploits. \n\nHere's an easy code sample that prints the client's IP:\n\n```php\necho 'Your IP is: ' . $_SERVER['REMOTE_ADDR'];\n```",
        "resources": [
          {
            "type": "course",
            "title": "$_SERVER",
            "url": "https://www.php.net/reserved.variables.server"
          }
        ]
      }
    },
    {
      "id": "sYI7f1PYP7G30_Uj2mZRv",
      "name": "Form Processing",
      "resources": {
        "description": "# Form Processing\n\nForm processing is a common web function and in PHP, it's pretty straightforward. It typically involves accepting data from a user through a web form and then using PHP to handle, process and possibly store that data. PHP provides superglobal arrays (`$_GET`, `$_POST`, and `$_REQUEST`) which help to collect form data. Let's talk about a simple example of a form that accepts a name from a user and then displays it.\n\nMake sure to handle form data securely, for instance by using the `htmlspecialchars()` function to neutralize any harmful characters.",
        "resources": [
          {
            "type": "course",
            "title": "HTML Form Processing",
            "url": "https://www.php.net/manual/en/tutorial.forms.php"
          }
        ]
      }
    },
    {
      "id": "HNo8QO4aPbvgePiA4l6tq",
      "name": "File Uploads",
      "resources": {
        "description": "# File Uploads\n\nUploading files in PHP is a commonly used functionality for many applications. This is typically done using the `$_FILES` superglobal array that allows you to manage uploaded files in your PHP script. It contains details like `name`, `type`, `size` etc of the file. An index is also present for each file in the case of multiple uploads. The `move_uploaded_file()` function is then used to move the uploaded file to the desired directory.\n\nDon't forget to pay attention to security considerations when accepting file uploads.",
        "resources": [
          {
            "type": "course",
            "title": "File Uploads",
            "url": "https://www.php.net/manual/en/features.file-upload.php"
          }
        ]
      }
    },
    {
      "id": "CGehmZjcgTWC7fQAvxmNW",
      "name": "State Management",
      "resources": {
        "description": "# State Management\n\nState management in PHP involves keeping track of user activity in the application, as HTTP protocol doesn't store earlier interactions. Typically, these data involve user details such as login info, form input data, etc. A prevalent method of state management in PHP is through sessions and cookies. Sessions work by keeping the state data on the server side and a session identifier on the client side. Note, session's info remains active until the user's session expires. On the other hand, cookies store data on the client side, having an expiry date or until the user deletes them. Here's how to set a cookie in PHP: `setcookie(\"test_cookie\", \"test\", time() + 3600, '/');`. To access sessions, use the `_SESSION` superglobal array: `$_SESSION[\"favcolor\"] = \"green\";`.",
        "resources": [
          {
            "type": "course",
            "title": "setcookie",
            "url": "https://php.net/manual/en/function.setcookie.php"
          }
        ]
      }
    },
    {
      "id": "so03-fK7E2WvTm6XsPq4i",
      "name": "Cookies",
      "resources": {
        "description": "# Cookies\n\nCookies are a crucial part of state management in PHP. They enable storage of data on the user's browser, which can then be sent back to the server with each subsequent request. This permits persistent data between different pages or visits. To set a cookie in PHP, you can use the `setcookie()` function. For example, `setcookie(\"user\", \"John Doe\", time() + (86400 * 30), \"/\");` will set a cookie named \"user\" with the value \"John Doe\", that will expire after 30 days. The cookie will be available across the entire website due to the path parameter set as `/`. To retrieve the value of the cookie, you can use the global `$_COOKIE` array: `echo $_COOKIE[\"user\"];`.",
        "resources": [
          {
            "type": "course",
            "title": "Cookies",
            "url": "https://www.php.net/manual/en/features.cookies.php"
          }
        ]
      }
    },
    {
      "id": "qobzzgzArNHLLn9Oiqc6G",
      "name": "Sessions",
      "resources": {
        "description": "# Sessions\n\nSessions provide a way to preserve certain data across subsequent accesses. Unlike a cookie, the information is not stored on the user's computer but on the server. This is particularly useful when you want to store information related to a specific user's session on your platform, like user login status or user preferences. When a session is started in PHP, a unique session ID is generated for the user. This ID is then passed and tracked through a cookie in the user's browser. To start a session, you would use the PHP function session_start(). To save a value in a session, you'd use the $_SESSION superglobal array. For example, `$_SESSION['username'] = 'John';` assigns 'John' to the session variable 'username'.",
        "resources": [
          {
            "type": "course",
            "title": "Sessions",
            "url": "https://www.php.net/manual/en/book.session.php"
          }
        ]
      }
    },
    {
      "id": "93oEIZttb85S23C1fLraP",
      "name": "Input Validation",
      "resources": {
        "description": "# Input Validation\n\nInput validation is a vital aspect of PHP security. It involves checking whether the user-provided data is in the expected format or not before it's processed further. This helps prevent potential security risks such as SQL injections, cross-site scripting (XSS) etc. Let's take an example of a simple form input validation: \n\n```php\nif (filter_var($email, FILTER_VALIDATE_EMAIL)) {\n  echo(\"Email is valid\");\n} else {\n  echo(\"Email is not valid\");\n}\n```\nThis code uses PHP's built-in `filter_var()` function to ensure the data is a valid email address. If not, the form will not be submitted until valid data is entered.",
        "resources": [
          {
            "type": "course",
            "title": "Input Validation",
            "url": "https://www.php.net/manual/en/book.filter.php"
          }
        ]
      }
    },
    {
      "id": "DxqQrToZSayWplKdCkTgT",
      "name": "XSS Prevention",
      "resources": {
        "description": "# XSS Prevention\n\nCross Site Scripting, often known as XSS, is a glaring risk in web security, and PHP also must address it. It occurs when someone is able to insert dangerous code into your site, which can then be executed by users. To prevent XSS in PHP, developers should deploy `htmlspecialchars()` function to escape potentially harmful characters. This function converts special characters to their HTML entities, reducing risk. For instance, '<' becomes '&lt;'. \n\nSample PHP code to implement this: \n\n```php\n$secure_text = htmlspecialchars($raw_text, ENT_QUOTES, 'UTF-8');\n```\n\nIn this code, `$raw_text` contains user input that might be risky. By using `htmlspecialchars()`, `$secure_text` will now hold a sanitized version of the user input.",
        "resources": [
          {
            "type": "course",
            "title": "Special Charsets",
            "url": "https://www.php.net/manual/en/function.htmlspecialchars.php"
          }
        ]
      }
    },
    {
      "id": "801vB_JMas4ucriUmfrLg",
      "name": "SQL Injection",
      "resources": {
        "description": "# SQL Injection\n\nSQL Injection is a crucial security topic in PHP. It is a code injection technique where an attacker may slip shady SQL code within a query. This attack can lead to data manipulation or loss and even compromise your database. To prevent this, PHP encourages the use of prepared statements with either the MySQLi or PDO extension. An example of a vulnerable code snippet would be: `$unsafe_variable = $_POST['user_input']; mysqli_query($link, \"INSERT INTO `table` (`column`) VALUES ('$unsafe_variable')\");`. Stop falling prey to injections by utilizing prepared statement like so: `$stmt = $pdo->prepare('INSERT INTO `table` (`column`) VALUES (?)'); $stmt->execute([$safe_variable]);`.",
        "resources": [
          {
            "type": "course",
            "title": "SQL Injection",
            "url": "https://www.php.net/manual/en/security.database.sql-injection.php"
          }
        ]
      }
    },
    {
      "id": "J9yIXZTtwbFzH2u4dI1ep",
      "name": "CSRF Protection",
      "resources": {
        "description": "# CSRF Protection\n\nCross-Site Request Forgery (CSRF) Protection in PHP is a method where a website can defend itself against unwanted actions performed on behalf of the users without their consent. It's a critical aspect of security as it safeguards users against potential harmful activities. Here's an example: if users are logged into a website and get tricked into clicking a deceitful link, CSRF attacks could be triggered. To protect your PHP applications from such attacks, you can generate a unique token for every session and include it as a hidden field for all form submissions. Afterwards, you need to verify this token on the server side before performing any action.\n\n```php\n<?php\n// Generate CSRF token\nif(empty($_SESSION['csrf'])) {\n    $_SESSION['csrf'] = bin2hex(random_bytes(32));\n}\n\n// Verify CSRF token\nif(isset($_POST['csrf']) && $_POST['csrf'] === $_SESSION['csrf']) {\n    // valid CSRF token, perform action\n}\n?>\n```",
        "resources": [
          {
            "type": "article",
            "title": "PHP Tutorial CSRF",
            "url": "https://www.phptutorial.net/php-tutorial/php-csrf/"
          }
        ]
      }
    },
    {
      "id": "JbWFfJiCRrXDhnuIx_lqx",
      "name": "Password Hashing",
      "resources": {
        "description": "# Password Hashing\n\nPassword Hashing in PHP is a crucial aspect of security, which involves converting a plaintext password into a unique hash that cannot be easily reversed. PHP's built-in functions - `password_hash()` and `password_verify()` - are usually employed for this purpose. `password_hash()` creates a new password hash using a strong one-way hashing algorithm, while `password_verify()` checks if the given hash matches the password provided. This makes it extremely difficult for malicious actors to get the original password, even if they have the hash.\n\n```php\n// Hashing the password\n$hash = password_hash('mypassword', PASSWORD_DEFAULT);\n\n// Verifying the password\nif (password_verify('mypassword', $hash)) {\n    echo 'Password is valid!';\n} else {\n    echo 'Invalid password.';\n}\n```",
        "resources": [
          {
            "type": "course",
            "title": "Password Hashing",
            "url": "https://www.php.net/manual/en/function.password-hash.php"
          }
        ]
      }
    },
    {
      "id": "HJJzKYXdK4BWITLP4APLZ",
      "name": "Auth Mechanisms",
      "resources": {
        "description": "# Auth Mechanisms\n\nWhen you are developing PHP application, security should always be a top priority and authentication mechanism forms it's very core. It ensures proper establishing of user identities before they can access your system's resources. PHP provides several methods to implement authentication like session-based, token-based, HTTP authentication, and more.",
        "resources": [
          {
            "type": "course",
            "title": "Auth Mechanisms",
            "url": "https://www.php.net/manual/en/features.http-auth.php"
          }
        ]
      }
    },
    {
      "id": "tfC1tCrbvH5J43WUpG9Yb",
      "name": "Sanitization Techniques",
      "resources": {
        "description": "# Sanitization Techniques\n\nSanitization Techniques is a vital part of PHP security basics, which ensures that the user-provided data is safe to be used within your script. It can prevent harmful data from being inserted into the database or being used in other ways that could potentially be dangerous to your application. It includes functions which can strip off unwanted characters from the data. For instance, the `filter_var()` function in PHP can be applied to sanitize text. \n\n```php \n$dirty_data = \"<p>We love PHP!</p><script>alert('Virus!')</script>\";   \n$clean_data = filter_var($dirty_data, FILTER_SANITIZE_STRING);\necho $clean_data;\n```",
        "resources": [
          {
            "type": "course",
            "title": "Sanitization Techniques",
            "url": "https://www.php.net/manual/en/function.filter-var.php"
          }
        ]
      }
    },
    {
      "id": "cJtPz1RMN1qDE4eRdv4N_",
      "name": "PDO",
      "resources": {
        "description": "# PDO\n\nPDO (PHP Data Objects) is an interface in PHP that provides a lightweight, consistent way for working with databases in PHP. PDO allows you to use any database without changing your PHP code, making your code database-independent. Furthermore, it offers robust error handling and can utilize prepared statements to prevent SQL injection attacks. Here is how you could connect and fetch data from a MySQL database using PDO:\n\n```php\ntry {\n    $pdo = new PDO('mysql:host=localhost;dbname=test', 'username', 'password');\n    $stmt = $pdo->query('SELECT * FROM myTable');\n    while ($row = $stmt->fetch()) {\n        echo $row['name'] . \"\\n\";\n    }\n} catch (PDOException $e) {\n    echo \"Connection failed: \" . $e->getMessage();\n}\n```",
        "resources": [
          {
            "type": "course",
            "title": "Data Objects",
            "url": "https://www.php.net/manual/en/book.pdo.php"
          }
        ]
      }
    },
    {
      "id": "YLuo0oZJzTCoiZoOSG57z",
      "name": "MySQLi",
      "resources": {
        "description": "# MySQLi\n\nMySQLi is a PHP extension that allows PHP programs to connect with MySQL databases. This extension provides the capability to perform queries, retrieve data, and perform complex operations on MySQL databases using PHP. MySQLi comes with an object-oriented and procedural interface and supports prepared statements, multiple statements, and transactions. \n\nHere's a basic example of using MySQLi to connect to a MySQL database:\n\n```php\n$servername = \"localhost\";\n$username = \"username\";\n$password = \"password\";\n$dbname = \"myDB\";\n\n// Create connection\n$conn = new mysqli($servername, $username, $password, $dbname);\n\n// Check connection\nif ($conn->connect_error) {\n  die(\"Connection failed: \" . $conn->connect_error);\n}\necho \"Connected successfully\";\n```",
        "resources": [
          {
            "type": "course",
            "title": "MySQLi",
            "url": "https://www.php.net/manual/en/book.mysqli.php"
          }
        ]
      }
    },
    {
      "id": "SeqGIfcLuveZ2z5ZSXcOd",
      "name": "Object-Relational Mapping (ORM)",
      "resources": {
        "description": "# Object-Relational Mapping (ORM)\n\nObject-Relational Mapping (ORM) is a popular technique used with PHP to convert data between incompatible type systems using an object-oriented programming language. Essentially, it saves PHP developers time by enabling them to work with databases using OOP standards and avoid writing long SQL queries. One commonly used ORM in PHP is Doctrine. For instance, to save data into a products table, you don't use SQL but OOP-style code:\n\n```php\n$product = new Product();\n$product->setName('New Product');\n$entityManager->persist($product);\n$entityManager->flush();\n```",
        "resources": [
          {
            "type": "article",
            "title": "What is an Object Relational Mapping (ORM)",
            "url": "https://stackoverflow.com/questions/1279613/what-is-an-orm-how-does-it-work-and-how-should-i-use-one#answer-1279678"
          }
        ]
      }
    },
    {
      "id": "FY-F6n9j29hQrnFry3VGb",
      "name": "Database Transactions",
      "resources": {
        "description": "# Database Transactions\n\nDatabase transactions in PHP refer to a unit of work performed within a database system, which is treated in a coordinated manner. This technique is vital when dealing with critical tasks like money transfer between accounts, where data consistency is crucial. If one part of the transaction fails, the entire transaction fails, ensuring that the database stays consistent even in an event of a failure.",
        "resources": [
          {
            "type": "course",
            "title": "PDO Transactions",
            "url": "https://www.php.net/manual/en/pdo.transactions.php"
          }
        ]
      }
    },
    {
      "id": "txUyPR_tdC8iTJV3RtvBz",
      "name": "Connection Pooling",
      "resources": {
        "description": "# Connection Pooling\n\nConnection pooling is a technique used in PHP to manage and maintain multiple open connections with a database. It reduces the time overhead of constantly opening and closing connections, and ensures efficient utilisation of resources. Connection pooling limits the number of connections opened with the database and instead reuses a pool of existing active connections, thereby significantly enhancing the performance of PHP applications. When a PHP script needs to communicate with the database, it borrows a connection from this pool, performs the operations, and then returns it back to the pool. Although PHP doesn't have native support for connection pooling, it can be achieved through third-party tools like 'pgBouncer' when using PostgreSQL or 'mysqlnd_ms' plugin with MySQL. Note, it's recommended to use connection pooling when you've a high-traffic PHP application.",
        "resources": [
          {
            "type": "course",
            "title": "Connection Pooling",
            "url": "https://www.php.net/manual/en/oci8.connection.php"
          },
          {
            "type": "course",
            "title": "Database Extensions",
            "url": "https://www.php.net/manual/en/refs.database.php"
          }
        ]
      }
    },
    {
      "id": "M1nVsh_sCSFJRf6-7Ttsj",
      "name": "Performance Optimization",
      "resources": {
        "description": "# Performance Optimization\n\nPerformance Optimization linked with Advanced Database Techniques in PHP ensures your database-driven applications run efficiently. This involves techniques like indexing, using EXPLAIN SQL command, de-normalization, and caching query results. For instance, an effective technique is caching query results, which can significantly reduce the number of database calls. PHP offers functions to serialize and unserialize data, you can store your result set in a serialized form and when needed, retrieve it quickly, unserialize it and voila, you have your data ready with no database calls. \n\nHere's a simple example of caching MySQL query with PHP:\n\n```php\n$query = \"SELECT * FROM my_table\";\n$cache_file = '/tmp/cache/' . md5($query);\n\nif (file_exists($cache_file)) {\n    $result_set = unserialize(file_get_contents($cache_file));\n} else {\n    $result= mysql_query($query);\n    $result_set= array();\n    while ($row = mysql_fetch_array($result)) {\n        $result_set[]= $row;\n    }\n    file_put_contents($cache_file, serialize($result_set));\n}\n```",
        "resources": [
          {
            "type": "course",
            "title": "MySQL Performance Optimization",
            "url": "https://www.php.net/manual/en/book.mysql.php"
          }
        ]
      }
    },
    {
      "id": "meplwvmHMtI3Sb_fyodzZ",
      "name": "Database Migrations",
      "resources": {
        "description": "# Database Migrations\n\nDatabase migrations help keep track of changes in your database schema, making it easier to move from one version of a database to another. Migrations allow us to evolve our database design iteratively and apply these updates across our development, staging, and production servers. This can save a lot of manual work. But more than that, migrations maintain consistency across all the environments, reducing the chances of unexpected behavior. There's no standard built-in migrations mechanism in PHP, but powerful and popular PHP frameworks like Laravel have robust solutions for migrations.",
        "resources": [
          {
            "type": "article",
            "title": "Laravel Migrations",
            "url": "https://laravel.com/docs/migrations"
          }
        ]
      }
    },
    {
      "id": "PIuplWreo7PFG3Mdn2t6W",
      "name": "Classes and Objects",
      "resources": {
        "description": "# Classes and Objects\n\nPHP supports object-oriented programming, offering a multi-paradigm way of coding through classes and objects. A class is like a blueprint for creating objects that encapsulate all faculties, properties and methods. An object, on the other hand, is an instance of a class where you can interact with the class's methods and change its properties. PHP lets you define a class using the keyword 'class', set properties and methods within it, and then create an object of that class using 'new'.",
        "resources": [
          {
            "type": "course",
            "title": "Classes",
            "url": "https://www.php.net/manual/en/language.oop5.php"
          }
        ]
      }
    },
    {
      "id": "oNUt1oT8pYBVvH0S2P6cb",
      "name": "Constructor / Destructor",
      "resources": {
        "description": "# Constructor / Destructor\n\nConstructor and Destructor methods are fundamental components of Object-Oriented Programming (OOP) in PHP. A constructor is a special type of method that automatically runs upon creating an object, often used to set property values or default behaviors. On the other hand, a destructor is a method that is automatically invoked when an object is due to be destroyed, perfect for cleanup activities. Here is a basic example:\n\n```php\nclass TestClass {\n  public $value;\n\n  // Constructor Method\n  public function __construct($val) {\n    $this->value = $val;\n  }\n\n  // Destructor Method\n  public function __destruct() {\n    echo \"Object is being destroyed.\";\n  }\n}\n\n$obj = new TestClass(\"Hello World\");\necho $obj->value; \n// Displays: Hello World\n// And when the script ends, \"Object is being destroyed.\"\n```",
        "resources": [
          {
            "type": "course",
            "title": "PHP Constructors and Destructors",
            "url": "https://www.php.net/manual/en/language.oop5.decon.php"
          }
        ]
      }
    },
    {
      "id": "MRAPXshy9RoYdReY6grf_",
      "name": "Properties and Methods",
      "resources": {
        "description": "# Properties and Methods\n\nProperties and Methods are fundamental components of Object-Oriented Programming (OOP) in PHP. Properties are just like variables; they hold information that an object will need to use. Methods, on the other hand, are similar to functions; they perform an action on an object's properties. In PHP, properties are declared using visibility keywords (public, protected, or private) followed by a regular variable declaration, while methods are declared like functions but inside a class. \n\nHere is a simple example: \n\n```php\nclass Car {\n  public $color; // Property\n\n  // Method\n  public function setColor($color) {\n    $this->color = $color;\n  }\n}\n```\nIn this example, `$color` is a property and `setColor()` is a method.",
        "resources": [
          {
            "type": "course",
            "title": "Properties and Methods",
            "url": "https://www.php.net/manual/en/language.oop5.properties.php"
          }
        ]
      }
    },
    {
      "id": "RD2RaBmA2XWkEa13PTCTX",
      "name": "Access Specifiers",
      "resources": {
        "description": "# Access Specifiers\n\nAccess specifiers, also known as access modifiers, in PHP are keywords used in the class context which define the visibility and accessibility of properties, methods and constants. PHP supports three types of access specifiers: public, private, and protected. 'Public' specified properties or methods can be accessed from anywhere, 'private' ones can only be accessed within the class that defines them, while 'protected' ones can be accessed within the class itself and by inherited and parent classes. Here's an illustrative example:",
        "resources": [
          {
            "type": "course",
            "title": "Access Specifiers & Visibility",
            "url": "https://www.php.net/manual/en/language.oop5.visibility.php"
          }
        ]
      }
    },
    {
      "id": "qlkpwXfOc1p7j37hrzffI",
      "name": "Static Methods and Properties",
      "resources": {
        "description": "# Static Methods and Properties\n\nStatic methods and properties in PHP belong to the class rather than an instance of the class. This means they can be accessed without creating an object of the class. A static method is declared with the static keyword and can be invoked directly using the class name followed by the scope resolution operator. Similarly, a static property is also defined with the static keyword, but cannot be accessed directly, even from within the class methods - they must be accessed through static methods. Here's a simple example: \n\n```php\nclass MyClass {\n    static $myStaticProperty = \"Hello, world\";\n\n    static function myStaticMethod() { \n        return self::$myStaticProperty; \n    }\n}\n\necho MyClass::myStaticMethod(); \n```\n\nIn this example, we're directly accessing `myStaticMethod` from `MyClass` without an instantiation.",
        "resources": [
          {
            "type": "course",
            "title": "Static Methods and Properties",
            "url": "https://www.php.net/manual/en/language.oop5.static.php"
          }
        ]
      }
    },
    {
      "id": "c5q2e_jyMt8Pir5Od3lRi",
      "name": "Inheritance",
      "resources": {
        "description": "# Inheritance\n\nInheritance, a fundamental concept in object-oriented programming (OOP), is a feature that PHP supports. It lets us create classes which are extensions of other classes, inheriting their methods and properties. This concept allows the creation of more flexible and maintainable code, as it promotes code reuse. For instance, consider we have a 'Vehicle' class and we want to create a 'Car' class. Since cars are a type of vehicle, it would make sense for our 'Car' class to inherit from the 'Vehicle' class.\n\n```php\nclass Vehicle {\n  public $color;\n  function drive() {\n    echo \"Driving...\";\n  }\n}\n\nclass Car extends Vehicle {\n  function horn() {\n    echo \"Beeping...\";\n  }\n}\n\n$myCar = new Car();\n$myCar->drive(); // Inherits drive method from Vehicle\n$myCar->horn(); // Unique to Car\n```\n\nIn the above example, the 'Car' class inherits the drive method from the 'Vehicle' class but also has an additional method, horn. This is an illustration of how inheritance in PHP can help to organize your code efficiently and intuitively.",
        "resources": [
          {
            "type": "course",
            "title": "Inheritance",
            "url": "https://www.php.net/manual/en/language.oop5.inheritance.php"
          }
        ]
      }
    },
    {
      "id": "yTviiPFR5b_dr3WyxdxxQ",
      "name": "OOP Fundamentals",
      "resources": {
        "description": "# OOP Fundamentals\n\nIn PHP, Object-Oriented Programming (OOP) Fundamentals cover critical aspects like classes, objects, properties, and methods. OOP facilitates efficient code reusability and makes it easier to manage and modify code. For example, here's a code snippet that represents a class with a method and a property in PHP:\n\n```php\nclass Hello {\n    public $greeting = \"Hello, world!\";\n\n    public function displayGreeting() {\n        echo $this->greeting;\n    }\n}\n$hello = new Hello();\n$hello->displayGreeting(); // Outputs \"Hello, world!\"\n```\n\nThis snippet defines a class `Hello` with a property `$greeting` and a method `displayGreeting()`. Instances of this class can access these methods and properties. OOP Fundamentals in PHP are much more comprehensive, encompassing concepts like inheritance, encapsulation, and polymorphism.",
        "resources": [
          {
            "type": "course",
            "title": "OOP",
            "url": "https://php.net/manual/en/language.oop5.basic.php"
          }
        ]
      }
    },
    {
      "id": "gtq5KrghF28f5G8nuDcYQ",
      "name": "Polymorphism",
      "resources": {
        "description": "# Polymorphism\n\nPolymorphism is a core concept in object-oriented programming that PHP supports. It provides a mechanism to use one interface for different underlying forms, enabling different objects to process differently based on their data type. In PHP, polymorphism can be achieved through inheritance and interfaces. For example, you may have a parent class 'Shape' and child classes 'Circle', 'Rectangle', etc. They all can have a method 'draw' but with different implementations. It's not limited to classes; you can also use polymorphism with interfaces by implementing different classes with the same interface where each class will have different code for the same method. \n\nHere's a small sample code demonstrating the concept:\n\n```php\n<?php\ninterface Shape {\n  public function draw();\n}\n\nclass Circle implements Shape {\n  public function draw() {\n    echo \"Draw a circle\";\n  }\n}\n\nclass Rectangle implements Shape {\n  public function draw() {\n    echo \"Draw a rectangle\";\n  }\n}\n\nfunction drawShape(Shape $shape) {\n  $shape->draw();\n}\n\ndrawShape(new Circle());  \ndrawShape(new Rectangle()); \n?>\n```\n\nThis creates a scalable way to add more shapes, as you only need to follow the 'Shape' interface.",
        "resources": [
          {
            "type": "tutorial",
            "title": "Polymorphism",
            "url": "https://www.phptutorial.net/php-oop/php-polymorphism/"
          }
        ]
      }
    },
    {
      "id": "ub79EkMiOmPBwXLRuYFL8",
      "name": "Abstract classes",
      "resources": {
        "description": "# Abstract classes\n\nAbstract classes in PHP are those which cannot be instantiated on their own. They are simply blueprints for other classes, providing a predefined structure. By declaring a class as abstract, you can define methods without having to implement them. Subsequent classes, when inheriting from an abstract class, must implement these undefined methods.",
        "resources": [
          {
            "type": "course",
            "title": "Abstract Classes",
            "url": "https://www.php.net/manual/en/language.oop5.abstract.php"
          }
        ]
      }
    },
    {
      "id": "vu0H-TsD7hkJgOQbSRj92",
      "name": "Interfaces",
      "resources": {
        "description": "# Interfaces\n\nInterfaces in PHP serve as a blueprint for designing classes. They ensure that a class adheres to a certain contract, all without defining how those methods should function. As PHP is not a strictly typed language, interfaces can be particularly useful in large codebases to maintain continuity and predictability. For example, in PHP, an interface 'iTemplate' could be defined with methods 'setVariable' and 'getHtml'. Any class that implements this interface must define these methods. \n\nHere is a snippet:\n\n```php\ninterface iTemplate {\n    public function setVariable($name, $var);\n    public function getHtml($template); \n}\n\nclass Template implements iTemplate {\n    private $vars = array();\n\n    public function setVariable($name, $var) {\n        $this->vars[$name] = $var;\n    }\n\n    public function getHtml($template) {\n        foreach($this->vars as $name => $value) {\n            $template = str_replace('{' . $name . '}', $value, $template);\n        }\n        return $template;\n    }\n}\n```",
        "resources": [
          {
            "type": "course",
            "title": "Interfaces",
            "url": "https://www.php.net/manual/en/language.oop5.interfaces.php"
          }
        ]
      }
    },
    {
      "id": "GR09ns9B-0cONQaQ_uj-7",
      "name": "Traits",
      "resources": {
        "description": "# Traits\n\nTraits is a concept in PHP that allows code reusability by enabling developers to create reusable pieces of code which can be used in classes to extend functionality. They are a way to reduce intricacies of single inheritance by enabling a developer to reuse sets of methods freely in several independent classes. \n\nHere's an example how to use a Trait:\n\n```php\ntrait Greeting {\n    public function sayHello() {\n        return \"Hello\";\n    }\n}\nclass User {\n    use Greeting;\n}\n$user = new User();\necho $user->sayHello(); // Outputs: Hello\n```\n\nIn the above code snippet, the `Greeting` trait is being used in the `User` class, and we are able to use its methods as if they were defined in the `User` class.",
        "resources": [
          {
            "type": "course",
            "title": "Traits",
            "url": "https://www.php.net/manual/en/language.oop5.traits.php"
          }
        ]
      }
    },
    {
      "id": "9raJ06lKRZITbjWeLil-F",
      "name": "Namespaces",
      "resources": {
        "description": "# Namespaces\n\nNamespaces in PHP are a way of encapsulating items so that name collisions won't occur. When your code expands, there could be a situation where classes, interfaces, functions, or constants might have the same name, causing confusion or errors. Namespaces come to the rescue by grouping these items. You declare a namespace using the keyword 'namespace' at the top of your PHP file. Every class, function, or variable under this declaration is a part of the namespace until another namespace is declared, or the file ends. It's like creating a new room in your house solely for storing sports equipment. This makes it easier to find your tennis racket, as you won't have to rummage around in a closet full of mixed items. \n\nHere's a quick example: \n\n```php\nnamespace MyNamespace\\SubNamespace; \nfunction displayGreeting() {\n     echo 'Hello World!'; \n} \n```",
        "resources": [
          {
            "type": "course",
            "title": "Namespaces",
            "url": "https://www.php.net/manual/en/language.namespaces.php"
          }
        ]
      }
    },
    {
      "id": "rSXsPWto7Jeyw3Szl9pvf",
      "name": "Magic methods",
      "resources": {
        "description": "# Magic methods\n\nPHP Magic Methods, often considered the hooks of the language, provide developers a way to change how objects will respond to particular language constructs. Magic methods are special functions that start with \"__\" such as `__construct()`, `__destruct(), __call(), __get(), __set()` and more. They enable us to perform certain tasks automatically when specific actions occur. For example, `__construct()` executes when an object is created while `__destruct()` triggers when an object is no longer needed. Let's see the `__construct` magic method in action:\n\n```php\nclass Car {\n    public $color;\n    public function __construct($color) {\n        $this->color = $color;\n    }\n}\n$blueCar = new Car(\"Blue\"); // This will call the __construct() method.\necho $blueCar->color;  // Outputs \"Blue\".\n```",
        "resources": [
          {
            "type": "course",
            "title": "Magic Methods",
            "url": "https://www.php.net/manual/en/language.oop5.magic.php"
          }
        ]
      }
    },
    {
      "id": "KEE50C6lOS4eX8sAbfhYe",
      "name": "Dependency injection",
      "resources": {
        "description": "# Dependency Injection\n\nDependency injection is a design pattern used mainly for managing class dependencies. Here, instead of a class being responsible for creating its dependencies on its own, an injector (the \"client\") passes the requirements to the class (the \"service\"), centralizing control and encouraging code to follow the single responsibility principle. As a simple example, consider a situation where class B needs to utilize class A's methods. Instead of creating an object of class A within B, with dependency injection, we pass an instance of class A to B.\n\n```php\nclass A {\n    function display(){\n        echo 'Hello, PHP dependency injection!';\n    }\n}\n\nclass B {\n    private $a;\n\n    public function __construct(A $classAInstance) {\n        $this->a = $classAInstance;\n    }\n\n    public function callDisplayOwn() {\n        $this->a->display();\n    }\n}\n\n$instanceA = new A();\n$instanceB = new B($instanceA);\n$instanceB->callDisplayOwn();  // Outputs: \"Hello, PHP dependency injection!\"\n```",
        "resources": [
          {
            "type": "article",
            "title": "Understand Dependency Injection in PHP",
            "url": "https://php-di.org/doc/understanding-di.html"
          }
        ]
      }
    },
    {
      "id": "sPW-Ti2VyNYzxq6EYkbn7",
      "name": "Type Declarations",
      "resources": {
        "description": "# Type Declarations\n\nType declarations, also known as type hints, are a feature in PHP that provides you options to specify the type of variable that a function is expected to receive or the type of value that it should return. Not only does it help to debug code quickly, it also makes the code more readable. In PHP, type declarations can be for both parameters in a function (parameter type declarations) and return values from a function (return type declarations). They can apply to classes, interfaces, callable, and scalar types (int, float, string, bool). \n\nHere's an example:\n\n```php\nfunction add(int $a, int $b): int {\n    return $a + $b;\n}\n\necho add(1, 2);  // prints: 3\n```\nIn this example, the function 'add' only accepts integers and also returns an integer.",
        "resources": [
          {
            "type": "course",
            "title": "Type Declarations",
            "url": "https://www.php.net/manual/en/functions.arguments.php#functions.arguments.type-declaration"
          }
        ]
      }
    },
    {
      "id": "zsscRQZIq5o0JZir9hlz-",
      "name": "Laravel",
      "resources": {
        "description": "# Laravel\n\nLaravel is a robust, elegant PHP framework perfect for web application development, providing developers with a lot of features that boost productivity. Laravel leverages the power of PHP for handling complex tasks such as routing, sessions, caching, and authentication, making it much simpler and quicker for PHP developers to build applications. Laravel's MVC architecture promotes clean, DRY code and separates business logic from UI which significantly improves scalability as well as ease of maintenance.",
        "resources": [
          {
            "type": "course",
            "title": "Laravel",
            "url": "https://laravel.com/"
          },
          {
            "type": "course",
            "title": "Laravel Installation",
            "url": "https://laravel.com/docs/11.x/installation"
          },
          {
            "type": "course",
            "title": "Laravel Documentation",
            "url": "https://laravel.com/docs"
          }
        ]
      }
    },
    {
      "id": "57VSMVePOr9qUD5x_LNdf",
      "name": "Symfony",
      "resources": {
        "description": "# Symfony\n\nSymfony is a set of PHP components and a framework for web projects. It aims to speed up the creation and maintenance of web applications and replace the recurring coding tasks. Symfony uses Composer, a PHP dependency manager, to manage its components. Below is an example of creating a new Symfony project:\n\n```shell\ncomposer create-project symfony/website-skeleton myproject\n```\n\nThis will download and install a new Symfony project in the 'myproject' directory. Symfony's components are reusable PHP libraries that will help you complete tasks, like routing, templating, or even creating form handling.",
        "resources": [
          {
            "type": "course",
            "title": "Symfony",
            "url": "https://symfony.com/"
          },
          {
            "type": "course",
            "title": "Symfony Documentation",
            "url": "https://symfony.com/doc/current/index.html"
          }
        ]
      }
    },
    {
      "id": "yVFDu2aTiEZ4PWMdKdW2P",
      "name": "Composer",
      "resources": {
        "description": "# Composer\n\nComposer is a fundamental tool in modern PHP development. It simplifies the management of project dependencies, allowing you to declare what you need and automatically installing those resources in your project. For example, if your PHP project requires a certain library, Composer will fetch the appropriate version and make sure it's available for your project. Here's an example of how to add a dependency using Composer:\n\n```shell\ncomposer require vendor/package\n```\n\nThis command adds the `vendor/package` dependency to your project. The same goes for removing dependencies, updating them, and more.",
        "resources": [
          {
            "type": "course",
            "title": "Composer",
            "url": "https://getcomposer.org/"
          },
          {
            "type": "course",
            "title": "Composer Documentation",
            "url": "https://getcomposer.org/doc/"
          }
        ]
      }
    },
    {
      "id": "xZf2jjnCVHwYfDH2hs9kR",
      "name": "Packagist",
      "resources": {
        "description": "# Packagist\n\nPackagist is the primary package repository for PHP, providing a service for hosting and distributing PHP package dependencies. Developers can use it to upload their PHP packages and share them with other developers globally. In conjunction with Composer, Packagist helps manage package versions and resolve dependencies for PHP, acting as a crucial part of modern PHP development.",
        "resources": [
          {
            "type": "course",
            "title": "Packagist",
            "url": "https://packagist.org/"
          },
          {
            "type": "course",
            "title": "Package Documentation",
            "url": "https://getcomposer.org/doc/01-basic-usage.md#package-versions"
          }
        ]
      }
    },
    {
      "id": "qFiTsf6Es-gwqe6J6bdL1",
      "name": "Autoloading",
      "resources": {
        "description": "# Autoloading\n\nAutoloading is a convenient feature in PHP that allows for automated loading of classes or files when they are needed. For example, if you have a class that is not yet included or required in the script, and you're instantiating that class, PHP would automatically include that class file for you, given that it complies with the standard PHP autoloading conventions. This feature cuts down the need to manually include or require files and makes your code cleaner and more efficient to manage. Here's a simple example:\n\n```php\nspl_autoload_register(function ($class_name) {\n    include $class_name . '.php';\n});\n\n$obj = new MyClass();\n```\n\nIn this example, PHP will automatically load the MyClass.php file when the MyClass is instantiated.",
        "resources": [
          {
            "type": "course",
            "title": "Autoloading",
            "url": "https://www.php.net/manual/en/language.oop5.autoload.php"
          }
        ]
      }
    },
    {
      "id": "NfBKKwG2GGBPppOjoLLBg",
      "name": "PHPUnit",
      "resources": {
        "description": "# PHPUnit\n\nPHPUnit is a widely used testing framework in PHP. Automated testing allows developers to ensure their code functions as expected. With PHPUnit, you can write test cases in PHP to check the functionality of your codebase. It's particularly good for executing unit tests - tests that verify individual parts of the software. PHPUnit supports several types of assertions, making it versatile for any testing requirement. Here's a simple PHPUnit test case:\n\n```php\n<?php\nuse PHPUnit\\Framework\\TestCase;\n\nclass StackTest extends TestCase\n{\n    public function testPushAndPop()\n    {\n        $stack = [];\n        $this->assertEquals(0, count($stack));\n\n        array_push($stack, 'foo');\n        $this->assertEquals('foo', $stack[count($stack)-1]);\n        $this->assertEquals(1, count($stack));\n\n        $this->assertEquals('foo', array_pop($stack));\n        $this->assertEquals(0, count($stack));\n    }\n}\n?>\n```\nIn this example, were testing the 'push' and 'pop' functionality of an array.",
        "resources": [
          {
            "type": "course",
            "title": "PHP Unit",
            "url": "https://phpunit.de/getting-started/phpunit-7.html"
          }
        ]
      }
    },
    {
      "id": "d6MydchA52HIxfAUjmZui",
      "name": "Pest",
      "resources": {
        "description": "# Pest\n\nPest is an innovative and elegant testing framework for PHP. Think of it as a stylish and streamlined alternative to PHPUnit. Pest makes testing your PHP code a breeze by enabling expressive and flexible test cases. It provides higher-level abstractions to minimize boilerplate code without disrupting the ability to integrate traditional PHPUnit tests. For example, using Pest can make a test case as simple as writing a closure:\n\n```php\nit('has homepage', function () {\n    $response = get('/');\n    $response->assertStatus(200);\n});\n```",
        "resources": [
          {
            "type": "course",
            "title": "Pest",
            "url": "https://pestphp.com/"
          },
          {
            "type": "course",
            "title": "Pest Installation",
            "url": "https://pestphp.com/docs/installation"
          }
        ]
      }
    },
    {
      "id": "6eWgZVLV479oQzl0fu-Od",
      "name": "Style Tools",
      "resources": {
        "description": "# Style Tools\n\nStyle Tools in PHP primarily refer to coding standard tools that help maintain a consistent coding style throughout your PHP project. PHP_CodeSniffer is a popular tool in this category. It tokenizes PHP, JavaScript, and CSS files and detects violations of a defined set of coding standards. A brief example of PHP_CodeSniffer usage would be to run it in the command line like this: `phpcs /path/to/code/myfile.php`. Other tools such as PHP CS Fixer can automatically correct coding standard violations.",
        "resources": [
          {
            "type": "course",
            "title": "Style Tools",
            "url": "https://www.php.net/manual/en/refs.basic.php.cs.php"
          }
        ]
      }
    },
    {
      "id": "fSpvZ_4kGFMbFVCWhA8vn",
      "name": "PHPCodeSniffer",
      "resources": {
        "description": "# PHPCodeSniffer\n\nPHPCodeSniffer, often abbreviated as PHPCS, is a fantastic tool designed for PHP developers to maintain neat and consistent coding styles across their projects. It does this by analyzing the PHP, JavaScript, and CSS files in your project to detect deviations from a defined set of coding standards. When PHPCodeSniffer finds a violation, it flags it for fixing, thus making your codebase more readable and harmonious. Here is an example of running PHPCS:\n\n```shell\nphpcs --standard=PSR2 /path/to/your/phpfile.php \n```\n\nThis command checks your PHP file against the PSR-2 coding standard.",
        "resources": [
          {
            "type": "tutorial",
            "title": "CodeSniffer Documentation",
            "url": "https://github.com/squizlabs/PHP_CodeSniffer/wiki"
          }
        ]
      }
    },
    {
      "id": "r07k_hT2z2EiIBH4q3F7-",
      "name": "PHP CS Fixer",
      "resources": {
        "description": "# PHP CS Fixer\n\nPHP CS Fixer is a valuable utility for PHP developers that examines and fixes your code to ensure it aligns with specific coding standards. This powerful tool diminishes the time and effort spent on manual code review and corrections. It reviews your PHP code's syntax, appearance, and structure and can automatically fix issues found. PHP CS Fixer supports PSR-1, PSR-2, Symfony standards, and more. Here's an example of how you can use PHP CS Fixer. First, install it via composer: \n\n```bash\ncomposer global require friendsofphp/php-cs-fixer\n```\n\nThen, run this command in your project directory:\n\n```bash\nphp-cs-fixer fix /path-to-your-php-files\n```",
        "resources": [
          {
            "type": "course",
            "title": "CS Fixer",
            "url": "https://cs.symfony.com/"
          }
        ]
      }
    },
    {
      "id": "PrG_5dyBblXsWYYRcOJMa",
      "name": "Static Analysis",
      "resources": {
        "description": "# Static Analysis\n\nStatic analysis in PHP is a method to inspect the source code before running it. Rather than testing programs on specific inputs (dynamic analysis), static analysis focuses on finding potential issues within code without executing it. It can help in identifying common coding mistakes and uncovering complex problems like dependency issues, unused variables, undeclared properties, and more. Using tools such as PHPStan or Psalm provides this static analysis feature in PHP. For instance, using PHPStan involves merely installing it via Composer and running it against your codebase.\n\n```bash\ncomposer require --dev phpstan/phpstan\n./vendor/bin/phpstan analyse src\n```\n\nIt outputs information about any issues it finds in code. However, to reap the full benefits, understand that these tools require proper configuration and regular usage.",
        "resources": [
          {
            "type": "course",
            "title": "PHP Stan",
            "url": "https://phpstan.org/"
          },
          {
            "type": "course",
            "title": "PHP Stan - Getting Started",
            "url": "https://phpstan.org/user-guide/getting-started"
          }
        ]
      }
    },
    {
      "id": "12k71gNfwAcT9K5aLWgbZ",
      "name": "PHPStan",
      "resources": {
        "description": "# PHPStan\n\nPHPStan is a static analysis tool for PHP that focuses on discovering bugs in your code. As opposed to dynamic analysis which works while your program is running, static analysis examines your code without executing it. PHPStan can catch an entire class of bugs even before you write tests for the code, thus making it a valuable tool in PHP development. For example, PHPStan can prevent issues like accessing an undefined array key or calling a method that doesn't exist. \n\nHere's a basic example of how you can use PHPStan:\n\n```shell\n// install PHPStan using composer\n$ composer require --dev phpstan/phpstan\n\n// analyse your code\n$ vendor/bin/phpstan analyse src\n```",
        "resources": [
          {
            "type": "course",
            "title": "PHP Stan",
            "url": "https://phpstan.org/user-guide/getting-started"
          }
        ]
      }
    },
    {
      "id": "B45YVzov8X_iOtneiFEqa",
      "name": "Phan",
      "resources": {
        "description": "# Phan\n\nPhan is a static analysis tool specially made for PHP language, greatly useful in catching common issues in the code before execution. It can analyze the syntax and behaviors in PHP code, detecting problems such as undeclared variables, type inconsistencies, uncaught exceptions, and more. Interestingly, Phan has a particular strength  it understands the relationships among PHP's different features, making the tool effective in finding subtle, complicated bugs. To use it, simply install it using composer and run the command 'phan' in your project directory.\n\n```php\n<?php\n// Phan sample usage\n\nrequire 'vendor/autoload.php';    // Autoload files using Composer autoload\n\nuse Phan\\Phan;\nuse Phan\\CLI;\n\n$code = \"<?php function add(int $a, int $b): int { return $a + $b; } echo add('hello', 'world');\"; // code with a type error\n\nPhan::analyzeFile('test.php', $code);\n```\nAbove is a basic sample of using Phan. It checks for a type error in a PHP function.",
        "resources": [
          {
            "type": "course",
            "title": "Phan",
            "url": "https://phan.github.io/"
          },
          {
            "type": "tutorial",
            "title": "phan/phan",
            "url": "https://github.com/phan/phan"
          }
        ]
      }
    },
    {
      "id": "T1XD93j6Lkpl88JSmys9b",
      "name": "Psalm",
      "resources": {
        "description": "# Psalm\n\nPsalm is a popular static analysis tool tailored for PHP. It identifies potential issues in your code, including syntax errors, unused variables, and type mismatches, before you run the code. This helps to improve code quality and maintainability. It's quite powerful, it can even understand complex scenarios using its template/interface system. To analyze your PHP code with Psalm, you simply need to install it and then run it against your PHP file or directory. \n\nHere's an example of how you might run Psalm against a file called 'example.php': \n\n```bash\nvendor/bin/psalm example.php\n```",
        "resources": [
          {
            "type": "course",
            "title": "Psalm Documentation",
            "url": "https://psalm.dev/docs/"
          }
        ]
      }
    },
    {
      "id": "KC6D81-T-FwQc7Osw1rlY",
      "name": "cURL",
      "resources": {
        "description": "# cURL\n\ncURL is a flexible way to make requests to external servers from within a PHP script. cURL, which stands for Client URL, is a library that facilitates various types of network communication methods based on different types of URLs. You can, for example, use cURL functions in PHP to access REST APIs, download files, or post form data, among other things. Here's a basic PHP cURL example where we fetch data from an API:\n\n```php\n$ch = curl_init();\n\ncurl_setopt($ch, CURLOPT_URL, \"http://example.com/api/data\");\ncurl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n\n$result = curl_exec($ch);\n\nif(curl_errno($ch)){\n   echo 'Error:' . curl_error($ch);\n}\n\ncurl_close($ch);\n```",
        "resources": [
          {
            "type": "course",
            "title": "cURL",
            "url": "https://curl.se/"
          },
          {
            "type": "tutorial",
            "title": "curl/curl",
            "url": "https://github.com/curl/curl"
          },
          {
            "type": "course",
            "title": "cURL in PHP",
            "url": "https://www.php.net/manual/en/book.curl.php"
          }
        ]
      }
    },
    {
      "id": "_Al4NXKVQAnk8OikwvXCL",
      "name": "Guzzle",
      "resources": {
        "description": "# Guzzle\n\nGuzzle is a PHP HTTP client that simplifies making HTTP requests in PHP. It provides a straightforward and powerful way to send HTTP requests. Guzzle can simplify your life if you often handle APIs or other HTTP requests. It's great for everything from sending simple GET requests, to uploading files with POST requests, or even handling Errors using exception handling.",
        "resources": [
          {
            "type": "course",
            "title": "Guzzle Documentation",
            "url": "https://docs.guzzlephp.org/en/stable/"
          }
        ]
      }
    },
    {
      "id": "SD9k16UlVve9WtNMDA5Za",
      "name": "PHP-FIG",
      "resources": {
        "description": "# PHP-FIG\n\nPHP-FIG, also known as the PHP Framework Interoperability Group, is a vital part of PHP's ecosystem. This group has the main goal of creating PHP standards that promote interoperability among PHP frameworks, libraries, and other pieces of PHP based software. The group is responsible for PSR standards, which most modern PHP codes adhere to. Typically, it provides guidelines on coding style, logger interface, http cache, and more. Each PSR is designed to make PHP code more consistent and maintainable. By adhering to PHP-FIG's standards, developers enhance their ability to integrate and leverage third-party code within their projects.",
        "resources": [
          {
            "type": "course",
            "title": "PHP FIG",
            "url": "https://www.php-fig.org/psr/"
          }
        ]
      }
    },
    {
      "id": "3tONibbRgK7HCwGTE2Gqw",
      "name": "PSR Standards",
      "resources": {
        "description": "# PSR Standards\n\nThe PHP Framework Interop Group (PHP-FIG) introduced PHP Standard Recommendation (PSR) standards to provide a uniform and interoperable set of coding practices for PHP developers. PSR standards cover a variety of coding aspects such as code style (PSR-1, PSR-2), autoloading (PSR-4), and more. The PHP community widely accepts these standards contributing towards writing clean and easy-to-follow code. \n\nHere's a snippet to illustrate the PSR-4 autoloading standards in PHP:\n\n```php\n// Register the autoloader\nspl_autoload_register(function ($class) {\n    // Convert namespace to directory structure\n    $class = str_replace('\\\\', DIRECTORY_SEPARATOR, $class) . '.php';\n\n    // Get file if it exists\n    if (file_exists($class)) {\n        require $class;\n    }\n});\n```",
        "resources": [
          {
            "type": "course",
            "title": "PSR Standards",
            "url": "https://www.php-fig.org/psr/"
          }
        ]
      }
    },
    {
      "id": "_Dh78x_tPLqZweg--qZFQ",
      "name": "Profiling Techniques",
      "resources": {
        "description": "# Profiling Techniques\n\nProfiling is an analytical process within PHP that focuses on optimizing the applications performance. It involves pinpointing bottlenecks and problematic sections of your PHP code that cause poor performance, often using profiling tools. One such tool is Xdebug, which provides detailed information about how each line of code is executed. This process helps in understanding how long an operation takes to execute, which parts consume more memory, and which functions/methods are most frequently used, thereby enabling an optimization strategy. Here's a snippet of how to use Xdebug:\n\n```php\nxdebug_start_trace();\n// Your code here\nxdebug_stop_trace();\n```",
        "resources": [
          {
            "type": "course",
            "title": "Xdebug Profiler",
            "url": "https://xdebug.org/docs/profiler"
          }
        ]
      }
    },
    {
      "id": "Av-BMa57RvrLlAXLffOH0",
      "name": "Caching Strategies",
      "resources": {
        "description": "# Caching Strategies\n\nCaching Strategies are integral to Performance Optimization in PHP. Caching minimizes server load and enhances application speed by temporarily storing results of expensive operations, so that they can be reused in subsequent requests. Some caching techniques used in PHP include opcode caching, object caching, database query caching or full-page caching. For example, OPcache is an opcode caching system that improves PHP performance by storing precompiled script bytecode in memory, negating the need for PHP to load and parse scripts on every request.",
        "resources": [
          {
            "type": "course",
            "title": "Opcache",
            "url": "https://www.php.net/manual/en/book.opcache.php"
          }
        ]
      }
    },
    {
      "id": "bt7dK2PcOZ72B9HXPyMwL",
      "name": "Memory Management",
      "resources": {
        "description": "# Memory Management\n\nMemory Management is a crucial part of PHP performance optimization. Efficient memory use can significantly boost the speed and reliability of your PHP applications. PHP automatically provides a garbage collector which cleans up unused memory, but understanding and managing your script's memory usage can result in better use of resources. For instance, `unset()` function can help in freeing up memory by destroying the variables that are no longer used. Here is an example:\n\n```php\n$string = \"This is a long string that's going to use a lot of memory!\";\necho memory_get_usage();  // Outputs: 36640\nunset($string);\necho memory_get_usage();  // Outputs: 36640\n```\n\nIn this code snippet, you'll notice that the memory used remains the same even when the `$string` variable is unset. This is because `unset() ` only reduces the reference count of the variable in PHP's memory manager, and the memory will be cleared at the end of script execution. Avoiding unnecessary data storage and using inherent PHP functions, can help optimize memory management.",
        "resources": [
          {
            "type": "course",
            "title": "Memory Management",
            "url": "https://www.php.net/manual/en/features.gc.php"
          }
        ]
      }
    },
    {
      "id": "VpwwF8j5ZtXVSbzNfE7Sx",
      "name": "Configuration Tuning",
      "resources": {
        "description": "# Configuration Tuning\n\nFor performance optimization in PHP, configuration tuning is a crucial step. You can manipulate several settings in your php.ini file to enhance your PHP application's performance. For instance, `memory_limit` is a key parameter that specifies the maximum amount of memory a script can consume. Optimizing this setting will prevent the PHP scripts from eating up all server resources. Similarly, adjusting the `max_execution_time` limits the time a script runs. Just ensure careful configuration since restrictive settings could lead to issues. Here's a simple example of how you might modify these parameters:\n\n```php\n// Updating memory_limit\nini_set('memory_limit','256M');\n\n// Updating max_execution_time\nini_set('max_execution_time', '300');\n```",
        "resources": [
          {
            "type": "course",
            "title": "Configuration Tuning",
            "url": "https://www.php.net/manual/en/ini.core.php"
          }
        ]
      }
    },
    {
      "id": "NieqZd1juaNYoZOrB7e31",
      "name": "Opcode Caching",
      "resources": {
        "description": "# Opcode Caching\n\nOpcode caching is a technique that can significantly enhance the PHP performance. It works by storing precompiled script bytecode in memory, thus eliminating the need for PHP to load and parse scripts on each request. For opcode caching, OPCache extension is often used in PHP. With this, the PHP script's compiled version is stored for subsequent requests, reducing the overhead of code parsing and compiling. As a result, your applications experience faster execution and lower CPU usage. \n\nAn Example of a way to enable OPCache in your php.ini configuration file might look like:\n\n```ini\n   opcache.enable=1 \n   opcache.memory_consumption=128 \n   opcache.max_accelerated_files=4000 \n   opcache.revalidate_freq=60\n```",
        "resources": [
          {
            "type": "course",
            "title": "Opcode Caching",
            "url": "https://www.php.net/manual/en/book.opcache.php"
          }
        ]
      }
    },
    {
      "id": "VhyYNGhOdKKrz_-uTkrjD",
      "name": "Executing System Commands",
      "resources": {
        "description": "# Executing System Commands\n\nPHP provides developers with the flexibility to invoke system commands directly from PHP scripts. This can be achieved with functions like `exec()`, `system()`, or `passthru()`, which allow your PHP script to execute system-level instructions and interact with the underlying server. This can be useful in several scenarios - for automating tasks, orchestrating system activities, or even for pulling out system information. However, it's important to use these functions with caution due to the security risks of executing system commands. Here's a simple example of using the exec() function:\n\n```php\n<?php\n// Outputs all lines\nexec('ls', $output);\nforeach($output as $out){\n    echo $out, PHP_EOL;\n}\n?>\n```",
        "resources": [
          {
            "type": "course",
            "title": "Exec Function",
            "url": "https://www.php.net/manual/en/ref.exec.php"
          }
        ]
      }
    },
    {
      "id": "NTKUMgsKGYISIyhgOJPQn",
      "name": "Process Control",
      "resources": {
        "description": "# Process Control\n\nProcess Control, a crucial aspect of PHP system interactions, pertains to the ability to manage child processes within larger PHP scripts. Through the Process Control Extensions, PHP can create, monitor and control these child processes efficiently. These functions help develop robust client-server systems by managing and bringing multi-threading capabilities to single-threaded PHP scripts. For instance, when creating a new child process using pcntl_fork() function, the return value in the parent process is the PID of the newly created child process whereas, in the child process, '0' is returned. Remember, this feature isn't enabled by default in PHP. \n\nHere's a short PHP code demonstrating Process Control:\n\n```php\n<?php \n$pid = pcntl_fork();\nif ($pid == -1) {\n     die('could not fork');\n} else if ($pid) {\n     // we are the parent\n     pcntl_wait($status); // Protect against Zombie children\n} else {\n     // we are the child\n}\n?>\n```",
        "resources": [
          {
            "type": "course",
            "title": "Process Control",
            "url": "https://www.php.net/manual/en/ref.pcntl.php"
          }
        ]
      }
    },
    {
      "id": "fitjnLYKLHJ2P5G7JAvzm",
      "name": "Environment Variables",
      "resources": {
        "description": "# Environment Variables\n\nEnvironment variables provide a way to influence the behavior of software on your system. They consist of name/value pairs and are used for various purposes, such as to specify directory paths, usernames, or passwords that your PHP application might use. You can set PHP environment variables using the `putenv()` function, and retrieve them using `getenv()`. For example, if you want to set the environment variable \"FOO\" to \"bar\", you could do so like this:\n\n```php\nputenv(\"FOO=bar\");\n```\n\nAnd then you can retrieve the value with `getenv()` like:\n\n```php\necho getenv(\"FOO\"); // returns \"bar\"\n```\n\nKeep in mind that environment variables set using `putenv()` are only available for the duration of the current request. If you want them to persist for future requests, you'll need to set them using your system's method for setting environment variables.",
        "resources": [
          {
            "type": "course",
            "title": "Environment Variables",
            "url": "https://www.php.net/manual/en/function.putenv.php"
          }
        ]
      }
    },
    {
      "id": "DTaAZaU1CwzW7esoDhj85",
      "name": "Configuration Files",
      "resources": {
        "description": "# Configuration Files\n\nConfiguration files are critical for PHP applications because they help manage dynamic settings like database connection information, error reporting, and many other PHP settings without hard coding, making your application flexible and secure. PHP uses an \"php.ini\" file to hold these settings. You can modify settings by accessing and changing values in this file. For example, to adjust the maximum file upload size, you might modify the `upload_max_filesize` directive. However, changes to the `php.ini` file take effect only after the server is restarted.",
        "resources": [
          {
            "type": "course",
            "title": "PHP Config",
            "url": "https://www.php.net/manual/en/ini.list.php"
          }
        ]
      }
    },
    {
      "id": "lFoHoMRywCWa056ii5cKQ",
      "name": "Xdebug",
      "resources": {
        "description": "# Xdebug\n\nXdebug is a PHP extension that provides debugging and profiling capabilities. It's a powerful tool that can help you understand what your code is doing, track down bugs, and optimize performance. With Xdebug, you can set breakpoints, watch variables, and step through your code one line at a time. For instance, to start using Xdebug, you first need to install it and then initialize it in your code like so:\n\n```php\n<?php\n\nxdebug_start_trace();\n\n// Your code here...\n\nxdebug_stop_trace();\n?>\n```\nXdebug can significantly speed up bug-tracking and testing, making it an essential tool in any PHP developer's toolkit.",
        "resources": [
          {
            "type": "course",
            "title": "Xdebug",
            "url": "https://xdebug.org/"
          },
          {
            "type": "course",
            "title": "Xdebug Documentation",
            "url": "https://xdebug.org/docs/"
          }
        ]
      }
    },
    {
      "id": "KpQb5Zh3GUcbYUyXHvyu2",
      "name": "Zend Debugger",
      "resources": {
        "description": "# Zend Debugger\n\nZend Debugger is a PHP debugging extension used to identify issues in PHP scripts. It allows you to monitor and fix issues in your code, such as logical errors, and helps in boosting your web application's overall performance. Essentially, it becomes a simple yet powerful method for debugging server-side PHP scripts, by providing detailed debugging data and facilitating real-time interaction with the scripts. Using Zend Debugger with PHP can drastically improve the quality of your codebase and save considerable time in the development phase. A short usage example of Zend Debugger can be setting up a debug session, using the function `zend_debugger_connector_address()` which returns the IP address of the debugger currently in use.",
        "resources": [
          {
            "type": "course",
            "title": "Zend Debugger",
            "url": "https://www.zend.com/topics/Debugger-API"
          }
        ]
      }
    },
    {
      "id": "KMQqePqAjQ-ReDwHqeofx",
      "name": "Apache",
      "resources": {
        "description": "# Apache\n\nApache is a popular web server that can efficiently host PHP applications. Apache integrates well with PHP, using its `mod_php` module, providing a stable and consistent environment for your PHP scripts to run. This compatibility creates a seamless user experience, as PHP pages are served as if they're part of the website and not just files being executed on the server.",
        "resources": [
          {
            "type": "course",
            "title": "Apache PHP Documentation",
            "url": "https://www.php.net/manual/en/install.unix.apache2.php"
          },
          {
            "type": "course",
            "title": "Apache",
            "url": "https://httpd.apache.org/"
          }
        ]
      }
    },
    {
      "id": "aspZpACHEKOsi_Er5FYPY",
      "name": "Nginx",
      "resources": {
        "description": "# Nginx\n\nNginx is often deployed as a reverse proxy server for PHP applications, helping to manage client requests and load balance. Unlike traditional servers, Nginx handles numerous simultaneous connections more efficiently, proving instrumental in delivering PHP content faster. For PHP, one common configuration with Nginx involves PHP-FPM (FastCGI Process Manager). FastCGI is a variation on the earlier CGI (Common Gateway Interface), it allows for long-lived PHP processes that can service many requests, improving the performance of PHP applications. For instance, your Nginx server configuration for serving PHP files might include directives like these:\n\n```php\nlocation ~ \\.php$ {\n    include snippets/fastcgi-php.conf;\n    fastcgi_pass unix:/run/php/php7.0-fpm.sock;\n}\n```",
        "resources": [
          {
            "type": "course",
            "title": "Nginx Documentation",
            "url": "https://nginx.org/en/docs/"
          }
        ]
      }
    },
    {
      "id": "AoGS-5MSkp8gtJFQVPSBE",
      "name": "PHP-FPM",
      "resources": {
        "description": "# PHP-FPM\n\nPHP-FPM, or PHP FastCGI Process Manager, is a robust and efficient way to serve PHP applications. It dramatically improves the speed and processing efficiency of PHP apps by isolating each request, thus preventing jobs from interfering with each other. With PHP-FPM, your server can handle more simultaneous visitors without a slowdown. For example, to start using PHP-FPM with NGINX, you may include this configuration in your NGINX server block:\n\n```bash\nlocation ~ \\.php$ {\n    try_files $uri =404;\n    fastcgi_pass unix:/var/run/php/php7.4-fpm.sock;\n    fastcgi_index index.php;\n    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n    include fastcgi_params;\n}\n```\nHere `$uri` is the incoming request and `fastcgi_pass` should be the location where PHP-FPM listens.",
        "resources": [
          {
            "type": "course",
            "title": "PHP FPM",
            "url": "https://www.php.net/manual/en/install.fpm.php"
          }
        ]
      }
    }
  ],
  "edges": [
    {
      "source": "KMA7NkxFbPoUDtFnGBFnj",
      "target": "0vLaVNJaJSHZ_bHli6Qzs"
    },
    {
      "source": "iogwMmOvub2ZF4zgg6WyF",
      "target": "_hYN0gEi9BL24nptEtXWU"
    },
    {
      "source": "_hYN0gEi9BL24nptEtXWU",
      "target": "_LhLDVZjLt1DoAP1NuUES"
    },
    {
      "source": "_hYN0gEi9BL24nptEtXWU",
      "target": "b2CuLrhsUNnb4OxI6RRAS"
    },
    {
      "source": "_hYN0gEi9BL24nptEtXWU",
      "target": "6sHRQTcoKL3TlgNJlwyx8"
    },
    {
      "source": "_hYN0gEi9BL24nptEtXWU",
      "target": "qA7UjGPRBRZaBdgHTS5o3"
    },
    {
      "source": "qA7UjGPRBRZaBdgHTS5o3",
      "target": "OdUXxPZaAIgiqd46L26dY"
    },
    {
      "source": "qA7UjGPRBRZaBdgHTS5o3",
      "target": "3_TuxOSzBuktBlBF05r_z"
    },
    {
      "source": "BxU_vv4FsalsT1Hq0qRRK",
      "target": "usBwcXnWuUlaN71q1nbED"
    },
    {
      "source": "oKbeLp4YB8rI1Q3vi0EnG",
      "target": "JCCeVC0hOrvIeyfg1ScKA"
    },
    {
      "source": "usBwcXnWuUlaN71q1nbED",
      "target": "hzBUHSuFwLYNooF_vEmrs"
    },
    {
      "source": "usBwcXnWuUlaN71q1nbED",
      "target": "D0BtyxyjIBcpfn5wP23WC"
    },
    {
      "source": "usBwcXnWuUlaN71q1nbED",
      "target": "srIHPZabaCGdB5VvUXaMa"
    },
    {
      "source": "usBwcXnWuUlaN71q1nbED",
      "target": "pzReF4C0mcCWAnpfIJbwl"
    },
    {
      "source": "usBwcXnWuUlaN71q1nbED",
      "target": "bN07oOEWH_UrXKfpp8MB0"
    },
    {
      "source": "usBwcXnWuUlaN71q1nbED",
      "target": "IhKjvT6CjRz4dsSU7SNQo"
    },
    {
      "source": "IhKjvT6CjRz4dsSU7SNQo",
      "target": "j2S8dP3HlAOOoZdpj-7Dx"
    },
    {
      "source": "IhKjvT6CjRz4dsSU7SNQo",
      "target": "38YksjvhXCbgnHqkl57Cz"
    },
    {
      "source": "38YksjvhXCbgnHqkl57Cz",
      "target": "1NXSk8VZDr89jQTTkOL7x"
    },
    {
      "source": "qwt8xN4vuTrY-D0czYITI",
      "target": "WiGv7vi7Mtw-YqPMcnnyw"
    },
    {
      "source": "38YksjvhXCbgnHqkl57Cz",
      "target": "qwt8xN4vuTrY-D0czYITI"
    },
    {
      "source": "WiGv7vi7Mtw-YqPMcnnyw",
      "target": "1nODJchgSuWbcvSlxnWeE"
    },
    {
      "source": "WiGv7vi7Mtw-YqPMcnnyw",
      "target": "mpQKoBzsOa-5iWo08sOhQ"
    },
    {
      "source": "WiGv7vi7Mtw-YqPMcnnyw",
      "target": "RgVP99rJJ8FVecIA45w20"
    },
    {
      "source": "WiGv7vi7Mtw-YqPMcnnyw",
      "target": "RkNjYva8o_jXp9suz5YdG"
    },
    {
      "source": "WiGv7vi7Mtw-YqPMcnnyw",
      "target": "Nr5m6wQLp7VyG3AucrSc8"
    },
    {
      "source": "fBym6pkzRkNh0LWyCg3Bv",
      "target": "hitsVjqeIuzCP0VUZRXkS"
    },
    {
      "source": "WiGv7vi7Mtw-YqPMcnnyw",
      "target": "fBym6pkzRkNh0LWyCg3Bv"
    },
    {
      "source": "_V2EY4z-CTE4g-HtjU_ov",
      "target": "dv4WVzUCQ6d95AfBqdqQV"
    },
    {
      "source": "_V2EY4z-CTE4g-HtjU_ov",
      "target": "sYI7f1PYP7G30_Uj2mZRv"
    },
    {
      "source": "HNo8QO4aPbvgePiA4l6tq",
      "target": "CGehmZjcgTWC7fQAvxmNW"
    },
    {
      "source": "CGehmZjcgTWC7fQAvxmNW",
      "target": "so03-fK7E2WvTm6XsPq4i"
    },
    {
      "source": "CGehmZjcgTWC7fQAvxmNW",
      "target": "qobzzgzArNHLLn9Oiqc6G"
    },
    {
      "source": "77uKH6zwzzEycoZkGotpK",
      "target": "1mXQQdSdlKkWfjlT47nE0"
    },
    {
      "source": "uH9DTrDCBmBzXlup8KG3G",
      "target": "yTviiPFR5b_dr3WyxdxxQ"
    },
    {
      "source": "yTviiPFR5b_dr3WyxdxxQ",
      "target": "PIuplWreo7PFG3Mdn2t6W"
    },
    {
      "source": "yTviiPFR5b_dr3WyxdxxQ",
      "target": "oNUt1oT8pYBVvH0S2P6cb"
    },
    {
      "source": "yTviiPFR5b_dr3WyxdxxQ",
      "target": "MRAPXshy9RoYdReY6grf_"
    },
    {
      "source": "yTviiPFR5b_dr3WyxdxxQ",
      "target": "RD2RaBmA2XWkEa13PTCTX"
    },
    {
      "source": "yTviiPFR5b_dr3WyxdxxQ",
      "target": "qlkpwXfOc1p7j37hrzffI"
    },
    {
      "source": "yTviiPFR5b_dr3WyxdxxQ",
      "target": "c5q2e_jyMt8Pir5Od3lRi"
    },
    {
      "source": "yTviiPFR5b_dr3WyxdxxQ",
      "target": "BOWGF4ovKzGC_3MFQET9p"
    },
    {
      "source": "BOWGF4ovKzGC_3MFQET9p",
      "target": "gtq5KrghF28f5G8nuDcYQ"
    },
    {
      "source": "BOWGF4ovKzGC_3MFQET9p",
      "target": "ub79EkMiOmPBwXLRuYFL8"
    },
    {
      "source": "BOWGF4ovKzGC_3MFQET9p",
      "target": "vu0H-TsD7hkJgOQbSRj92"
    },
    {
      "source": "BOWGF4ovKzGC_3MFQET9p",
      "target": "GR09ns9B-0cONQaQ_uj-7"
    },
    {
      "source": "BOWGF4ovKzGC_3MFQET9p",
      "target": "9raJ06lKRZITbjWeLil-F"
    },
    {
      "source": "BOWGF4ovKzGC_3MFQET9p",
      "target": "rSXsPWto7Jeyw3Szl9pvf"
    },
    {
      "source": "BOWGF4ovKzGC_3MFQET9p",
      "target": "KEE50C6lOS4eX8sAbfhYe"
    },
    {
      "source": "BOWGF4ovKzGC_3MFQET9p",
      "target": "sPW-Ti2VyNYzxq6EYkbn7"
    },
    {
      "source": "BOWGF4ovKzGC_3MFQET9p",
      "target": "oAED9Fd5FFTB2Dm7Vi2JF"
    },
    {
      "source": "oAED9Fd5FFTB2Dm7Vi2JF",
      "target": "nWYHpcvp1RT1gSqs1Dqcs"
    },
    {
      "source": "PrG_5dyBblXsWYYRcOJMa",
      "target": "12k71gNfwAcT9K5aLWgbZ"
    },
    {
      "source": "6eWgZVLV479oQzl0fu-Od",
      "target": "PrG_5dyBblXsWYYRcOJMa"
    },
    {
      "source": "SD9k16UlVve9WtNMDA5Za",
      "target": "3tONibbRgK7HCwGTE2Gqw"
    },
    {
      "source": "SD9k16UlVve9WtNMDA5Za",
      "target": "okaY9JLgjz8JRaVAgz9Dr"
    },
    {
      "source": "okaY9JLgjz8JRaVAgz9Dr",
      "target": "gn5qNP3VTmmQE2tT6o-vS"
    }
  ]
}