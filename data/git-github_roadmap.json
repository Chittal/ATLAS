{
  "nodes": [
    {
      "id": "HlUUGj3dOZ68t4gIjerXh",
      "name": "Learn the Basics",
      "resources": {
        "description": "# Learn the Basics\n\nA Version Control System (VCS) is a tool that helps developers manage changes to their code over time. It allows multiple versions of a project to exist simultaneously, making it easier to collaborate with others and maintain a record of all modifications.",
        "resources": [
          {
            "type": "article",
            "title": "What is version control?",
            "url": "https://www.atlassian.com/git/tutorials/what-is-version-control"
          },
          {
            "type": "article",
            "title": "What is Git? - The Complete Guide to Git",
            "url": "https://www.datacamp.com/blog/all-about-git"
          },
          {
            "type": "article",
            "title": "Version Control (Git) - The Missing Semester of Your CS Education",
            "url": "https://missing.csail.mit.edu/2020/version-control/"
          },
          {
            "type": "video",
            "title": "What is Git? Explained in 2 Minutes!",
            "url": "https://www.youtube.com/watch?v=2ReR1YJrNOM"
          },
          {
            "type": "course",
            "title": "GUI Clients",
            "url": "https://git-scm.com/downloads/guis"
          },
          {
            "type": "course",
            "title": "Getting Started - Installing Git",
            "url": "https://git-scm.com/book/en/v2/Getting-Started-Installing-Git"
          },
          {
            "type": "course",
            "title": "Creating an account on GitHub",
            "url": "https://docs.github.com/en/get-started/start-your-journey/creating-an-account-on-github"
          }
        ]
      }
    },
    {
      "id": "bY6b1GV2XQQ52NOx8gWFj",
      "name": "What is Version Control?",
      "resources": {
        "description": "# What is Version Control?\n\nVersion control is a system that manages and tracks changes to files over time, allowing multiple people to collaborate on a project while maintaining a history of all modifications. It records changes to files, such as code, documents, or configuration files, and stores them in a repository. With version control, developers can revert to previous versions, compare differences between versions, and understand the evolution of a project. It supports features like branching, where different lines of development can occur independently, and merging, which combines changes from different branches. Overall, version control ensures that changes are organized, recoverable, and easily managed, making it a critical tool in software development and collaborative projects.",
        "resources": [
          {
            "type": "video",
            "title": "What is Git? Explained in 2 minutes",
            "url": "https://www.youtube.com/watch?v=2ReR1YJrNOM"
          },
          {
            "type": "article",
            "title": "What is version control?",
            "url": "https://www.atlassian.com/git/tutorials/what-is-version-control"
          }
        ]
      }
    },
    {
      "id": "dhIx1GnynvbSUriqYLUt0",
      "name": "Why use Version Control?",
      "resources": {
        "description": "# Why use Version Control?\n\nUsing version control is essential for managing changes in software development, as it enables tracking of modifications, collaboration, and maintaining a history of your project. It allows multiple developers to work on the same codebase simultaneously without overwriting each other's work, providing a clear record of who made changes and why. Version control systems facilitate rollback to previous versions if issues arise, and they support branching and merging, which are crucial for experimenting with new features and managing different stages of development. Overall, version control ensures code quality, accountability, and efficient collaboration in projects.",
        "resources": [
          {
            "type": "article",
            "title": "Benefits of using version control",
            "url": "https://www.techrepublic.com/article/version-control-benefits/"
          },
          {
            "type": "article",
            "title": "What is version control and why is it important?",
            "url": "https://start.docuware.com/blog/document-management/what-is-version-control-why-is-it-important"
          }
        ]
      }
    },
    {
      "id": "_jSTrYN9G8EsGHkbusKPU",
      "name": "Git vs Other VCS",
      "resources": {
        "description": "# Git vs Other VCS\n\nGit has become the de facto standard for source control in software development, but it's not the only version control system (VCS) available. Here are some key differences between Git and other popular VCS:\n\n- Mercurial: Mercurial is a distributed VCS that uses a similar architecture to Git. However, it has a more centralized approach and doesn't use hashes for tracking changes.\n- Subversion: Subversion is a centralized VCS that's often compared to Git. While both systems support branching and merging, Subversion requires a central server to manage the repository.\n- Perforce: Perforce is a commercial VCS that's designed for large-scale development projects. It uses a centralized approach and has features like build automation and issue tracking.\n- CVS: CVS is an older version control system that's still in use today. However, it lacks many modern features and is often considered outdated.",
        "resources": [
          {
            "type": "article",
            "title": "Git vs. Other VCS: A Comparative Analysis",
            "url": "https://medium.com/@pascalchinedu2000/git-vs-other-vcs-a-comparative-analysis-5cb03ad58e0e"
          }
        ]
      }
    },
    {
      "id": "v7hCNbgPByi3YiLSs46BK",
      "name": "Installing Git Locally",
      "resources": {
        "description": "# Installing Git Locally\n\nTo use Git on your local machine, you need to install it first. The installation process varies depending on your operating system:\n\n- On Windows: Download the binary from the official Git or GitHub release page and follow the installation instructions.\n- On macOS (using Homebrew): Run `brew install git` in your terminal.\n- On Linux: Run `sudo apt-get install git` or `sudo yum install git` depending on your distribution.\n\nOnce installed, you can verify the Git version by running `git --version` in your terminal. This will display the currently installed Git version.",
        "resources": [
          {
            "type": "course",
            "title": "Git - Downloads",
            "url": "https://git-scm.com/downloads"
          },
          {
            "type": "article",
            "title": "Install Git",
            "url": "https://github.com/git-guides/install-git"
          }
        ]
      }
    },
    {
      "id": "PtU5Qwfzn3N1i3oRlCGoR",
      "name": "What is a Repository",
      "resources": {
        "description": "# What is a Repository\n\nA repository is a storage location for your project's code, documentation, and other files. It serves as a central hub for collaboration, version control, and code management. It allows multiple people to work on the same project without overwriting each other's work.",
        "resources": [
          {
            "type": "article",
            "title": "About repositories",
            "url": "https://docs.github.com/en/repositories/creating-and-managing-repositories/about-repositories"
          },
          {
            "type": "article",
            "title": "What is a repository?",
            "url": "https://www.gitkraken.com/learn/git/tutorials/what-is-a-git-repository"
          }
        ]
      }
    },
    {
      "id": "1iOkbO5juk2LO-WZHx_W6",
      "name": "git init",
      "resources": {
        "description": "# git init\n\nThe `git init` command creates a new Git repository. It can be used to convert an existing, unversioned project to a Git repository or initialize a new, empty repository. Most other Git commands are not available outside of an initialized repository, so this is usually the first command you'll run in a new project.",
        "resources": [
          {
            "type": "course",
            "title": "Git - git-init Documentation",
            "url": "https://git-scm.com/docs/git-init"
          },
          {
            "type": "article",
            "title": "git init | Atlassian Git Tutorial",
            "url": "https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-init#:~:text=The%20git%20init%20command%20creates,run%20in%20a%20new%20project."
          }
        ]
      }
    },
    {
      "id": "NMCWgzhhfUvFOMO5GbF_u",
      "name": "git config",
      "resources": {
        "description": "# git config\n\nThe `git config` command is a convenience function that is used to set Git configuration values on a global or local project level. These configuration levels correspond to .gitconfig text files. Executing `git config` will modify a configuration text file.\n\nThe most basic use case for `git config` is to invoke it with a configuration name, which will display the set value at that name. Configuration names are dot delimited strings composed of a 'section' and a 'key' based on their hierarchy. For example: `user.email`",
        "resources": [
          {
            "type": "course",
            "title": "Git - git-config Documentation",
            "url": "https://git-scm.com/docs/git-config"
          },
          {
            "type": "article",
            "title": "git config | Atlassian Git Tutorial",
            "url": "https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-config"
          },
          {
            "type": "article",
            "title": "Setting your username in Git",
            "url": "https://docs.github.com/en/get-started/getting-started-with-git/setting-your-username-in-git"
          },
          {
            "type": "article",
            "title": "Git config commands | Git tutorial",
            "url": "https://nulab.com/learn/software-development/git-tutorial/git-commands-settings/git-config-commands/"
          }
        ]
      }
    },
    {
      "id": "tVvxC5JQgUb_B8kOqYpD8",
      "name": "Local vs Global Config",
      "resources": {
        "description": "# Local vs Global Config\n\nTo manage local and global configuration settings, you can use the git config command with the --local and --global options.\n\n- Local configuration: Run `git config --local [key] [value]` to set a local configuration setting for the current repository.\n- Global configuration: Use `git config --global [key] [value]` to set a global configuration setting that applies to all repositories on your system.",
        "resources": [
          {
            "type": "course",
            "title": "Customizing Git - Git Configuration",
            "url": "https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration"
          },
          {
            "type": "article",
            "title": "A step-by-step guide to setting up global Git config properties",
            "url": "https://medium.com/geekculture/a-step-by-step-guide-to-setting-up-git-config-global-properties-db6dbce30fa8"
          }
        ]
      }
    },
    {
      "id": "Sv36oxTZwlUv-i1K28NeP",
      "name": "Working Directory",
      "resources": {
        "description": "# Working Directory\n\nA working directory in Git is the local environment where files are stored and modified as part of a project. It reflects the current state of the project's files, allowing developers to edit, add, or delete files. Changes made in the working directory can be staged for commit, which means they're prepared for inclusion in the next commit. The working directory is connected to the Git repository, and it helps manage the differences between the committed history and the current state of the files. It plays a central role in tracking changes, testing, and developing new features.",
        "resources": [
          {
            "type": "article",
            "title": "Git vs Working Directory",
            "url": "https://codesweetly.com/git-vs-working-directory/"
          }
        ]
      }
    },
    {
      "id": "h71Tx3nkfUrnhaqcHlDkQ",
      "name": "Staging Area",
      "resources": {
        "description": "# Staging Area\n\nIn Git, a staging area serves as an intermediate step between your local repository changes and the actual commit.\n\n- Temporary storage: The staging area holds changes that are intended to be part of the next commit.\n- Previewing changes: It allows you to preview your changes before committing them.",
        "resources": [
          {
            "type": "course",
            "title": "Getting Started - What is Git? - Staging Area",
            "url": "https://git-scm.com/book/en/v2/Getting-Started-What-is-Git%3F#:~:text=The%20staging%20area%20is%20a,area%E2%80%9D%20works%20just%20as%20well."
          },
          {
            "type": "video",
            "title": "What are Staged Changes in Git?",
            "url": "https://www.youtube.com/watch?v=HyeNfWZBut8"
          }
        ]
      }
    },
    {
      "id": "2_z3R7seCvQVj-Na4H1SV",
      "name": "Committing Changes",
      "resources": {
        "description": "# Committing Changes\n\nCommitting changes in Git is a crucial part of version control, allowing you to save your progress and record a snapshot of your project's current state.",
        "resources": [
          {
            "type": "course",
            "title": "How git commit works",
            "url": "https://github.com/git-guides/git-commit"
          },
          {
            "type": "article",
            "title": "Git commit",
            "url": "https://www.atlassian.com/git/tutorials/saving-changes/git-commit"
          }
        ]
      }
    },
    {
      "id": "oz2oRAhaEQb0Fm3aRJQG8",
      "name": ".gitignore",
      "resources": {
        "description": "# .gitignore\n\nIgnored files are tracked in a special file named `.gitignore` that is checked in at the root of your repository. There is no explicit git ignore command: instead the `.gitignore` file must be edited and committed by hand when you have new files that you wish to ignore. `.gitignore` files contain patterns that are matched against file names in your repository to determine whether or not they should be ignored.",
        "resources": [
          {
            "type": "course",
            "title": "gitignore Documentation",
            "url": "https://git-scm.com/docs/gitignore"
          },
          {
            "type": "article",
            "title": ".gitignore file - ignoring files in Git | Atlassian Git Tutorial",
            "url": "https://www.atlassian.com/git/tutorials/saving-changes/gitignore"
          },
          {
            "type": "article",
            "title": "Ignoring files - GitHub Docs",
            "url": "https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files"
          },
          {
            "type": "tutorial",
            "title": "gitignore - A collection of useful .gitignore templates",
            "url": "https://github.com/github/gitignore"
          }
        ]
      }
    },
    {
      "id": "IfUm5D_zNaUKMd4HX4Fi4",
      "name": "Viewing Commit History",
      "resources": {
        "description": "# Viewing Commit History\n\nViewing commit history is a crucial aspect of Git, allowing users to examine the chronological record of repository changes. This feature is essential for understanding project evolution, tracking modifications, and facilitating effective team collaboration. Git provides various commands like `git log` and its options (e.g., `--oneline`, `--graph`, `--patch`, `--stat`) to display commit history in different formats. Users can filter commits by author, date range, and other criteria. By regularly reviewing commit history and following best practices such as writing clear commit messages and using tags, developers can gain valuable insights into their project's development and make informed decisions about future changes.",
        "resources": [
          {
            "type": "course",
            "title": "Git Basics - Viewing the Commit History",
            "url": "https://git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History"
          },
          {
            "type": "article",
            "title": "How to Use Git Log to View Commit History",
            "url": "https://www.freecodecamp.org/news/git-log-command/"
          }
        ]
      }
    },
    {
      "id": "bXfCUG3h1TIFPgD4WUDph",
      "name": "Branching Basics",
      "resources": {
        "description": "# Collaboration\n\nWhen working on projects with others, Git provides tools to facilitate collaboration through forking repositories using `git clone` or `git fork`, cloning them locally with git clone, managing pull requests with `git request-pull`, and resolving merge conflicts. To contribute effectively, follow established contributing guides and respect open-source licenses that govern how contributors' work may be used by others.",
        "resources": [
          {
            "type": "article",
            "title": "Git Fork and Git Clone: The difference and why it's important!",
            "url": "https://dev.to/danielasaboro/git-fork-and-clone-whats-the-difference-190c"
          },
          {
            "type": "article",
            "title": "About pull requests",
            "url": "https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests"
          },
          {
            "type": "article",
            "title": "About merge conflicts",
            "url": "https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/addressing-merge-conflicts/about-merge-conflicts"
          },
          {
            "type": "article",
            "title": "Setting guidelines for repository contributors",
            "url": "https://docs.github.com/en/communities/setting-up-your-project-for-healthy-contributions/setting-guidelines-for-repository-contributors"
          },
          {
            "type": "video",
            "title": "Git Fork vs Git Clone (Animated)",
            "url": "https://www.youtube.com/watch?v=rxh6MhK6Tbs"
          },
          {
            "type": "video",
            "title": "The EXTREMELY helpful guide to merge conflicts",
            "url": "https://www.youtube.com/watch?v=HosPml1qkrg"
          },
          {
            "type": "video",
            "title": "Free and Open Source software licenses explained",
            "url": "https://www.youtube.com/watch?v=UMIG4KnM8xw"
          },
          {
            "type": "course",
            "title": "OSI Approved Licenses",
            "url": "https://opensource.org/licenses"
          }
        ]
      }
    },
    {
      "id": "OegitQ5Ngjvd3ZfMpfrkM",
      "name": "Creating Branch",
      "resources": {
        "description": "# Creating Branch\n\nCreating a branch in Git is a fundamental part of working with version control, allowing you to work on different features or fixes without affecting the main codebase. You can create branches either through the terminal or github interface",
        "resources": [
          {
            "type": "course",
            "title": "Git branch documentation",
            "url": "https://git-scm.com/docs/git-branch"
          },
          {
            "type": "article",
            "title": "Git branch",
            "url": "https://www.atlassian.com/git/tutorials/using-branches"
          }
        ]
      }
    },
    {
      "id": "_dPOVUbxApx0pfKPH8fgr",
      "name": "Renaming Branch",
      "resources": {
        "description": "# Renaming Branch\n\nRenaming a branch in Git means changing the name of a branch to something different while preserving its history and the commits it contains. The branch itself remains the same in terms of the code and history it tracks, but the reference (the name by which you refer to it) is updated",
        "resources": [
          {
            "type": "course",
            "title": "Renaming a Branch - GitHub Docs",
            "url": "https://docs.github.com/github/administering-a-repository/renaming-a-branch"
          },
          {
            "type": "article",
            "title": "Git Rename Branch – How to Change a Local Branch Name",
            "url": "https://www.freecodecamp.org/news/git-rename-branch-how-to-change-a-local-branch-name/"
          }
        ]
      }
    },
    {
      "id": "1uDenoQ6zu7CT69FR2iQB",
      "name": "Deleting Branch",
      "resources": {
        "description": "# Deleting Branch\n\nDeleting a Git branch means removing a line of development from your Git repository. A branch in Git is essentially a pointer to a specific commit, representing an independent line of development. When you delete a branch, you’re removing this pointer, making that line of development no longer accessible through the branch name.",
        "resources": [
          {
            "type": "course",
            "title": "Creating and deleting branches within your repository",
            "url": "https://docs.github.com/articles/creating-and-deleting-branches-within-your-repository"
          },
          {
            "type": "article",
            "title": "How to Delete a Git Branch Both Locally and Remotely",
            "url": "https://www.freecodecamp.org/news/how-to-delete-a-git-branch-both-locally-and-remotely/"
          }
        ]
      }
    },
    {
      "id": "PtRo-wGiNAagZ6CykfvMr",
      "name": "Checkout Branch",
      "resources": {
        "description": "# Checkout Branch\n\nIn Git, to \"checkout\" from a branch means to switch your working directory to that branch, making it the active branch. This updates your files to match the state of that branch and allows you to work on it.",
        "resources": [
          {
            "type": "course",
            "title": "git-checkout",
            "url": "https://git-scm.com/docs/git-checkout"
          },
          {
            "type": "article",
            "title": "git-commands-checkout",
            "url": "https://www.git-tower.com/learn/git/commands/git-checkout"
          },
          {
            "type": "video",
            "title": "Git Checkout. Different ways of using the checkout command in the Git Project",
            "url": "https://youtu.be/h_PIHOFUYuw?si=tebKCCb5U3ues0Io"
          }
        ]
      }
    },
    {
      "id": "sNuy6NMjLOEkJlqdEjFPq",
      "name": "Merging Basics",
      "resources": {
        "description": "# Merging Basics\n\nA merge in Git is the process of combining changes from one branch into another. When you want to integrate updates from one branch (the source) into another branch (the target), you need to perform a merge. This involves resolving conflicts between the two branches, if any exist. The goal of merging is to create a new commit that represents the combined changes from both branches, resulting in a single, cohesive history for your project.",
        "resources": [
          {
            "type": "course",
            "title": "Git Branching - Basic Merging",
            "url": "https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging#:~:text=into%20master%20later.-,Basic%20Merging,-Suppose%20you%E2%80%99ve%20decided"
          },
          {
            "type": "article",
            "title": "Git merge",
            "url": "https://www.atlassian.com/git/tutorials/using-branches/git-merge"
          }
        ]
      }
    },
    {
      "id": "NeSvgS2yA5x8qbcJHrV__",
      "name": "GitHub Essentials",
      "resources": {
        "description": "# GitHub Essentials\n\nGitHub Essentials refers to the core features and functionalities that form the foundation of GitHub's version control and collaboration platform. These essentials include repositories for storing and managing code, branches for parallel development, pull requests for code review and merging, issues for tracking tasks and bugs, and collaborative tools like project boards and wikis. Understanding and mastering these fundamental components allows developers to effectively manage their projects, collaborate with team members, and contribute to open-source initiatives, making GitHub an indispensable tool in modern software development workflows.",
        "resources": [
          {
            "type": "course",
            "title": "GitHub Essentials - Microsoft",
            "url": "https://learn.microsoft.com/en-us/contribute/content/git-github-fundamentals"
          },
          {
            "type": "course",
            "title": "Hello World",
            "url": "https://docs.github.com/en/get-started/start-your-journey/hello-world"
          }
        ]
      }
    },
    {
      "id": "i7fIIHcBEk473te8bniJ5",
      "name": "Creating Account",
      "resources": {
        "description": "# Creating Account\n\nTo get started with GitHub, you'll need to create a free personal account on GitHub.com and verify your email address. Every person who uses GitHub.com signs in to a personal account. Your personal account is your identity on GitHub.com and has a username and profile.",
        "resources": [
          {
            "type": "course",
            "title": "Creating an Account on GitHub",
            "url": "https://docs.github.com/en/get-started/start-your-journey/creating-an-account-on-github"
          }
        ]
      }
    },
    {
      "id": "qZFtRABvlBbVvsy6T00J2",
      "name": "GitHub Interface",
      "resources": {
        "description": "# GitHub Interface\n\nThe GitHub interface is a web-based platform that provides a user-friendly environment for managing and collaborating on software projects. It offers a comprehensive set of tools and features accessible through an intuitive layout, including repository management, code browsing, issue tracking, pull requests, and project boards. The interface is designed to streamline workflows, facilitate team communication, and enhance productivity for developers of all skill levels. With its clean and organized structure, users can easily navigate between different sections of their projects, review code changes, manage tasks, and interact with team members, making it an essential tool for modern software development and version control.",
        "resources": [
          {
            "type": "course",
            "title": "GitHub Desktop App",
            "url": "https://github.com/apps/desktop"
          },
          {
            "type": "article",
            "title": "Getting Started with GitHub",
            "url": "https://digital.gov/resources/an-introduction-github/"
          }
        ]
      }
    },
    {
      "id": "GS3f1FKFVKT0-GJQrgCm8",
      "name": "Setting up Profile",
      "resources": {
        "description": "# Setting up Profile\n\nOn GitHub, creating a profile is an essential step in showcasing yourself as a developer or contributor.\n\n- Sharing information: Your profile page allows others to find out more about you, including your interests and skills.\n- Showcasing projects: You can display your notable projects and contributions, giving a glimpse into your work experience.\n- Expressing identity: The profile also serves as an opportunity for personal expression, allowing you to convey your unique personality and style within the GitHub community.",
        "resources": [
          {
            "type": "course",
            "title": "Setting up your profile",
            "url": "https://docs.github.com/en/get-started/start-your-journey/setting-up-your-profile"
          },
          {
            "type": "video",
            "title": "GitHub Profile Readme",
            "url": "https://www.youtube.com/watch?v=KhGWbt1dAKQ"
          }
        ]
      }
    },
    {
      "id": "c_FO6xMixrrMo6iisfsvl",
      "name": "Creating Repositories",
      "resources": {
        "description": "# Creating Repositories\n\nCreating a Git repository means setting up a system to track changes in your project's files over time. This is crucial for version control, allowing you to manage, review, and collaborate on code efficiently.",
        "resources": [
          {
            "type": "course",
            "title": "Quickstart for repositories - GitHub Docs",
            "url": "https://docs.github.com/en/repositories/creating-and-managing-repositories/quickstart-for-repositories"
          }
        ]
      }
    },
    {
      "id": "KbVvFVQ4k77R2_ddsc7WT",
      "name": "Profile Readme",
      "resources": {
        "description": "# Profile Readme\n\nA GitHub Profile README is a special repository that allows users to showcase their skills, projects, and personality directly on their GitHub profile. To create one, you need to make a new repository with the same name as your GitHub username. This repository should contain a README.md file, which GitHub will automatically display on your profile page. The README can be customized with Markdown formatting, allowing you to add text, images, links, and even dynamic content like GitHub stats or recent blog posts. This feature provides a unique opportunity to make your GitHub profile more engaging and informative for visitors, effectively serving as a personalized landing page for your GitHub presence.",
        "resources": [
          {
            "type": "course",
            "title": "Managing your Profile README",
            "url": "https://docs.github.com/en/account-and-profile/setting-up-and-managing-your-github-profile/customizing-your-profile/managing-your-profile-readme"
          },
          {
            "type": "video",
            "title": "GitHub Profile README",
            "url": "https://www.youtube.com/watch?v=KhGWbt1dAKQ"
          }
        ]
      }
    },
    {
      "id": "HEqBbw_A4ZbJI5zEy8ViN",
      "name": "Private vs Public",
      "resources": {
        "description": "# Private vs Public\n\nGitHub offers both private and public repositories, each serving different purposes in software development. Public repositories are visible to everyone on the internet, making them ideal for open-source projects, collaboration, and showcasing work to a wider audience. They encourage community contributions and can help developers build their portfolios. Private repositories, on the other hand, are only accessible to the repository owner and designated collaborators. These are suitable for proprietary code, sensitive projects, or work that's not ready for public consumption. Private repositories offer greater control over access and visibility, making them essential for businesses and individuals who need to keep their code confidential.",
        "resources": [
          {
            "type": "course",
            "title": "About project visibility",
            "url": "https://docs.github.com/en/repositories/creating-and-managing-repositories/about-repositories#about-repository-visibility"
          }
        ]
      }
    },
    {
      "id": "aWx9WHUrgofcTr8B-fQYe",
      "name": "Git Remotes",
      "resources": {
        "description": "# Git Remotes\n\nIn Git, a remote is a reference to a repository that exists on another server or system. Remotes allow you to access and interact with a copy of your repository that is stored elsewhere, making it possible to collaborate with others, share your work, and maintain multiple copies of your repository for backup and disaster recovery purposes. When you add a remote to your local repository, Git creates a reference to the remote repository, enabling you to push changes from your local repository to the remote one, pull changes from the remote to your local one, or fetch changes from the remote without updating your local copy. This enables distributed development and helps maintain a centralized version of your project's history, making it easier to track changes, manage conflicts, and ensure that everyone has access to the most up-to-date code.",
        "resources": [
          {
            "type": "course",
            "title": "About Remote Repositories",
            "url": "https://docs.github.com/en/get-started/getting-started-with-git/about-remote-repositories"
          }
        ]
      }
    },
    {
      "id": "sBQOInoFBU9XfkPZ-JlyT",
      "name": "Managing Remotes",
      "resources": {
        "description": "# Managing Remotes\n\nIn Git, a remote repository refers to a copy of a project's source code stored on a server or other machine.\n\n- Adding remotes: Use `git remote add [name] [url]` to add a new remote repository. This allows you to track changes and push/pull updates from the remote.\n- Listing remotes: Run `git remote -v` to list all configured remotes with their URLs.\n- Renaming remotes: Update the name of an existing remote using `git remote rename [old-name] [new-name]`.\n- Deleting remotes: Remove a remote repository with `git remote remove [name]`.\n\nManaging remotes is essential for collaborating on projects or tracking changes from upstream sources.",
        "resources": [
          {
            "type": "course",
            "title": "Managing remote repositories",
            "url": "https://docs.github.com/en/get-started/getting-started-with-git/managing-remote-repositories"
          }
        ]
      }
    },
    {
      "id": "ZVMCh9om37ee1qsecFa-N",
      "name": "Pushing / Pulling Changes",
      "resources": {
        "description": "# Pushing / Pulling Changes\n\nWhen you pull changes in Git, you're fetching and integrating changes from a remote repository into your local repository. This operation updates your local branch with the latest changes from the remote branch. Whereas When you push changes in Git, you're sending your local commits to a remote repository, such as GitHub, GitLab, or Bitbucket. This operation updates the remote repository with your latest changes.",
        "resources": [
          {
            "type": "course",
            "title": "Pushing commits to a remote repository",
            "url": "https://docs.github.com/en/get-started/using-git/pushing-commits-to-a-remote-repository"
          },
          {
            "type": "article",
            "title": "A Comprehensive Guide to git pull and git push",
            "url": "https://dev.to/alexmercedcoder/mastering-git-a-comprehensive-guide-to-git-pull-and-git-push-2eo3"
          },
          {
            "type": "article",
            "title": "Git Push and Pull Tutorial",
            "url": "https://www.datacamp.com/tutorial/git-push-pull"
          }
        ]
      }
    },
    {
      "id": "Gybnekbd1rJKTOf4hJ4Sh",
      "name": "Fetch without Merge",
      "resources": {
        "description": "# Fetch without Merge\n\nRunning `git fetch` retrieves changes from a remote repository into your local clone, but does not automatically merge any of these changes into your local working directory. This is different from `git pull`, which both fetches and merges remote changes. By using fetch without merge, you can ensure that your local clone is up-to-date with the latest information from the remote repository, while leaving your working directory unchanged. You can then choose to apply these changes by using merge or rebase. This approach helps maintain a clean and consistent local state, making it easier to manage and commit changes.",
        "resources": [
          {
            "type": "course",
            "title": "Git Fetch",
            "url": "https://git-scm.com/docs/git-fetch"
          },
          {
            "type": "article",
            "title": "Git fetch",
            "url": "https://www.atlassian.com/git/tutorials/syncing/git-fetch"
          },
          {
            "type": "video",
            "title": "Git Fetch | What is Git Fetch and How to Use it | Learn Git",
            "url": "https://www.youtube.com/watch?v=uEEcw1s_wWk"
          }
        ]
      }
    },
    {
      "id": "d_GNnB6PBINz1jxGNWAE-",
      "name": "Collaboration on GitHub",
      "resources": {
        "description": "# Collaboration on GitHub\n\nCollaboration on GitHub is a powerful way for multiple people to work together on the same project, using Git as the version control system. GitHub provides various tools and workflows that make collaboration efficient and organized.",
        "resources": [
          {
            "type": "course",
            "title": "How to collaborate in a GitHub project",
            "url": "https://gist.github.com/neklaf/9002d3acccf6b6e448db5c4c4e8764c0"
          },
          {
            "type": "article",
            "title": "Best Practices for collaborating in github",
            "url": "https://www.gitkraken.com/blog/collaborate-on-github"
          },
          {
            "type": "article",
            "title": "Working with GitHub in VS Code",
            "url": "https://code.visualstudio.com/docs/sourcecontrol/github"
          }
        ]
      }
    },
    {
      "id": "l1Wf7Pe_ah8ycCgslfSK4",
      "name": "Forking vs Cloning",
      "resources": {
        "description": "# Forking vs Cloning\n\nForking and cloning are two fundamental concepts in Git, particularly when working with repositories hosted on platforms like GitHub, GitLab, or Bitbucket. While both actions involve copying a repository, they serve different purposes and have distinct workflows.\nCloning a repository means creating a local copy of a repository that exists on a remote server (e.g., GitHub) on your local machine. This allows you to work on the project locally, make changes, and then push those changes back to the remote repository if you have the necessary permissions.\nForking a repository is specific to platforms like GitHub, GitLab, and Bitbucket. When you fork a repository, you create a copy of someone else’s repository in your own account. This forked repository is independent of the original and can be modified without affecting the original project.",
        "resources": [
          {
            "type": "course",
            "title": "The difference between forking and cloning a repository",
            "url": "https://github.com/orgs/community/discussions/35849"
          },
          {
            "type": "article",
            "title": "Git fork vs. clone: What's the difference?",
            "url": "https://www.theserverside.com/answer/Git-fork-vs-clone-Whats-the-difference"
          },
          {
            "type": "video",
            "title": "Git Fork vs. Git Clone: What's the Difference?",
            "url": "https://youtu.be/6YQxkxw8nhE?si=mJNvcaB4lQccsU57"
          },
          {
            "type": "video",
            "title": "GitHub Forking vs Cloning: Key Differences Explained",
            "url": "https://youtu.be/yQSjqYs2UBE?si=3BKYtWmkLIMWvA6G"
          }
        ]
      }
    },
    {
      "id": "crdllx5cH_seIpgVPvHg_",
      "name": "Issues",
      "resources": {
        "description": "# Issues\n\nOn GitHub, an issue is a way to track and report bugs, feature requests, or other problems with a repository. Here are some key aspects of issues:\n\n- Creating issues: Users can create new issues by submitting a form on the repository's Issues page.\n- Issue titles and descriptions: Each issue has a title and body (description), which provide context for the problem or request.\n- Assignees: Issues can be assigned to specific users, who are then responsible for addressing the issue.\n- Labels: Labels are used to categorize issues by topic, priority, or other criteria. This helps filter and organize issues within a repository.\n- States: Issues have states that reflect their status, such as \"Open\", \"Closed\", or \"Pending\".\n- Comments: Users can comment on existing issues to discuss or provide additional context.\n- Labels and milestones: Issues can be associated with labels (topics) and milestones (deadlines), which help filter and prioritize them.\n\nIssues are a core feature of GitHub repositories, enabling teams to collaborate effectively on resolving problems and implementing new features.",
        "resources": [
          {
            "type": "course",
            "title": "About Issues",
            "url": "https://docs.github.com/en/issues/tracking-your-work-with-issues/about-issues"
          },
          {
            "type": "video",
            "title": "What is GitHub Issues?",
            "url": "https://www.youtube.com/watch?v=6HWw7rhwvtY"
          }
        ]
      }
    },
    {
      "id": "1Koej79yTv-OAswVZwgGq",
      "name": "Cloning Repositories",
      "resources": {
        "description": "# Cloning Repositories\n\nCloning a repository in Git and GitHub involves creating a local copy of a remote repository on your computer. This allows you to work on the project locally, commit changes, and later push those changes back to the remote repository.",
        "resources": [
          {
            "type": "course",
            "title": "git clone",
            "url": "https://git-scm.com/docs/git-clone"
          },
          {
            "type": "course",
            "title": "Cloning a Repository",
            "url": "https://docs.github.com/en/repositories/creating-and-managing-repositories/cloning-a-repository"
          },
          {
            "type": "article",
            "title": "Clone a Git Repository",
            "url": "https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-clone"
          },
          {
            "type": "video",
            "title": "Cloning Remote Repository into local machine",
            "url": "https://youtu.be/xeQih8LVtZM?si=djlyTDpLNS0oyqQH"
          }
        ]
      }
    },
    {
      "id": "x6eILrLCQrVpz4j8uOuy6",
      "name": "Pull Requests",
      "resources": {
        "description": "# Pull Requests\n\nA pull request is a proposal to merge a set of changes from one branch into another. In a pull request, collaborators can review and discuss the proposed set of changes before they integrate the changes into the main codebase. Pull requests display the differences, or diffs, between the content in the source branch and the content in the target branch.",
        "resources": [
          {
            "type": "course",
            "title": "Creating a pull request",
            "url": "https://docs.github.com/articles/creating-a-pull-request"
          },
          {
            "type": "article",
            "title": "Pull Requests",
            "url": "https://www.atlassian.com/git/tutorials/making-a-pull-request#:~:text=In%20their%20simplest%20form%2C%20pull,request%20via%20their%20Bitbucket%20account."
          },
          {
            "type": "video",
            "title": "GitHub Pull Request in 100 Seconds ",
            "url": "https://youtu.be/8lGpZkjnkt4?si=qbCQ8Uvzn9GN2koL"
          }
        ]
      }
    },
    {
      "id": "8lXXVFkgK6n5IHaYkYe3l",
      "name": "PR from a Fork",
      "resources": {
        "description": "# PR from a Fork\n\nCreating a pull request from a fork on GitHub is a common workflow for contributing to open-source projects or collaborating on repositories you don't have direct write access to. After forking the original repository to your GitHub account, you can make changes in your fork, commit them, and then create a pull request to propose these changes to the original repository. This process allows project maintainers to review your contributions, discuss any necessary modifications, and ultimately merge your changes into the main project if they're approved. It's an essential feature that facilitates collaboration and code review in distributed development environments.",
        "resources": [
          {
            "type": "course",
            "title": "Creating a pull request from a fork",
            "url": "https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request-from-a-fork"
          },
          {
            "type": "video",
            "title": "How to Create a Pull Request from a Fork on GitHub",
            "url": "https://www.youtube.com/watch?v=a_FLqX3vGR4"
          }
        ]
      }
    },
    {
      "id": "r-u1vTpUyuvsB0revOU0C",
      "name": "Collaborators",
      "resources": {
        "description": "# Collaborators\n\nCollaborators in GitHub are users who have been granted direct access to a repository by the repository owner or organization administrators. Collaborators can perform actions like pushing commits, creating branches, and managing issues or pull requests, depending on the permissions granted to them. They are typically added to private repositories or to public repositories where more control over contributions is needed.",
        "resources": [
          {
            "type": "course",
            "title": "How to add collaborators to your personal projects",
            "url": "https://docs.github.com/en/account-and-profile/setting-up-and-managing-your-personal-account-on-github/managing-access-to-your-personal-repositories/inviting-collaborators-to-a-personal-repository"
          },
          {
            "type": "course",
            "title": "Adding outside collaborators to repositories in your organization",
            "url": "https://docs.github.com/en/organizations/managing-user-access-to-your-organizations-repositories/managing-outside-collaborators/adding-outside-collaborators-to-repositories-in-your-organization"
          },
          {
            "type": "article",
            "title": "How to Add Collaborators to Your GitHub Repository",
            "url": "https://www.blinkops.com/blog/how-to-add-collaborators-to-your-github-repository"
          },
          {
            "type": "video",
            "title": "Using GitHub for Team collaboration",
            "url": "https://youtu.be/4nyIS58ORWw?si=yK5LCONNVm9OIUK5"
          }
        ]
      }
    },
    {
      "id": "y4DkB5NvTh41IeT0G2gr-",
      "name": "Labelling Issues / PRs",
      "resources": {
        "description": "# Labelling Issues / PRs\n\nOn GitHub, labels are a way to categorize issues and pull requests (PRs) by topic, priority, or other criteria. Some common labels used are:\n\n- `Bug`\n- `Duplicate`\n- `Enhancement`\n- `Feature request`\n- `High priority`\n- `Needs feedback`",
        "resources": [
          {
            "type": "course",
            "title": "Managing labels",
            "url": "https://docs.github.com/en/issues/using-labels-and-milestones-to-track-work/managing-labels"
          }
        ]
      }
    },
    {
      "id": "dQS1V0zZxeKhHhUo3STBK",
      "name": "Saved Replies",
      "resources": {
        "description": "# Saved Replies\n\nGitHub allows you to save frequently used comments and reuse them when discussing issues or pull requests.\n\n- Saved replies: You can create pre-written comments that can be easily added to conversations.\n- Customization: Saved replies can be edited to fit specific situations, making it easy to tailor your responses.",
        "resources": [
          {
            "type": "course",
            "title": "Using saved replies",
            "url": "https://docs.github.com/en/get-started/writing-on-github/working-with-saved-replies/using-saved-replies"
          },
          {
            "type": "article",
            "title": "Walkthrough: Using GitHub’s “Saved Replies” to make life consistent and easy",
            "url": "https://prowe214.medium.com/walkthrough-using-githubs-saved-replies-to-make-life-consistent-and-easy-80f23efe6a0"
          }
        ]
      }
    },
    {
      "id": "oWMaOWU06juoIuzXNe-wt",
      "name": "Mentions",
      "resources": {
        "description": "# Mentions\n\nMentions on GitHub allow you to notify specific users or teams about comments, issues, pull requests, or other activities. This feature improves collaboration by encouraging participation and discussion among team members, increasing visibility of important topics, and streamlining communication within your repository. To use mentions, simply type `@username` or `@teamname` in a comment, and GitHub will auto-complete the mention as you type, automatically linking their username to the comment and notifying them about the discussion.",
        "resources": [
          {
            "type": "course",
            "title": "Mention Somebody",
            "url": "https://github.blog/news-insights/mention-somebody-they-re-notified/"
          }
        ]
      }
    },
    {
      "id": "XstmIysIi_lWo6RzszLBt",
      "name": "Reactions",
      "resources": {
        "description": "# Reactions\n\nReactions in GitHub are a way for users to express their feelings or opinions about issues, pull requests, comments, and other discussions without adding additional comments. They are similar to \"likes\" or \"emojis\" on social media platforms, providing a quick and non-verbal way to engage with content.",
        "resources": [
          {
            "type": "course",
            "title": "Add Reactions to Pull Requests, Issues, and Comments",
            "url": "https://github.blog/news-insights/product-news/add-reactions-to-pull-requests-issues-and-comments/"
          }
        ]
      }
    },
    {
      "id": "0rHDUbAdXqH9zQW2VfJ8v",
      "name": "Merge Strategies",
      "resources": {
        "description": "# Merge Strategies\n\nWhen combining changes from one branch into another, Git provides various merge strategies to choose from. These methods allow for flexibility and customization in integrating code updates into your main branch. The available options include:\n\n- Fast Forward (FF)\n- Non-Fast Forward\n- Rebase\n- Squash\n- Cherry Picking",
        "resources": [
          {
            "type": "course",
            "title": "Git Merge Strategies",
            "url": "https://git-scm.com/docs/merge-strategies"
          },
          {
            "type": "article",
            "title": "Git Merge Options",
            "url": "https://www.atlassian.com/git/tutorials/using-branches/merge-strategy"
          }
        ]
      }
    },
    {
      "id": "agtPWS8j6i6wQPk10cy8E",
      "name": "Fast-Forward vs Non-FF",
      "resources": {
        "description": "# Fast-Forward vs Non-FF\n\nIn Git, when you merge branches, there are two primary types of merges: Fast-Forward and Non-Fast-Forward (No-FF). These terms describe how Git handles the history and pointers when merging branches. Understanding the difference between these two types of merges is crucial for managing your project's commit history effectively.\n\nA Fast-Forward merge occurs when the branch you are merging into (often main or master) has not diverged from the branch you are merging (often a feature branch). In other words, the commit history of the target branch is a strict subset of the branch being merged. In a Fast-Forward merge, Git simply moves the pointer of the target branch forward to the latest commit on the branch being merged.\nNo new merge commit is created; the history is linear.\n\nA Non-Fast-Forward (No-FF) merge happens when the target branch has diverged from the branch being merged or when you explicitly choose to create a merge commit. In this case, Git creates a new commit that represents the merging of the two branches. Git creates a new merge commit that has two parent commits: one from the target branch and one from the branch being merged. The merge commit is a snapshot of the merged work, preserving the history of both branches.",
        "resources": [
          {
            "type": "article",
            "title": "Git Fast-Forward VS Non-Fast-Forward",
            "url": "https://leimao.github.io/blog/Git-Fast-Forward-VS-Non-Fast-Forward/"
          },
          {
            "type": "article",
            "title": "Git Merge: To Squash Or Fast-Forward?",
            "url": "https://dev.to/trpricesoftware/git-merge-to-squash-or-fast-forward-3791"
          },
          {
            "type": "article",
            "title": "Difference between a git fast forward and no fast forward",
            "url": "https://gist.github.com/moraisaugusto/1fa02c49b6d9833fcdf665505595ac2e"
          },
          {
            "type": "video",
            "title": "GIT Fast Forward Visualized",
            "url": "https://youtu.be/DN1fNYoJgDw?si=_TZKACj4SCOuESGm"
          },
          {
            "type": "video",
            "title": "git merge no fast forward",
            "url": "https://youtu.be/X_8atqzsO8U?si=e9hMQg_aWLRMWf4O"
          }
        ]
      }
    },
    {
      "id": "9Dt4Gyiiq5jteWSKxsRMK",
      "name": "Handling Conflicts",
      "resources": {
        "description": "# Handling Conflicts\n\nWhen multiple developers work on the same project simultaneously, conflicts can arise during the merging process. This occurs when changes made by different individuals overlap or contradict each other in a specific code file. In such situations, Git's conflict resolution mechanism comes into play, allowing users to manually resolve these issues and merge the conflicting changes.",
        "resources": [
          {
            "type": "article",
            "title": "Resolving a merge conflict using the command line",
            "url": "https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/addressing-merge-conflicts/resolving-a-merge-conflict-using-the-command-line"
          },
          {
            "type": "article",
            "title": "Resolve merge conflicts in Visual Studio",
            "url": "https://learn.microsoft.com/en-us/visualstudio/version-control/git-resolve-conflicts?view=vs-2022"
          },
          {
            "type": "video",
            "title": "Resolve Git MERGE CONFLICTS: The Definitive Guide",
            "url": "https://www.youtube.com/watch?v=Sqsz1-o7nXk"
          }
        ]
      }
    },
    {
      "id": "99FVJ3Zs8n6lr8L95mG6g",
      "name": "Rebase",
      "resources": {
        "description": "# Rebase\n\nRebasing in Git is a powerful and potentially complex feature used to reorganize or modify a series of commits. The primary purpose of rebasing is to create a cleaner, more linear project history by moving or combining changes from one branch into another.",
        "resources": [
          {
            "type": "course",
            "title": "Rebasing",
            "url": "https://git-scm.com/book/en/v2/Git-Branching-Rebasing"
          }
        ]
      }
    },
    {
      "id": "Z-srOhYFGVEKDexlJ6cjt",
      "name": "Squash",
      "resources": {
        "description": "# Squash\n\nSquashing in Git, refers to the process of combining multiple commits into a single commit. This is often done to create a cleaner and more concise commit history, especially before merging a feature branch into the main branch.",
        "resources": [
          {
            "type": "article",
            "title": "Git Squash Commits",
            "url": "https://www.freecodecamp.org/news/git-squash-commits/"
          },
          {
            "type": "article",
            "title": "How to Squash Commits in Git",
            "url": "https://medium.com/iosnesia/how-to-squash-commits-in-git-e73a41248211"
          },
          {
            "type": "video",
            "title": "GIT Tutorial - How to Squash Commits",
            "url": "https://youtu.be/viY1BbKZhSI?si=kORsEzQvCRFGauQa"
          }
        ]
      }
    },
    {
      "id": "eFf2fesrs-1aVM5tH3ORQ",
      "name": "Cherry Picking Commits",
      "resources": {
        "description": "# Cherry Picking Commits\n\nCherry-picking in Git allows you to apply a specific commit from one branch to another, without merging the entire branch. This is useful when you want to bring in a specific feature or fix from one branch to another without incorporating all the changes from the source branch.",
        "resources": [
          {
            "type": "course",
            "title": "git-cherry-pick docs",
            "url": "https://git-scm.com/docs/git-cherry-pick"
          },
          {
            "type": "article",
            "title": "Git Cherry Pick",
            "url": "https://www.atlassian.com/git/tutorials/cherry-pick"
          },
          {
            "type": "video",
            "title": "Git Cherry Pick - Tutorial",
            "url": "https://youtu.be/i657Bg_HAWI?si=3jjn2X8Hi1na--F4"
          }
        ]
      }
    },
    {
      "id": "7lRUYWNSpHvJ-QyIE8RMa",
      "name": "Commit Messages",
      "resources": {
        "description": "# Commit Messages\n\nA Git commit message is a brief explanation of the changes introduced in a particular commit. It helps others (and your future self) understand the purpose of the changes and the context behind them. Writing clear and informative commit messages is an important practice for maintaining a well-organized and easily navigable project history.",
        "resources": [
          {
            "type": "article",
            "title": "How to Write Better Git Commit Messages",
            "url": "https://www.freecodecamp.org/news/how-to-write-better-git-commit-messages/"
          },
          {
            "type": "article",
            "title": "Writing good commit messages",
            "url": "https://www.theodinproject.com/lessons/foundations-commit-messages"
          },
          {
            "type": "article",
            "title": "How to Write Good Git Commit Messages like a pro",
            "url": "https://medium.com/front-end-weekly/how-to-write-good-git-commit-messages-like-a-pro-2c12f01569d9"
          },
          {
            "type": "video",
            "title": "Write git commit messages like a PRO with Conventional Commits",
            "url": "https://youtu.be/OJqUWvmf4gg?si=Fgl3isZpP13jYXHP"
          },
          {
            "type": "video",
            "title": "How to Make Actually Good Commits in Git",
            "url": "https://youtu.be/Dy5t_H2PRrk?si=0V-JEbqphpJX5OLl"
          }
        ]
      }
    },
    {
      "id": "ks1Pip-RM-UWD6zuF2j4n",
      "name": "Branch Naming",
      "resources": {
        "description": "# Branch Naming\n\nA well-defined branch naming convention is essential for maintaining a clean and organized Git workflow. It's recommended to use descriptive and meaningful names that clearly indicate the purpose of each branch. For example, using prefixes like `feature/`, `fix/`, or `docs/` can help identify whether a branch is related to new feature development, bug fixes, or documentation updates. Additionally, including the issue or task ID (e.g., `issue/123`) can provide context and make it easier for team members to find relevant information. By following a consistent naming convention, you can improve collaboration, reduce confusion, and increase the overall efficiency of your Git workflow.",
        "resources": [
          {
            "type": "article",
            "title": "Naming conventions for Git Branches — a Cheatsheet",
            "url": "https://medium.com/@abhay.pixolo/naming-conventions-for-git-branches-a-cheatsheet-8549feca2534"
          },
          {
            "type": "article",
            "title": "Git Branching Naming Convention: Best Practices to Follow",
            "url": "https://phoenixnap.com/kb/git-branch-name-convention"
          }
        ]
      }
    },
    {
      "id": "GwDNk2HBjASr_NWIL4G3-",
      "name": "PR Guidelines",
      "resources": {
        "description": "# PR Guidelines\n\nPull Request (PR) guidelines are essential for maintaining a smooth and efficient code review process in collaborative development environments. These guidelines typically outline best practices for creating, formatting, and submitting PRs, ensuring that changes are well-documented, easy to review, and align with the project's standards. They may cover aspects such as PR size, commit message formatting, documentation requirements, and testing expectations. By establishing clear PR guidelines, teams can streamline their workflow, improve code quality, and facilitate effective communication among contributors.",
        "resources": [
          {
            "type": "course",
            "title": "Best Practices for Pull Requests",
            "url": "https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/getting-started/best-practices-for-pull-requests"
          },
          {
            "type": "article",
            "title": "Pull Request Guidelines",
            "url": "https://opensource.creativecommons.org/contributing-code/pr-guidelines/"
          }
        ]
      }
    },
    {
      "id": "xLB2fhsOm0Vu3xg_PusJB",
      "name": "Code Reviews",
      "resources": {
        "description": "# Code Reviews\n\nThe purpose of a code review in software development is to help ensure that the code meets the organization’s standards and requirements, is of high quality, and is maintainable. In addition to identifying errors and bugs, code reviews also promote a culture of learning and collaboration among the development team.\n\nSome of the benefits of code reviews include:\n\n- Increase code quality by identifying defects in the code and issues such as security vulnerabilities and performance problems—before developers merge the code into an upstream branch.\n- Ensure compliance with organizational standards, regulations, and the team’s code style.\n- Save time and money by detecting issues earlier in the software development process before they become more complex and expensive to fix.\n- Boost collaboration, communication, and knowledge sharing among developers by providing a forum to discuss code and ask questions, share ideas and best practices, and learn from each other.\n- Ensure that the code is maintainable by identifying any software maintenance issues and suggesting improvements.",
        "resources": [
          {
            "type": "article",
            "title": "A practical guide for better, faster code reviews",
            "url": "https://github.com/mawrkus/pull-request-review-guide"
          },
          {
            "type": "article",
            "title": "How to improve code with code reviews",
            "url": "https://github.com/resources/articles/software-development/how-to-improve-code-with-code-reviews"
          }
        ]
      }
    },
    {
      "id": "pJ-najh7dXhhYA_0bDiR5",
      "name": "Contribution Guidelines",
      "resources": {
        "description": "# Contribution Guidelines\n\nContribution guidelines are essential for collaborative projects on GitHub as they help streamline collaboration, set expectations for contributions, and maintain the project's quality and consistency.",
        "resources": [
          {
            "type": "course",
            "title": "Setting Guidelines for Repository Contributors",
            "url": "https://docs.github.com/articles/setting-guidelines-for-repository-contributors"
          },
          {
            "type": "course",
            "title": "Contributing Guidelines",
            "url": "https://github.blog/news-insights/contributing-guidelines/"
          },
          {
            "type": "course",
            "title": "Contributing Guides: A Template",
            "url": "https://github.com/nayafia/contributing-template"
          },
          {
            "type": "article",
            "title": "How to Build a CONTRIBUTING.md",
            "url": "https://mozillascience.github.io/working-open-workshop/contributing/"
          }
        ]
      }
    },
    {
      "id": "D2WIExwfSnkAPIa5O-Hp5",
      "name": "Documentation",
      "resources": {
        "description": "# Documentation\n\nA well-maintained repository should include documentation that helps others understand the project, its context, and how to contribute to it. This is essential for fostering a community around your project and making it easier for newcomers to join in.\n\nHere are some key sections of documentation that you should consider including in each repository:\n\n- README.md: A brief introduction to the project, explaining what it's about, why it exists, and how to get started.\n- CONTRIBUTING.md: Guidelines on how others can contribute to the project, including steps for reporting issues, submitting pull requests, or suggesting new features.\n- LICENSE: Information about the license under which the repository is released, ensuring users understand their rights and responsibilities when using your code.\n- CHANGELOG: A history of changes made to the project over time, highlighting significant updates, bug fixes, or feature additions.\n\nThese documents help ensure a smooth onboarding process for contributors, making it easier for them to collaborate effectively and enhance the overall project.",
        "resources": [
          {
            "type": "article",
            "title": "How to Manage Documentation in a GitHub Repository: A Guide for Junior Developers",
            "url": "https://dev.to/mochafreddo/how-to-manage-documentation-in-a-github-repository-a-guide-for-junior-developers-pgo"
          }
        ]
      }
    },
    {
      "id": "1Ulxl4VUvRSfyCPpi-iv8",
      "name": "Markdown",
      "resources": {
        "description": "# Markdown\n\nMarkdown is a simple way to add formatting to text without using HTML tags or other complex syntax. It's easy to read and write, making it suitable for documentation, README files, and more. Some basic GitHub Markdown features include:\n\n- Basic syntax: Use headers (`# Heading`), bold/italic text (**bold**, *italic*), and lists (- item) to format text.\n- Links: Create links with `[text](url)` or `[text][ref]`.\n- Images: Embed images with `[![alt-text](image-url)]`.\n\nBy using Markdown, you can easily format text within your GitHub repository, making it easier to read and understand for yourself and others.",
        "resources": [
          {
            "type": "course",
            "title": "Basic writing and formatting syntax",
            "url": "https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax"
          },
          {
            "type": "article",
            "title": "Markdown Cheatsheet",
            "url": "https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet"
          }
        ]
      }
    },
    {
      "id": "WIVr7JxO1AJTNObW8mtY3",
      "name": "Project Readme",
      "resources": {
        "description": "# Project Readme\n\nA GitHub project README is a crucial document that serves as the front page of a repository, providing essential information about the project. It typically includes a brief description of the project's purpose, installation instructions, usage guidelines, and contribution procedures. A well-crafted README helps visitors quickly understand the project's goals, how to get started, and how they can participate. It often contains badges indicating build status, code coverage, and other metrics, as well as links to documentation, issue trackers, and community channels. By effectively communicating the project's value and guiding new users and potential contributors, a good README significantly enhances a project's visibility, adoption, and collaboration potential on GitHub.",
        "resources": [
          {
            "type": "course",
            "title": "About READMEs",
            "url": "https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-readmes"
          },
          {
            "type": "article",
            "title": "How to write a good README",
            "url": "https://bulldogjob.com/readme/how-to-write-a-good-readme-for-your-github-project"
          }
        ]
      }
    },
    {
      "id": "lONqOqD-4slxa9B5i9ADX",
      "name": "GitHub Wikis",
      "resources": {
        "description": "# GitHub Wikis\n\nGitHub Wikis are collaborative documentation spaces integrated directly into GitHub repositories. They provide a platform for teams to create, edit, and organize project-related information, such as documentation, guidelines, and FAQs. Wikis support Markdown formatting, making it easy to structure content and include images or links. With version control and the ability to clone wiki repositories, teams can collaboratively maintain up-to-date documentation alongside their code, enhancing project understanding and facilitating knowledge sharing among contributors and users.",
        "resources": [
          {
            "type": "course",
            "title": "About Wikis",
            "url": "https://docs.github.com/en/communities/documenting-your-project-with-wikis/about-wikis"
          },
          {
            "type": "course",
            "title": "Documenting your project with Wikis",
            "url": "https://docs.github.com/en/communities/documenting-your-project-with-wikis"
          }
        ]
      }
    },
    {
      "id": "i3AbARgzQtxtlB-1AS8zv",
      "name": "Clean Git History",
      "resources": {
        "description": "# Clean Git History\n\nCleaning up Git history can make your commit history more readable, concise, and organized. Here are some of the reasons why you'd want to clean your git history:\n\n- makes it easy to decipher the order of the commits in your repository\n- It facilitates finding commits that might have introduced bugs and enable rollback if necessary\n- To be able to deploy any commit on your development branch using your CI/CD system\n- If you are handling mobile app releases and you are responsible for figuring out what feature is in which release.",
        "resources": [
          {
            "type": "article",
            "title": "Clean GIT history — a Step by Step Guide",
            "url": "https://medium.com/@catalinaturlea/clean-git-history-a-step-by-step-guide-eefc0ad8696d"
          },
          {
            "type": "video",
            "title": "Git Best Practice Tip: Clean Commit History",
            "url": "https://youtu.be/bZpiVijzd2g?si=8lJTlR3LfY9ZUd77"
          }
        ]
      }
    },
    {
      "id": "yMx3LdadPz4g25CL3N8da",
      "name": "Working in a Team",
      "resources": {
        "description": "# Working in a Team\n\nWorking in a team on GitHub involves collaborative development using Git's distributed version control system. Team members can work on separate branches, create pull requests for code reviews, and merge changes into the main codebase. GitHub's features like issues, projects, and discussions facilitate communication and project management. Effective teamwork on GitHub requires clear communication, adherence to agreed-upon workflows, and proper use of Git commands to manage code changes and resolve conflicts. This collaborative approach enables teams to work efficiently on complex projects, maintain code quality, and track progress effectively.\n\nGitHub also offers an organization and team management interface, allowing teams to manage projects, members, and collaboration settings.",
        "resources": [
          {
            "type": "course",
            "title": "Getting Started with Teams",
            "url": "https://docs.github.com/en/get-started/onboarding/getting-started-with-github-team"
          },
          {
            "type": "course",
            "title": "GitHub Team Docs",
            "url": "https://docs.github.com/organizations/organizing-members-into-teams/about-teams"
          }
        ]
      }
    },
    {
      "id": "RMrxQLhrINO5g4Mhxh5qS",
      "name": "GitHub Organizations",
      "resources": {
        "description": "# GitHub Organizations\n\nGitHub Organizations are shared accounts that provide centralized management and collaboration for multiple projects and teams. They offer enhanced administrative controls, allowing owners to create teams with specific access permissions, manage member roles, and oversee repositories at scale. Organizations facilitate better project coordination, resource sharing, and team communication, making them ideal for businesses, open-source projects, and large-scale collaborations. With features like team discussions, project boards, and audit logs, GitHub Organizations streamline workflow management and foster a more structured and secure development environment.",
        "resources": [
          {
            "type": "course",
            "title": "About Organizations",
            "url": "https://docs.github.com/en/organizations/collaborating-with-groups-in-organizations/about-organizations"
          },
          {
            "type": "video",
            "title": "Set up a GitHub Organization",
            "url": "https://www.youtube.com/watch?v=XowSSIhJFuk"
          }
        ]
      }
    },
    {
      "id": "_ft-uvXt6s_xrcMT3fbSF",
      "name": "Collaborators / Members",
      "resources": {
        "description": "# Collaborators / Members\n\nIn GitHub, collaborators and members refer to individuals who contribute to or have access to your repository. Collaborators are users who have been granted permission to contribute code, make changes, and push updates to your repository, whereas members are the owners of a repository, including organization owners who have full control over their team's repositories. Members can be either individual collaborators or part of an organization team, with varying levels of access and permissions based on their role within the team.",
        "resources": [
          {
            "type": "article",
            "title": "Inviting collaborators to a personal repository",
            "url": "https://docs.github.com/en/account-and-profile/setting-up-and-managing-your-personal-account-on-github/managing-access-to-your-personal-repositories/inviting-collaborators-to-a-personal-repository"
          },
          {
            "type": "course",
            "title": "REST API endpoints for collaborators",
            "url": "https://docs.github.com/en/rest/collaborators/collaborators?apiVersion=2022-11-28"
          }
        ]
      }
    },
    {
      "id": "wydgCxR5VnieBpRolXt8i",
      "name": "Teams within Organization",
      "resources": {
        "description": "# Teams within Organization\n\nGitHub Organizations allow you to create teams within your organization, which helps in organizing members based on their roles and responsibilities.\n\n- Grouping: Team members can be grouped together according to the company or group's structure.\n- Access permissions: Access permissions can be cascaded from one team member to another.\n- Mentions: Team mentions allow for easy referencing of specific teams in repository discussions.",
        "resources": [
          {
            "type": "course",
            "title": "Organizing Members into Teams",
            "url": "https://docs.github.com/en/organizations/organizing-members-into-teams"
          },
          {
            "type": "article",
            "title": "Best Practices for Organizations and Teams using GitHub Enterprise Cloud",
            "url": "https://github.blog/enterprise-software/devops/best-practices-for-organizations-and-teams-using-github-enterprise-cloud/"
          }
        ]
      }
    },
    {
      "id": "DzFJDdqnSy5GeGHWOpcVo",
      "name": "GitHub Projects",
      "resources": {
        "description": "# GitHub Projects\n\nGitHub Projects is a flexible project management tool integrated directly into GitHub repositories. It allows teams to create customizable project boards, track issues and pull requests, and manage workflows using Kanban-style columns or table views. With features like automated workflows, custom fields, and various visualization options, GitHub Projects helps teams organize, prioritize, and track work across multiple repositories. This tool enhances collaboration, increases transparency, and streamlines project management processes, making it easier for developers and stakeholders to stay aligned on project goals and progress.",
        "resources": [
          {
            "type": "course",
            "title": "About Projects",
            "url": "https://docs.github.com/en/issues/planning-and-tracking-with-projects/learning-about-projects/about-projects"
          },
          {
            "type": "video",
            "title": "How to use Projects Roadmap",
            "url": "https://www.youtube.com/watch?v=D80u__nYYWw"
          }
        ]
      }
    },
    {
      "id": "q0zy_hXav5iXw8LpGVJVd",
      "name": "Project Planning",
      "resources": {
        "description": "# Project Planning\n\nProject planning on GitHub is a comprehensive process that leverages the platform's built-in tools to organize, track, and manage software development projects efficiently. It typically involves using features such as Issues for task tracking, Projects for kanban-style boards, Milestones for grouping related issues and pull requests, and Labels for categorization. These tools, combined with GitHub's collaborative features like pull requests and code reviews, enable teams to create structured workflows, set priorities, assign tasks, and monitor progress throughout the development lifecycle. By centralizing project management within the same platform used for version control, GitHub streamlines communication and enhances productivity for development teams of all sizes.",
        "resources": [
          {
            "type": "course",
            "title": "Project planning for developers",
            "url": "https://github.com/features/issues"
          },
          {
            "type": "video",
            "title": "GitHub Project Management",
            "url": "https://www.youtube.com/watch?v=oPQgFxHcjAw"
          }
        ]
      }
    },
    {
      "id": "RFJgfuxoVxt22QlwLI5mW",
      "name": "Kanban Boards",
      "resources": {
        "description": "# Kanban Boards\n\nOn GitHub, Kanban boards provide a visual representation of issues as they move through the development process.\n\nA Kanban board typically has columns representing different stages or states, such as \"To-Do\", \"In-Progress\", and \"Done\". Each issue is represented by a card on the board, which can be moved between columns as its state changes. Users can drag and drop issue cards to move them from one column to another, reflecting progress or completion.",
        "resources": [
          {
            "type": "course",
            "title": "Projects - Boards - Changing the layout of a view",
            "url": "https://docs.github.com/en/issues/planning-and-tracking-with-projects/customizing-views-in-your-project/changing-the-layout-of-a-view"
          },
          {
            "type": "video",
            "title": "GitHub Project Management - Create GitHub Project Board & Automations",
            "url": "https://www.youtube.com/watch?v=oPQgFxHcjAw"
          }
        ]
      }
    },
    {
      "id": "sxvT2hGko2PDRBoBrCGWD",
      "name": "Roadmaps",
      "resources": {
        "description": "# Roadmaps\n\nGitHub Roadmaps are a feature that helps you visualize and organize plans for your projects, allowing you to create a high-level view of milestones and goals, and collaborate on planning and tracking progress with team members.",
        "resources": [
          {
            "type": "course",
            "title": "Customizing the Roadmap Layout",
            "url": "https://docs.github.com/en/issues/planning-and-tracking-with-projects/customizing-views-in-your-project/customizing-the-roadmap-layout"
          },
          {
            "type": "video",
            "title": "Learn how to use Project Roadmaps - GitHub Checkout",
            "url": "https://www.youtube.com/watch?v=D80u__nYYWw"
          }
        ]
      }
    },
    {
      "id": "TNBz5755PhI6iKxTQTqcS",
      "name": "Automations",
      "resources": {
        "description": "# Automations\n\nTo add automation to your GitHub project, use built-in workflows that can trigger actions such as setting fields on item changes or archiving items meeting specific criteria, and also configure automatic item addition from repositories based on matching criteria.",
        "resources": [
          {
            "type": "course",
            "title": "Automating your project",
            "url": "https://docs.github.com/en/issues/planning-and-tracking-with-projects/automating-your-project"
          },
          {
            "type": "video",
            "title": "GitHub Project Management - Create GitHub Project Board & Automations",
            "url": "https://www.youtube.com/watch?v=oPQgFxHcjAw&t=600s"
          }
        ]
      }
    },
    {
      "id": "snWQHCQECZyUXHdn6ppIk",
      "name": "GitHub Discussions",
      "resources": {
        "description": "# GitHub Discussions\n\nGitHub Discussions is a collaborative communication feature within GitHub repositories that provides a dedicated space for community conversations, questions, and knowledge sharing. It allows team members, contributors, and users to engage in threaded discussions, share ideas, ask for help, and make announcements outside of specific code changes or issues. This feature enhances project collaboration by centralizing important conversations, reducing noise in the issue tracker, and fostering a sense of community around open-source projects or team initiatives.",
        "resources": [
          {
            "type": "course",
            "title": "GitHub Discussions Docs",
            "url": "https://docs.github.com/en/discussions"
          },
          {
            "type": "video",
            "title": "What is GitHub Discussions?",
            "url": "https://www.youtube.com/watch?v=bErGYN3Ljz8"
          }
        ]
      }
    },
    {
      "id": "X9K3PBpGsMoXkJsKdJPI7",
      "name": "Git Stash Basics",
      "resources": {
        "description": "# Git Stash Basics\n\nGit stash allows you to temporarily save your changes, or \"stashes\", when they're not yet ready for commit. This feature is useful when you need to work on multiple tasks, and want to switch between them without committing changes that are not complete. By using `git stash`, you can quickly stash uncommitted changes, reset the working directory to a clean state, and then apply the stashed changes later when they're ready for commit. This helps avoid cluttering the commit history with incomplete work, and allows you to maintain a clean and organized repository by separating your progress on different tasks.\n\nTo apply a stash in Git, you can use the following commands:\n\n- `git stash apply`: This command applies the topmost stash (the most recent one) by default. It will merge the stashed changes into your current working directory.\n- `git stash apply <stash_name>`: If you want to specify a particular stash, you can use its name instead of default. For example, if you've stored multiple stashes and want to apply an earlier one, you can use <stash_name>.\n- `git stash pop`: This command is similar to apply, but it also automatically deletes the applied stash from the stash list. If you need more control over which stash to apply, using pop might be a better option.",
        "resources": [
          {
            "type": "article",
            "title": "Git stash",
            "url": "https://www.atlassian.com/git/tutorials/saving-changes/git-stash"
          },
          {
            "type": "article",
            "title": "A practical guide to using the git stash command",
            "url": "https://opensource.com/article/21/4/git-stash"
          }
        ]
      }
    },
    {
      "id": "zen3RRdK9_nPAYgicRoHk",
      "name": "History",
      "resources": {
        "description": "# History\n\nThe history of a Git repository is a record of all commits made over time, including changes to files, commit messages, and metadata. This history is stored as a series of snapshots, with each commit representing a new version of the codebase.",
        "resources": [
          {
            "type": "course",
            "title": "Git Basics - Viewing the Commit History",
            "url": "https://git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History"
          }
        ]
      }
    },
    {
      "id": "lXC07j6dOa3rQixY1P-Ob",
      "name": "Linear vs Non-Linear",
      "resources": {
        "description": "# Linear vs Non-Linear\n\nIn Git, linear and non-linear history refer to different ways of managing commit history.\n\n- Linear history: A repository with a linear history has commits that are applied in a single, sequential order.\n- Non-linear history: A repository with a non-linear history allows multiple branches or lines of development, which can be merged back into the main branch at different points.",
        "resources": [
          {
            "type": "article",
            "title": "Linear vs Non-Linear History",
            "url": "https://idiv-biodiversity.github.io/git-knowledge-base/linear-vs-nonlinear.html"
          },
          {
            "type": "article",
            "title": "Linear git history - Part I",
            "url": "https://jun-sheng.medium.com/linear-git-history-part-i-b97184dde252#:~:text=The%20benefit%20of%20having%20a%20linear%20git%20history&text=It%20is%20easier%20to%20understand,bisect%20to%20track%20a%20bug."
          }
        ]
      }
    },
    {
      "id": "V8nLIvddyOKTzEjOJX5GW",
      "name": "HEAD",
      "resources": {
        "description": "# HEAD\n\nThe `HEAD` file is at the core of how Git knows the SHA-1 of the last commit when running commands like `git branch <branch>`. It serves as a symbolic reference, pointing to the current branch. However, in rare cases, HEAD can contain the actual SHA-1 value of a Git object, such as when checking out a tag, commit, or remote branch, which puts your repository in a \"detached HEAD\" state.",
        "resources": [
          {
            "type": "course",
            "title": "Git Internals - Git References - The HEAD",
            "url": "https://git-scm.com/book/en/v2/Git-Internals-Git-References#:~:text=want%20to%20create.-,The%20HEAD,-The%20question%20now"
          },
          {
            "type": "video",
            "title": "Learn Git Essentials: Head & Detached Head",
            "url": "https://www.youtube.com/watch?v=HvDjbAa9ZsY"
          }
        ]
      }
    },
    {
      "id": "0cLf7FiI9CX--UX45sm2f",
      "name": "Detached HEAD",
      "resources": {
        "description": "# Detached HEAD\n\nIn Git, a detached head occurs when you check out a commit directly using its hash instead of a branch name. This leaves your repository's HEAD pointer pointing directly at that commit, rather than being linked to a specific branch. To view the history and changes made in a detached head, use `git log` or `git show`. If you want to see the differences between the current detached head and another branch, use `git diff <branch>`. A detached head can be a useful temporary state for exploring specific commits or features, but it's essential to merge those changes back into a branch before sharing them with others.",
        "resources": [
          {
            "type": "article",
            "title": "How to resolve detached HEAD state in Git",
            "url": "https://graphite.dev/guides/how-to-resolve-detached-head-state-in-git"
          },
          {
            "type": "video",
            "title": "Head & Detached Head",
            "url": "https://www.youtube.com/watch?v=HvDjbAa9ZsY"
          }
        ]
      }
    },
    {
      "id": "qFEonbCMLri8iA0yONwuf",
      "name": "git log options",
      "resources": {
        "description": "# git log options\n\n`git log` is a command in Git that shows the commit history of your repository. It provides a detailed view of all commits, including their hashes, authors, dates, and messages.\n\nHere are some common git log options:\n\n- `-2`: Only show the last two commits.\n- `-- <file-name>`: Show the commits that modified a specific file.\n- `--all`: Show all branches in the repository.\n- `--graph`: Display the commit history as a graph.\n- `--pretty`: Enable clean colorized output.\n- `--no-color`: Disable colorized output.\n- `--stat`: Show a statistical summary of changes.\n- `**-S`: Only show commits with modified files.\n\nYou can combine these options to tailor your log output to suit your needs.\n\nFor example, `git log -2 --graph` will display the last two commits in graph form.",
        "resources": [
          {
            "type": "course",
            "title": "Git Log",
            "url": "https://git-scm.com/docs/git-log"
          },
          {
            "type": "article",
            "title": "Git Log Cheatsheet",
            "url": "https://elijahmanor.com/blog/git-log"
          }
        ]
      }
    },
    {
      "id": "0Yi4cryT2v2SGBjouOas3",
      "name": "Undoing Changes",
      "resources": {
        "description": "# Undoing Changes\n\nIf mistakes or unwanted changes have been committed to your Git repository, there are ways to correct them. Two common methods for reverting changes include:\n\n- Git Reset: Resets the branch to a previous commit.\n- Git Revert: Creates a new commit that reverts specified changes.",
        "resources": [
          {
            "type": "course",
            "title": "Undoing Changes",
            "url": "https://git-scm.com/book/en/v2/Git-Tools-Reset-Demystified"
          },
          {
            "type": "article",
            "title": "Undo Anything in Git",
            "url": "https://github.blog/open-source/git/how-to-undo-almost-anything-with-git/"
          },
          {
            "type": "article",
            "title": "Undoing Changes in Git",
            "url": "https://www.atlassian.com/git/tutorials/undoing-changes"
          }
        ]
      }
    },
    {
      "id": "dLr55Om7IOvI53c1DgTKc",
      "name": "git revert",
      "resources": {
        "description": "# git revert\n\nGit revert is a command that allows you to \"undo\" or revert specific commits in your Git repository. It creates a new commit that reverses the changes made by the specified commit(s), effectively rolling back your code to a previous state.\n\nHere are some key things to know about `git revert`:\n\n- Reverts changes, not moves HEAD: Unlike `git reset`, which can move your current branch's head to a different point in history, `git revert` creates new commits that reverse the changes made by specific commit(s).\n- Creates new commits: Each time you use `git revert`, it creates a new commit that undoes the specified change. This means your Git history will still contain all previous commits.\n- Can be used with multiple commits: If you want to revert multiple commits, simply specify their hashes or references (e.g., branch names) separated by commas.",
        "resources": [
          {
            "type": "article",
            "title": "Git Revert",
            "url": "https://medium.com/@meghasharmaa704/git-revert-84727b543c17"
          },
          {
            "type": "video",
            "title": "Git Revert - Visualised",
            "url": "https://www.youtube.com/watch?v=XJqQPNudPSY"
          }
        ]
      }
    },
    {
      "id": "igrR7LguU1jemg_mf_AD6",
      "name": "git reset",
      "resources": {
        "description": "# git reset\n\nGit reset is a command that allows you to \"undo\" or reset your current branch to a previous state by moving its HEAD pointer, effectively discarding changes made since then. When using git reset, it's essential to specify one of the three modes: soft, hard, or mixed. The mode you choose will determine how Git interacts with files in your working directory and staging area.",
        "resources": [
          {
            "type": "article",
            "title": "git reset",
            "url": "https://www.atlassian.com/git/tutorials/undoing-changes/git-reset"
          },
          {
            "type": "video",
            "title": "Git Reset | How to Use Git Reset | Learn Git",
            "url": "https://www.youtube.com/watch?v=s1idhUiCk38"
          }
        ]
      }
    },
    {
      "id": "Uc7FyfAKpDFRGRNHwztFo",
      "name": "--soft",
      "resources": {
        "description": "# --soft\n\nIn this mode, only the HEAD pointer is moved to the specified commit. The files in your working directory are not modified, but they remain as they were when you started the reset.\n\n- [@official@--soft documentation](https://git-scm.com/docs/git-reset#Documentation/git-reset.txt---soft)",
        "resources": [
          {
            "type": "course",
            "title": "--soft documentation",
            "url": "https://git-scm.com/docs/git-reset#Documentation/git-reset.txt---soft"
          }
        ]
      }
    },
    {
      "id": "V_joZNpQsS9G9PI-o-GmC",
      "name": "--hard",
      "resources": {
        "description": "# --hard\n\nWith this option, both the HEAD pointer and the working directory's contents are updated to match the specified commit. Any changes made since then will be lost.",
        "resources": [
          {
            "type": "course",
            "title": "--hard documentation",
            "url": "https://git-scm.com/docs/git-reset#Documentation/git-reset.txt---hard"
          }
        ]
      }
    },
    {
      "id": "qis7Z5VRxMcOmbesQlegZ",
      "name": "--mixed",
      "resources": {
        "description": "# --mixed\n\nWhen using mixed mode, the HEAD pointer is moved to the specified commit. However, files in your working directory remain as they were before the reset. The staging area (index) is updated to match the specified commit.",
        "resources": [
          {
            "type": "course",
            "title": "--mixed documentation",
            "url": "https://git-scm.com/docs/git-reset#Documentation/git-reset.txt---mixed"
          }
        ]
      }
    },
    {
      "id": "-0zQvCHG8jS_ghSjmTeIx",
      "name": "Viewing Diffs",
      "resources": {
        "description": "# Viewing Diffs\n\nViewing diffs in Git is crucial for understanding the changes made to your code. This is especially important when collaborating with others or reviewing your own work over time. Diffs show you exactly what lines have been added, modified, or removed between different versions of your files. This feature helps in code review processes, troubleshooting issues, and maintaining a clear history of your project's evolution. Git provides various commands and tools to view these differences, making it easier to track and manage changes effectively.",
        "resources": [
          {
            "type": "course",
            "title": "Git Diff Documentation",
            "url": "https://git-scm.com/docs/git-diff"
          },
          {
            "type": "article",
            "title": "Git Diff",
            "url": "https://www.atlassian.com/git/tutorials/saving-changes/git-diff"
          }
        ]
      }
    },
    {
      "id": "Rwpeltygwzcf6hnuZNURE",
      "name": "Between Commits",
      "resources": {
        "description": "# Between Commits\n\nTo compare two specific commits in your Git history, use git diff followed by the hashes of the commits. This will show you the changes made between those two points, including added, modified, and deleted lines.",
        "resources": [
          {
            "type": "article",
            "title": "Comparing changes with Git diff",
            "url": "https://refine.dev/blog/git-diff-command/"
          },
          {
            "type": "video",
            "title": "Git Diff 2 Different Commits, Tags or Branches",
            "url": "https://www.youtube.com/watch?v=uq5VWPDCtFo"
          }
        ]
      }
    },
    {
      "id": "O-zoAWkDvyn7B8_TmY257",
      "name": "Between Branches",
      "resources": {
        "description": "# Between Branches\n\nWhen comparing the differences between two branches, such as a feature branch and its upstream parent branch, use `git diff <branch1>..<branch2>`. This command displays the changes made on the feature branch relative to the parent branch. It's useful for reviewing the impact of new features or changes before merging them into your mainline.",
        "resources": [
          {
            "type": "article",
            "title": "How to compare branches in Git diff",
            "url": "https://scribehow.com/shared/How_to_Compare_Branches_in_GitHub__xsotezV-S1O-GL0PquqJwQ"
          },
          {
            "type": "article",
            "title": "How can I see the differences between two branches?",
            "url": "https://stackoverflow.com/questions/9834689/how-can-i-see-the-differences-between-two-branches"
          }
        ]
      }
    },
    {
      "id": "mzjtCdpke1ayHcEuS-YUS",
      "name": "Staged Changes",
      "resources": {
        "description": "# Staged Changes\n\nTo view the changes you've staged with `git add`, but not yet committed, use `git diff --cached`. This command compares the staged files against their original versions in the repository. It's a quick way to review what you're about to commit before finalizing it.",
        "resources": [
          {
            "type": "article",
            "title": "What does Staged Changes mean in Git?",
            "url": "https://dillionmegida.com/p/staged-changes-in-git/"
          },
          {
            "type": "video",
            "title": "What are Staged Changes in Git?",
            "url": "https://www.youtube.com/watch?v=HyeNfWZBut8"
          }
        ]
      }
    },
    {
      "id": "uxqJzQFRcALqatNRIWR0w",
      "name": "Unstaged Changes",
      "resources": {
        "description": "# Unstaged Changes\n\nFor changes that are not yet staged with `git add`, such as untracked new files or modified existing ones , use `git diff`. This command compares your working directory (your current changes) against the staging area (changes already staged with `git add`). It’s a useful tool for reviewing local modifications before deciding whether to stage them for future commits.\n\nThe `--unified` option (or -U) controls the number of context lines shown in the diff output. By default, Git shows 3 lines of context around each change. For example, `git diff --unified=5` will display 5 lines of context around each change, making it easier to understand the surrounding code or content.\n\n- [@article@What are unstaged changes in GitHub?](https://stackoverflow.com/questions/10954329/whats-the-unstaged-changes-in-github)\n- [@article@How to unstage files in Git](https://www.git-tower.com/learn/git/faq/git-unstage)",
        "resources": [
          {
            "type": "article",
            "title": "What are unstaged changes in GitHub?",
            "url": "https://stackoverflow.com/questions/10954329/whats-the-unstaged-changes-in-github"
          },
          {
            "type": "article",
            "title": "How to unstage files in Git",
            "url": "https://www.git-tower.com/learn/git/faq/git-unstage"
          }
        ]
      }
    },
    {
      "id": "sOoC-XxEoIvwKct00oKlX",
      "name": "Rewriting History",
      "resources": {
        "description": "# Rewriting History\n\nIn certain situations, you might need to modify or remove commits from your Git repository's history. This can be achieved using various methods:\n\n- `git commit --amend`: Allows you to edit the most recent commit.\n- `git rebase`: Replaces one branch with another, preserving the commit history.\n- `git filter-branch`: Removes specific commits from a branch without altering the original branch.\n- `git push --force`: Updates the remote repository while respecting existing pull requests.\n\nRewriting history in Git is typically necessary when:\n\n- Fixing mistakes: Correcting errors or typos in commit messages.\n- Removing sensitive data: Deleting confidential information from commits, like API keys or database credentials.\n- Simplifying complex histories: Reorganizing branches to improve clarity and reduce complexity.",
        "resources": [
          {
            "type": "course",
            "title": "Git Tools - Rewriting History",
            "url": "https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History"
          },
          {
            "type": "article",
            "title": "Methods of Rewriting History in Git",
            "url": "https://www.atlassian.com/git/tutorials/rewriting-history"
          }
        ]
      }
    },
    {
      "id": "NjPnEXLf1Lt9qzgxccogv",
      "name": "git commit --amend",
      "resources": {
        "description": "# git commit --amend\n\n`git commit --amend` is a command used to modify the most recent commit in your repository's history by updating its message, adding or removing files, or changing the commit's metadata. This allows you to correct mistakes or improve the commit's description after it has been made. When using --amend, Git will replace the existing commit with a new one that includes any changes made since the last commit, effectively \"amending\" the previous commit.",
        "resources": [
          {
            "type": "article",
            "title": "Changing a commit message",
            "url": "https://docs.github.com/en/enterprise-cloud@latest/pull-requests/committing-changes-to-your-project/creating-and-editing-commits/changing-a-commit-message"
          },
          {
            "type": "article",
            "title": "Rewriting history",
            "url": "https://www.atlassian.com/git/tutorials/rewriting-history"
          },
          {
            "type": "video",
            "title": "Git Amend Tutorial: Rewrite Git History",
            "url": "https://www.youtube.com/watch?v=q53umU5vMkk"
          }
        ]
      }
    },
    {
      "id": "HMEfUFNu_Wp_Pac7VWHr-",
      "name": "git rebase",
      "resources": {
        "description": "# git rebase\n\nGit rebase is a powerful command in Git that allows you to integrate changes from one branch into another. Unlike git merge, which creates a new commit to combine the histories of two branches, git rebase moves or applies commits from one branch on top of another, effectively re-writing the commit history.",
        "resources": [
          {
            "type": "course",
            "title": "Git - git-rebase Documentation",
            "url": "https://git-scm.com/docs/git-rebase"
          },
          {
            "type": "article",
            "title": "git rebase",
            "url": "https://www.atlassian.com/git/tutorials/rewriting-history/git-rebase"
          },
          {
            "type": "video",
            "title": "git rebase - Why, When &amp; How to fix conflicts",
            "url": "https://youtu.be/DkWDHzmMvyg?si=59jauQgkL-sMewzo"
          },
          {
            "type": "video",
            "title": "Git Rebase --interactive: EXPLAINED",
            "url": "https://youtu.be/H7RFt0Pxxp8?si=gLhfkVW_PmWHBQSs"
          }
        ]
      }
    },
    {
      "id": "BKVA6Q7DXemAYjyQOA0nh",
      "name": "git filter-branch",
      "resources": {
        "description": "# git filter-branch\n\nYou can use `git filter-branch` to rewrite Git revision history by applying custom filters on each revision.\n\n- Filter types: You can modify trees (e.g., removing a file or running a Perl script) or information about each commit.\n- Preserving original data: The command preserves all original commit times, merge information, and other details unless specified otherwise.\n- Rewriting specific branches: Only the positive refs mentioned in the command line are rewritten; if no filters are specified, commits are recommitted without changes.\n\nNotably, there exists a simpler, safer, and more powerful alternative: `git filter-repo`. This tool is actively promoted by Git and offers a streamlined approach to filtering revisions, making it a preferred choice for rewriting your Git history, especially when managing large repositories.",
        "resources": [
          {
            "type": "course",
            "title": "git filter-branch",
            "url": "https://git-scm.com/docs/git-filter-branch"
          },
          {
            "type": "course",
            "title": "git filter-repo",
            "url": "https://github.com/newren/git-filter-repo"
          },
          {
            "type": "article",
            "title": "Removing sensitive data from a repository",
            "url": "https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/removing-sensitive-data-from-a-repository"
          }
        ]
      }
    },
    {
      "id": "OQOmxg9mCfcjt80hpvXkA",
      "name": "git push --force",
      "resources": {
        "description": "# git push --force\n\n`git push --force` is a command that allows you to overwrite or \"force\" an existing commit on a remote repository with a new commit from your local repository. This can be useful in certain situations, such as when you need to update the remote branch with changes that were previously rejected or when you want to remove commits that are no longer relevant. However, it's essential to exercise caution when using git push --force because it can overwrite changes made by others or even your own previous work. Always verify that there are no conflicting changes on the remote repository before using this command.",
        "resources": [
          {
            "type": "article",
            "title": "Git Push Force",
            "url": "https://www.gitkraken.com/learn/git/problems/git-push-force"
          },
          {
            "type": "video",
            "title": "How to force push to GitHub?",
            "url": "https://www.youtube.com/watch?v=wgXbfLn-zkI"
          }
        ]
      }
    },
    {
      "id": "iFJBF-EEnLjQVsFSXjo_i",
      "name": "Tagging",
      "resources": {
        "description": "# Tagging\n\nIn Git, tags are used to identify specific points in a repository's history as being important. This feature allows developers to mark release points or milestones.\n\n- Marking release points: Tags are typically used to mark release versions (e.g., v1.0, v2.0) of a project.\n- Types of tags: There are different types of tags, including lightweight and annotated tags.",
        "resources": [
          {
            "type": "course",
            "title": "Git Basics - Tagging",
            "url": "https://git-scm.com/book/en/v2/Git-Basics-Tagging"
          }
        ]
      }
    },
    {
      "id": "NeU38WPbEphJuJ_AMkH82",
      "name": "Managing Tags",
      "resources": {
        "description": "# Managing Tags\n\nIn Git, a tag is a named reference to a specific commit in the project's history.\n\n- Creating tags: Use `git tag [name] [commit-hash]` to create a new tag. You can also use `git tag -a [name] -m \"[message]\" [commit-hash]` for annotated tags.\n- Listing tags: Run `git tag` to display all existing tags.\n- Deleting tags: Remove an existing tag with `git tag -d [tag-name]`.\n\nTags can be used for marking releases, milestones, or other significant events in a project's history.",
        "resources": [
          {
            "type": "course",
            "title": "Git Basics - Tagging",
            "url": "https://git-scm.com/book/en/v2/Git-Basics-Tagging"
          },
          {
            "type": "article",
            "title": "Git — Use Tags for Versioning and Release Management",
            "url": "https://medium.com/@KeyurRamoliya/git-use-tags-for-versioning-and-release-management-09aca9631eee"
          }
        ]
      }
    },
    {
      "id": "E3HAGNM-kXLL4Oci5JzpQ",
      "name": "Pushing Tags",
      "resources": {
        "description": "# Pushing Tags\n\nPushing tags in Git is the process of sharing your local tags with a remote repository. Tags in Git are used to mark specific points in the repository's history, typically to signify a release or a milestone.",
        "resources": [
          {
            "type": "article",
            "title": "Tagging in git",
            "url": "https://git-scm.com/book/en/Git-Basics-Tagging"
          },
          {
            "type": "article",
            "title": "How to Push Git Tags to Remote",
            "url": "https://kodekloud.com/blog/how-to-push-git-tags-to-remote/"
          },
          {
            "type": "article",
            "title": "Git Push Tag to Remote Guide",
            "url": "https://phoenixnap.com/kb/git-push-tag"
          }
        ]
      }
    },
    {
      "id": "62E1tDMXB6K74OEN0WsS0",
      "name": "Checkout Tags",
      "resources": {
        "description": "# Checkout Tags\n\nTags in Git are typically used to mark specific points in history, such as a release version. Checking out a tag means switching your working directory to the state of the repository at the point in time when that tag was created.",
        "resources": [
          {
            "type": "article",
            "title": "How To Checkout Git Tags",
            "url": "https://devconnected.com/how-to-checkout-git-tags/"
          },
          {
            "type": "article",
            "title": "What is git tag, How to create tags & How to checkout git remote tag(s)",
            "url": "https://stackoverflow.com/questions/35979642/what-is-git-tag-how-to-create-tags-how-to-checkout-git-remote-tags"
          },
          {
            "type": "video",
            "title": "Git Tag Tutorial | Create, Checkout, and Delete Git Tags | Learn Git",
            "url": "https://youtu.be/spkUevg1NqM?si=UXRwJEOI6bpN30nM"
          }
        ]
      }
    },
    {
      "id": "YmnTrjJtqHPXbEVrP8vd7",
      "name": "GitHub Releases",
      "resources": {
        "description": "# GitHub Releases\n\nGitHub Releases is a feature that allows developers to package and distribute software versions to users. It provides a way to create tagged points in a repository's history, attach binary files (such as compiled executables or packaged code), and include release notes. This feature makes it easy to track and manage different versions of a project, share pre-compiled binaries with users who may not want to build from source, and communicate changes and updates to the community. GitHub Releases integrates seamlessly with Git tags and can be automated as part of a continuous integration and deployment pipeline.",
        "resources": [
          {
            "type": "course",
            "title": "About Releases",
            "url": "https://docs.github.com/en/repositories/releasing-projects-on-github/about-releases"
          },
          {
            "type": "article",
            "title": "REST API endpoints for releases",
            "url": "https://docs.github.com/en/rest/releases/releases?apiVersion=2022-11-28"
          }
        ]
      }
    },
    {
      "id": "pqBV7BMAs0z6qpfZeW2XP",
      "name": "Git hooks",
      "resources": {
        "description": "# Git hooks\n\nGit hooks are scripts that run automatically at specific points during the Git workflow, such as when you commit, push, or pull changes from a repository. These scripts can be used to perform various tasks, like validating code, formatting files, or even sending notifications.\n\nThere are two types of Git hooks:\n\n- Client-side hooks: Run on your local machine before committing changes.\n- Server-side hooks: Run on the remote server when you push changes.",
        "resources": [
          {
            "type": "course",
            "title": "Customizing Git - Git Hooks",
            "url": "https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks"
          },
          {
            "type": "article",
            "title": "Git hooks",
            "url": "https://www.atlassian.com/git/tutorials/git-hooks"
          },
          {
            "type": "video",
            "title": "What are GitHooks? Explained in 5 minutes",
            "url": "https://www.youtube.com/watch?v=1OFiiPretCM"
          }
        ]
      }
    },
    {
      "id": "v7uabKuMQPOD_hBIaHOVT",
      "name": "What and Why?",
      "resources": {
        "description": "# What and Why?\n\nGit hooks are customizable scripts that Git executes automatically before or after specific events, such as committing, pushing, or merging. These hooks allow developers to automate tasks, enforce coding standards, run tests, or perform other actions at crucial points in the Git workflow. By leveraging git hooks, teams can enhance their development process, maintain code quality, and ensure consistency across projects. Hooks can be implemented locally or shared among team members, providing a powerful mechanism for streamlining workflows and enforcing best practices throughout the development lifecycle.",
        "resources": [
          {
            "type": "article",
            "title": "Git Hooks",
            "url": "https://www.atlassian.com/git/tutorials/git-hooks"
          },
          {
            "type": "video",
            "title": "What are Git Hooks?",
            "url": "https://www.youtube.com/watch?v=1OFiiPretCM"
          }
        ]
      }
    },
    {
      "id": "zsU6R2zvJKnYNU2ac4o4p",
      "name": "Client vs Server Hooks",
      "resources": {
        "description": "# Client vs Server Hooks\n\nLike many other Version Control Systems, Git has a way to fire off custom scripts when certain important actions occur. There are two groups of these hooks: client-side and server-side. Client-side hooks are triggered by operations such as committing and merging, while server-side hooks run on network operations such as receiving pushed commits.",
        "resources": [
          {
            "type": "course",
            "title": "Git Hooks",
            "url": "https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks#:~:text=There%20are%20two%20groups%20of,for%20all%20sorts%20of%20reasons."
          },
          {
            "type": "article",
            "title": "Git Hooks: The Powerful Tool You're Probably Not Using",
            "url": "https://dev.to/algodame/git-hooks-the-powerful-tool-youre-probably-not-using-but-should-be-1lec"
          },
          {
            "type": "video",
            "title": "Client vs Server Hooks",
            "url": "https://youtu.be/egfuwOe8nXc?si=IkbLCr-3eGE9x6cY"
          }
        ]
      }
    },
    {
      "id": "jzYjHx-gIKSP8dQUTqWVw",
      "name": "commit-msg",
      "resources": {
        "description": "# commit-msg\n\nThe commit-msg hook is a client-side hook that runs after you enter a commit message, but before the commit is finalized in your repository. It's typically used to validate or modify the commit message before it's recorded in the Git history.",
        "resources": [
          {
            "type": "article",
            "title": "A Git-Hook for Commit Messages Validation - No Husky, Just JS",
            "url": "https://dev.to/mbarzeev/a-git-hook-for-commit-messages-validation-no-husky-just-js-1hni"
          },
          {
            "type": "video",
            "title": "Git Hooks Made Easy: Create a Custom 'commit-msg' Hook Script",
            "url": "https://www.youtube.com/watch?v=yH1lBm5t97s"
          }
        ]
      }
    },
    {
      "id": "SANEQI2rgOtsMQyn4qUCq",
      "name": "post-checkout",
      "resources": {
        "description": "# post-checkout\n\nGit post-checkout hooks are scripts that run automatically after a successful `git checkout` operation. These hooks provide a way to customize Git's behavior and perform specific actions when switching branches or updating the working directory. Post-checkout hooks can be used for tasks such as updating dependencies, regenerating files, or adjusting project settings based on the newly checked-out branch. They offer developers a powerful tool to automate workflows and maintain consistency across different branches in a Git repository.",
        "resources": [
          {
            "type": "course",
            "title": "Post-checkout hooks",
            "url": "https://git-scm.com/docs/githooks#_post_checkout"
          }
        ]
      }
    },
    {
      "id": "buxb5TpzQ-xxn0vqtGdS3",
      "name": "post-update",
      "resources": {
        "description": "# post-update\n\nGit post-update hooks are scripts that run automatically after a successful push to a repository. These hooks are executed on the remote repository and are typically used for server-side tasks such as updating other services, triggering continuous integration processes, or notifying team members about changes. Post-update hooks provide a powerful mechanism for automating workflows and maintaining consistency across different parts of a project's infrastructure, making them an essential tool for streamlining development processes and enhancing collaboration in Git-based projects.",
        "resources": [
          {
            "type": "course",
            "title": "Post-update hooks",
            "url": "https://git-scm.com/docs/githooks#post-update"
          }
        ]
      }
    },
    {
      "id": "HhpAIzYMlMiQ9msrYZyDB",
      "name": "pre-commit",
      "resources": {
        "description": "# pre-commit\n\nGit pre-commit hooks are scripts that run automatically before a commit is created, allowing developers to enforce code quality standards and catch issues early in the development process. These hooks can perform tasks such as linting, formatting, running tests, or checking for sensitive information, ensuring that only clean and compliant code is committed to the repository. By intercepting the commit process, pre-commit hooks help maintain code consistency, reduce errors, and streamline the overall development workflow, making them a valuable tool for enforcing best practices and improving code quality across a project.",
        "resources": [
          {
            "type": "tutorial",
            "title": "pre-commit/pre-commit",
            "url": "https://github.com/pre-commit/pre-commit"
          },
          {
            "type": "course",
            "title": "Git Hooks",
            "url": "https://www.atlassian.com/git/tutorials/git-hooks"
          }
        ]
      }
    },
    {
      "id": "j5kWEUKwBFg5EMm8-61K9",
      "name": "pre-push",
      "resources": {
        "description": "# pre-push\n\nGit pre-push hooks are scripts that run automatically before a push operation is executed, providing a final checkpoint to validate changes before they are shared with a remote repository. These hooks allow developers to perform last-minute checks, such as running tests, linting code, or verifying commit messages, to ensure that only high-quality and compliant code is pushed. By intercepting the push process, pre-push hooks help maintain code integrity, prevent accidental pushes of incomplete or broken code, and enforce project-specific rules, making them a valuable tool for maintaining code quality and consistency across distributed development teams.",
        "resources": [
          {
            "type": "article",
            "title": "pre-push hooks",
            "url": "https://dev.to/jameson/pre-push-hooks-42g5"
          },
          {
            "type": "video",
            "title": "Detect secrets with a pre-commit git hook",
            "url": "https://www.youtube.com/watch?v=8bDKn3y7Br4"
          }
        ]
      }
    },
    {
      "id": "fjAFNjNNbPOzme9Uk_fDV",
      "name": "Submodules",
      "resources": {
        "description": "# Submodules\n\nIn Git, submodules allow you to include another repository within a project. This feature enables the management of external dependencies as part of the main project.\n\n- Including external repositories: Submodules can be used to include other Git repositories within your project.\n- Managing dependencies: They provide a way to manage and track changes in external dependencies.",
        "resources": [
          {
            "type": "course",
            "title": "Git Submodules",
            "url": "https://git-scm.com/book/en/v2/Git-Tools-Submodules"
          },
          {
            "type": "article",
            "title": "Git Submodules Tutorial",
            "url": "https://www.atlassian.com/git/tutorials/git-submodule"
          }
        ]
      }
    },
    {
      "id": "x4bnsPVTiX2xOCSyrgWpF",
      "name": "Adding / Updating",
      "resources": {
        "description": "# Adding / Updating\n\nTo add a submodule to a repository, use `git submodule add https://github.com/user/submodule-repo.git`, which is the typical format for specifying the URL of the submodule repository. This creates a new folder for the submodule and checks it out at the specified revision. To update an existing submodule to its latest commit, run `git submodule update`. If you want to pull in changes from upstream while keeping your submodule's history intact, use `git submodule sync` followed by `git submodule update`.",
        "resources": [
          {
            "type": "article",
            "title": "Git submodules",
            "url": "https://www.atlassian.com/git/tutorials/git-submodule"
          },
          {
            "type": "article",
            "title": "Working with submodules",
            "url": "https://github.blog/open-source/git/working-with-submodules/"
          }
        ]
      }
    },
    {
      "id": "d0-u_-_vtPK8tnUpnj_NB",
      "name": "What and Why use?",
      "resources": {
        "description": "# What and Why use?\n\nGit submodules are a feature that allows you to include one Git repository within another. They are useful for managing external dependencies or shared components across projects.\n\n## Key points\n\n1. Separate repositories with independent histories\n2. Parent repository tracks specific submodule commits\n3. Enables code reuse and modular project structure\n4. Helps manage dependencies and keep main repository focused\n5. Facilitates collaboration on complex projects\n\n## Benefits\n\n- Including third-party libraries\n- Sharing common code\n- Managing multi-component projects\n- Keeping main repository lightweight\n\nNote: While powerful, submodules can add complexity to your workflow, so careful consideration is needed before implementation.",
        "resources": [
          {
            "type": "article",
            "title": "Git Submodules: Core Concept, Workflows, and Tips",
            "url": "https://www.atlassian.com/git/tutorials/git-submodule"
          },
          {
            "type": "video",
            "title": "Git Submodules Tutorial",
            "url": "https://www.youtube.com/watch?v=gSlXo2iLBro"
          }
        ]
      }
    },
    {
      "id": "h9cf_dh_pwjialOXOlNW-",
      "name": "GitHub CLI",
      "resources": {
        "description": "# GitHub CLI\n\nGitHub CLI is a command-line interface tool that brings GitHub functionality to your terminal. It allows developers to interact with GitHub directly from the command line, enabling them to manage repositories, create issues, pull requests, and perform various GitHub operations without leaving their terminal environment. This powerful tool streamlines workflows, enhances productivity, and provides a seamless integration between local development and GitHub's collaborative features, making it easier for developers to incorporate GitHub into their daily coding routines.",
        "resources": [
          {
            "type": "course",
            "title": "GitHub CLI Docs",
            "url": "https://cli.github.com/"
          },
          {
            "type": "video",
            "title": "What is the GitHub CLI?",
            "url": "https://www.youtube.com/watch?v=uy_PEGgUF4U"
          }
        ]
      }
    },
    {
      "id": "vHfpoVbOW0DHNtiy0VN4X",
      "name": "Installation and Setup",
      "resources": {
        "description": "# Installation and Setup\n\nThe GitHub CLI can be installed on Windows, macOS, and Linux operating systems. Installation options include downloading binaries directly from the release page or using package managers (such as homebrew, pip, etc).\n\nOnce installed, setting up the GitHub CLI typically involves authenticating with your GitHub account by running `gh auth login` in your terminal. This step is essential for linking your GitHub credentials to the CLI, allowing you to interact with your repositories and perform various actions.",
        "resources": [
          {
            "type": "course",
            "title": "GitHub CLI - Installation",
            "url": "https://github.com/cli/cli?tab=readme-ov-file#installation"
          },
          {
            "type": "course",
            "title": "GitHub CLI - Release",
            "url": "https://github.com/cli/cli/releases/"
          },
          {
            "type": "course",
            "title": "GitHub CLI Quickstart",
            "url": "https://docs.github.com/en/github-cli/github-cli/quickstart"
          }
        ]
      }
    },
    {
      "id": "lw4zHuhtxIO4kDvbyiVfq",
      "name": "Repository management",
      "resources": {
        "description": "# Repository management\n\nUsing GitHub CLI for repository management allows you to streamline tasks and work more efficiently. ou can use GitHub CLI to manage repositories with the following commands:\n\n- `gh repo create`: Create a new repository.\n- `gh repo delete`: Delete an existing repository.\n- `gh repo visibility`: Change the repository's visibility (public or private).\n- `gh repo topic`: Manage topic labels for a repository.",
        "resources": [
          {
            "type": "course",
            "title": "gh repo",
            "url": "https://cli.github.com/manual/gh_repo"
          },
          {
            "type": "article",
            "title": "Efficient GitHub Operations: Simplifying Repository Management using GitHub CLI",
            "url": "https://dev.to/yutee_okon/efficient-github-operations-simplifying-repository-management-using-github-cli-190l"
          },
          {
            "type": "video",
            "title": "GitHub CLI (gh) - How to manage repositories more efficiently",
            "url": "https://www.youtube.com/watch?v=BII6ZY2Rnlc"
          }
        ]
      }
    },
    {
      "id": "kGnZifvXbHBf5zXIsfAQw",
      "name": "Issue Management",
      "resources": {
        "description": "# Issue Management\n\nThe GitHub CLI provides a range of features for managing issues within your repository. Here are some key actions you can perform:\n\n- Listing issues: Run `gh issue list` to view a list of all open and closed issues.\n- Creating issues: Use `gh issue create --title \"Issue Title\" --body \"Issue body\"` to create a new issue with the specified title and body.\n- Assigning issues: Run `gh issue assign <issue-number> <username>` to assign an issue to a specific user.\n- Labelling issues: Use `gh issue label <issue-number> <label-name>` to add a label to an existing issue.\n- Closing issues: Run `gh issue close <issue-number>` to mark an issue as closed.",
        "resources": [
          {
            "type": "course",
            "title": "gh issue",
            "url": "https://cli.github.com/manual/gh_issue"
          },
          {
            "type": "video",
            "title": "Manage GitHub Issues From The Command Line Using GitHub CLI",
            "url": "https://www.youtube.com/watch?v=nuCQiP41jU0"
          }
        ]
      }
    },
    {
      "id": "s3MzDYFPMASqiS8UnvWzW",
      "name": "Pull Requests",
      "resources": {
        "description": "# Pull Requests\n\nYou can use GitHub CLI to manage pull requests with the following commands:\n\n- `gh pr create`: Create a new pull request.\n- `gh pr merge`: Merge a pull request into the target branch.\n- `gh pr list`: List all pull requests for a repository.\n- `gh pr view`: View details of a specific pull request.",
        "resources": [
          {
            "type": "course",
            "title": "gh pr",
            "url": "https://cli.github.com/manual/gh_pr"
          },
          {
            "type": "video",
            "title": "Use GitHub CLI For Command Line Pull Request Management",
            "url": "https://www.youtube.com/watch?v=Ku9_0Mftiic"
          }
        ]
      }
    },
    {
      "id": "AmetdCURXXob5TUsikAab",
      "name": "GitHub Actions",
      "resources": {
        "description": "# GitHub Actions\n\nGitHub Actions is a very useful tool for automation, allowing developers to automate tasks within the software development lifecycle directly on GitHub.\n\nOne of the best ways to learn about GitHub Actions is through the course offered by Microsoft Learn. This course is well-structured and provides practical examples that are concise and easy to understand.",
        "resources": [
          {
            "type": "course",
            "title": "GitHub Actions",
            "url": "https://docs.github.com/en/actions"
          },
          {
            "type": "course",
            "title": "Microsoft Learn: Introduction to GitHub Actions",
            "url": "https://learn.microsoft.com/en-us/collections/n5p4a5z7keznp5"
          },
          {
            "type": "course",
            "title": "YouTube: GitHub Actions Playlist",
            "url": "https://www.youtube.com/watch?v=-hVG9z0fCac&list=PLArH6NjfKsUhvGHrpag7SuPumMzQRhUKY&pp=iAQB"
          },
          {
            "type": "video",
            "title": "What are GitHub Actions",
            "url": "https://www.youtube.com/watch?v=URmeTqglS58"
          }
        ]
      }
    },
    {
      "id": "p6rq3lQ9YRrTqwcc31O23",
      "name": "YAML Syntax",
      "resources": {
        "description": "# YAML Syntax\n\nYAML (YAML Ain't Markup Language) is a human-readable data serialization standard for all programming languages. It is designed to be easily readable by humans while also being machine-parsable. Key features of YAML include:\n\n1. Simplicity: YAML uses a minimalist syntax with significant whitespace and indentation.\n\n2. Versatility: It can represent various data types, including scalars, lists, and associative arrays.\n\n3. Readability: Its clear, concise format makes it easy for both humans and machines to understand.\n\n4. Language-independent: YAML can be used with any programming language that has a YAML parser.\n\nYAML is commonly used for:\n\n- Configuration files: Many applications and tools use YAML for their configuration settings.\n- Data exchange: It serves as a lightweight alternative to XML or JSON for data transfer between systems.\n- Data storage: YAML can be used to store structured data in a human-readable format.\n- DevOps and CI/CD: It's widely used in tools like Docker, Kubernetes, and various CI/CD platforms for defining workflows and configurations.\n\nUnderstanding YAML syntax is crucial for working with modern development tools, especially in the realms of DevOps, cloud computing, and containerization.",
        "resources": [
          {
            "type": "course",
            "title": "YAML",
            "url": "https://yaml.org/"
          },
          {
            "type": "article",
            "title": "YAML Cheatsheet",
            "url": "https://cheatsheets.zip/yaml"
          },
          {
            "type": "article",
            "title": "What is YAML?",
            "url": "https://circleci.com/blog/what-is-yaml-a-beginner-s-guide/"
          },
          {
            "type": "article",
            "title": "YAML Tutorial : A Complete Language Guide with Examples",
            "url": "https://spacelift.io/blog/yaml"
          }
        ]
      }
    },
    {
      "id": "55uHPFNwYPVZx8Cy3c985",
      "name": "Workflow Triggers",
      "resources": {
        "description": "# Workflow Triggers\n\nWorkflow triggers are events that initiate a GitHub Actions workflow. They can be scheduled, triggered by code changes, or manually initiated. This allows for automation of tasks based on specific conditions.",
        "resources": [
          {
            "type": "course",
            "title": "GitHub Actions Documentation",
            "url": "https://docs.github.com/en/actions"
          },
          {
            "type": "course",
            "title": "GitHub Actions Triggers",
            "url": "https://docs.github.com/en/actions/reference/events-that-trigger-workflows"
          }
        ]
      }
    },
    {
      "id": "uS1H9KoKGNONvETCuFBbz",
      "name": "Scheduled Worfklows",
      "resources": {
        "description": "# Scheduled Worfklows\n\nGitHub Actions allows you to schedule workflows to run at specific times or intervals. You can set up workflows to automatically run at predetermined times, such as daily or weekly.",
        "resources": [
          {
            "type": "course",
            "title": "Events that trigger workflows - Schedule",
            "url": "https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows#schedule"
          },
          {
            "type": "video",
            "title": "GitHub Actions - How to Schedule workflows in GitHub",
            "url": "https://www.youtube.com/watch?v=StipNrK__Gk"
          }
        ]
      }
    },
    {
      "id": "6QwlY3dEvjfAOPALcWKXQ",
      "name": "Workflow Runners",
      "resources": {
        "description": "# Workflow Runners\n\nWorkflow runners are the environments where GitHub Actions workflows are executed. They are hosted on GitHub-hosted virtual machines (GHVMs) or self-hosted runners. Each runner has a specific configuration and capabilities, depending on its type.",
        "resources": [
          {
            "type": "course",
            "title": "GitHub Actions Runners",
            "url": "https://docs.github.com/en/actions/hosting-your-own-runners/about-self-hosted-runners"
          },
          {
            "type": "video",
            "title": "GitHub Actions Self-hosted runners",
            "url": "https://www.youtube.com/watch?v=aLHyPZO0Fy0"
          }
        ]
      }
    },
    {
      "id": "BnPiTu1Jw2kIW560a2A5T",
      "name": "Workflow Context",
      "resources": {
        "description": "# Workflow Context\n\nWorkflow context in GitHub Actions refers to the environment and variables that are available to a workflow. It includes information about the workflow's execution, such as the event that triggered it, the repository, and the workflow itself.",
        "resources": [
          {
            "type": "course",
            "title": "GitHub Actions Contexts",
            "url": "https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/contexts"
          },
          {
            "type": "video",
            "title": "Working with contexts in GitHub Actions",
            "url": "https://www.youtube.com/watch?v=16WT_r0zjYE"
          }
        ]
      }
    },
    {
      "id": "aflP7oWsQzAr4YPo2LLiQ",
      "name": "Secrets and Env Vars",
      "resources": {
        "description": "# Secrets and Env Vars\n\nGitHub provides features to securely store and manage sensitive data, such as secrets and environment variables.\n\n- Secrets: These are sensitive values that should not be committed to a repository, like API keys or database credentials.\n- Environment Variables: They can be used to set values for your workflow or application, making it easier to manage dependencies.",
        "resources": [
          {
            "type": "course",
            "title": "Using secrets in GitHub Actions",
            "url": "https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions"
          },
          {
            "type": "course",
            "title": "Store information in variables",
            "url": "https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/store-information-in-variables"
          },
          {
            "type": "video",
            "title": "Secrets and Environment Variables in your GitHub Action",
            "url": "https://www.youtube.com/watch?v=dPLPSaFqJmY"
          }
        ]
      }
    },
    {
      "id": "HMNhzzV6ApTKj4I_FOmUB",
      "name": "Caching Dependencies",
      "resources": {
        "description": "# Caching Dependencies\n\nGitHub Actions provides a caching feature that allows you to store and reuse dependencies between workflows, reducing the time it takes to run your actions. By caching dependencies, you can:\n\n- Reuse compiled code\n- Store database connections\n- Reduce network traffic\n\nIt is highly recommended to not store any sensitive information in the cache. For example, sensitive information can include access tokens or login credentials stored in a file in the cache path.",
        "resources": [
          {
            "type": "course",
            "title": "Caching dependencies to speed up workflows",
            "url": "https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/caching-dependencies-to-speed-up-workflows"
          },
          {
            "type": "video",
            "title": "Cache Management with GitHub actions",
            "url": "https://www.youtube.com/watch?v=7PVUjRXUY0o"
          }
        ]
      }
    },
    {
      "id": "alysXC4b1hGi9ZdQ5-40y",
      "name": "Storing Artifacts",
      "resources": {
        "description": "# Storing Artifacts\n\nGitHub provides a feature for storing artifacts, which allows you to upload build outputs or other files as part of your workflow.\n\n- Artifacts: These are files generated by a job, such as compiled binaries, test reports, or logs. They can be used to validate the results of a build or deployment.\n- Referenceable storage: Artifacts are stored in a referenceable way, making it easy to access and use them in future builds.",
        "resources": [
          {
            "type": "course",
            "title": "Storing and sharing data from a workflow",
            "url": "https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/storing-and-sharing-data-from-a-workflow"
          }
        ]
      }
    },
    {
      "id": "jc4R1zhd1YeCEbVuxwJWy",
      "name": "Workflow Status",
      "resources": {
        "description": "# Workflow Status\n\nWorkflow status in GitHub Actions refers to the current state of a workflow run. It can be one of the following:\n\n- Pending: The workflow is waiting for an event to trigger it.\n- In Progress: The workflow is currently running.\n- Completed: The workflow has finished running.\n- Failed: The workflow has failed due to an error.",
        "resources": [
          {
            "type": "article",
            "title": "Adding a workflow status badge to your repository",
            "url": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/adding-a-workflow-status-badge"
          }
        ]
      }
    },
    {
      "id": "SsogoCgJIbeTD6tk8UhTe",
      "name": "Marketplace Actions",
      "resources": {
        "description": "# Marketplace Actions\n\nThe GitHub Marketplace offers a wide range of pre-built actions that can be used to automate tasks and workflows within your repository.\n\n- Automate tasks: Use marketplace actions to automate tasks such as testing, deployment, or security.\n- Customize workflows: Create custom workflows using marketplace actions to tailor the build process to specific needs.\n- Streamline development: By automating repetitive tasks, developers can focus on code quality and collaboration.\n\nThese actions are created by the GitHub community and can be easily added to your workflow to enhance productivity and efficiency.",
        "resources": [
          {
            "type": "course",
            "title": "GitHub MarketPlace - Actions",
            "url": "https://github.com/marketplace?type=actions"
          }
        ]
      }
    },
    {
      "id": "PUnYNBrAZWoZiopjtNgnA",
      "name": "Usecases",
      "resources": {
        "description": "# Usecases\n\nGitHub Actions offer a wide range of automation possibilities for your development workflow. Here are some common use cases:\n\n1. Continuous Integration (CI): Automatically build and test your code on every push or pull request.\n2. Continuous Deployment (CD): Automatically deploy your application to various environments after successful builds.\n3. Code Quality Checks: Run linters, formatters, and other code quality tools automatically.\n4. Dependency Updates: Automatically create pull requests for outdated dependencies.\n5. Issue and PR Management: Automatically label, assign, or close issues and pull requests based on certain conditions.\n6. Scheduled Tasks: Run periodic maintenance tasks, backups, or data processing jobs.\n7. Security Scanning: Perform automated security checks on your codebase and dependencies.\n8. Documentation Generation: Automatically generate and publish documentation for your project.\n9. Cross-platform Testing: Test your code on multiple operating systems and environments simultaneously.\n10. Release Management: Automate the creation of release notes and asset uploads for new versions.",
        "resources": [
          {
            "type": "course",
            "title": "GitHub Actions Documentation",
            "url": "https://docs.github.com/en/actions"
          },
          {
            "type": "article",
            "title": "How GitHub Actions 10x my productivity",
            "url": "https://www.youtube.com/watch?v=yfBtjLxn_6k"
          }
        ]
      }
    },
    {
      "id": "Ni3HKVLanFvSrJ3u8i5I1",
      "name": "What are these?",
      "resources": {
        "description": "# What are these?\n\nGitHub Actions is a powerful automation and continuous integration/continuous deployment (CI/CD) platform provided by GitHub. It allows developers to create custom workflows that automatically build, test, and deploy their code directly from their GitHub repositories. These workflows are triggered by specific events, such as push requests, pull requests, or scheduled tasks. GitHub Actions enables teams to streamline their development processes, improve code quality, and accelerate software delivery by automating repetitive tasks and integrating various tools and services seamlessly within their development pipeline.",
        "resources": [
          {
            "type": "article",
            "title": "Understanding GitHub Actions",
            "url": "https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions"
          },
          {
            "type": "video",
            "title": "GitHub Actions Tutorial - Basic Concepts and CI/CD Pipeline with Docker",
            "url": "https://www.youtube.com/watch?v=R8_veQiYBjI"
          }
        ]
      }
    },
    {
      "id": "Y0EWgPsS4kZxH3y53jNxY",
      "name": "Use in Automation",
      "resources": {
        "description": "# Use in Automation\n\nGitHub CLI is a powerful tool for automating GitHub-related tasks directly from the command line. It enables developers to streamline workflows and integrate GitHub processes into scripts and automated systems.\n\nKey uses in automation:\n\n1. CI/CD: Automate PR creation, review, merging, and release management\n2. Issue and Project Management: Create, update, and close issues; manage project boards\n3. Repository Management: Clone repos, create forks, manage settings and collaborators\n4. GitHub Actions Integration: Trigger and monitor workflows, manage secrets\n5. Scripting and Batch Operations: Perform bulk actions across multiple repositories\n\nTo use GitHub CLI in automation:\n\n1. Install GitHub CLI\n2. Authenticate with your GitHub account\n3. Learn basic commands and syntax\n4. Integrate CLI commands into scripts or automation tools",
        "resources": [
          {
            "type": "course",
            "title": "GitHub CLI documentation",
            "url": "https://cli.github.com/manual/"
          },
          {
            "type": "article",
            "title": "Automating your workflow with GitHub CLI",
            "url": "https://github.blog/2021-03-11-scripting-with-github-cli/"
          }
        ]
      }
    },
    {
      "id": "sFf1PdFfmEdQxsEntfeFq",
      "name": "Git Patch",
      "resources": {
        "description": "# Git Patch\n\nIn Git, a patch is a file that contains a set of changes made to a project's codebase. It's essentially a diff (difference) file that shows the modifications between two versions of a commit or a branch. However, despite its usefulness in certain contexts, the use of Git patches has declined somewhat with the advent of more modern and efficient ways to manage code changes.",
        "resources": [
          {
            "type": "article",
            "title": "Git Patch",
            "url": "https://www.gitkraken.com/learn/git/git-patch"
          },
          {
            "type": "article",
            "title": "How to generate and apply patches with git?",
            "url": "https://gist.github.com/nepsilon/22bc62a23f785716705c"
          }
        ]
      }
    },
    {
      "id": "hru0sL1-D4bJSQI1efEyU",
      "name": "Git Reflog",
      "resources": {
        "description": "# Git Reflog\n\nGit reflog is a powerful tool in Git that keeps a record of all the changes made to the branches and commits in your repository, including actions that are not part of the regular commit history, such as resetting branches or checking out commits. It's particularly useful for recovering lost commits or understanding the history of changes in your repository, even if those changes are not reflected in the normal commit history.Reflog stands for \"reference log.\" It records when the tip of branches or other references (like HEAD) is updated in your repository.",
        "resources": [
          {
            "type": "course",
            "title": "Git - git-reflog Documentation",
            "url": "https://git-scm.com/docs/git-reflog"
          },
          {
            "type": "article",
            "title": "What is the Git Reflog? | Learn Version Control with Git",
            "url": "https://www.git-tower.com/learn/git/faq/what-is-git-reflog"
          },
          {
            "type": "video",
            "title": "Learn Git Essentials 12: Git Reflog",
            "url": "https://youtu.be/RVu8lpS7JFY?si=eNGBpsYfHtlyPClj"
          },
          {
            "type": "video",
            "title": "Git Reflog Command. Get all log details of the reference using git reflog show command",
            "url": "https://youtu.be/I4f4pddD16g?si=0Ny7xOJgiPgdfuh6"
          }
        ]
      }
    },
    {
      "id": "ExXuwTQSI_lg4SRGW3Iu1",
      "name": "Git Bisect",
      "resources": {
        "description": "# Git Bisect\n\nGit Bisect is an interactive tool used to identify which commit in your project's history introduced a bug or regression. You start by identifying two commits: one where the issue isn't present (the \"good\" commit) and another where it is (the \"bad\" commit). Then, run `git bisect start`, followed by `git bisect good` for the good commit and `git bisect bad` for the bad commit. Git Bisect will guide you through a binary search process, asking you to test the midpoint of your current range until it identifies the exact commit that introduced the bug or regression.",
        "resources": [
          {
            "type": "course",
            "title": "Git Bisect",
            "url": "https://git-scm.com/docs/git-bisect"
          },
          {
            "type": "article",
            "title": "Using `git bisect` to find the faulty commit",
            "url": "https://dev.to/alvesjessica/using-git-bisect-to-find-the-faulty-commit-25gf"
          },
          {
            "type": "video",
            "title": "Git Bisect | How to use Git Bisect | Learn Git",
            "url": "https://www.youtube.com/watch?v=z-AkSXDqodc"
          }
        ]
      }
    },
    {
      "id": "4dxVN81rXWn6VZqK99yq0",
      "name": "Git Worktree",
      "resources": {
        "description": "# Git Worktree\n\nA Git worktree allows you to create multiple working directories for a single repository, each with its own checkout and index. Unlike a regular checkout, which creates a new working directory for a specific branch and updates your IDE's configuration settings, a Git worktree does not require you to switch between branches using git checkout. This means you can have multiple branches checked out at the same time without affecting each other or requiring changes to your IDE configurations. By creating a separate worktree for each branch, you can stage changes independently and maintain distinct working directories without impacting the main repository or its working directory.",
        "resources": [
          {
            "type": "article",
            "title": "Git Worktree",
            "url": "https://www.gitkraken.com/learn/git/git-worktree"
          },
          {
            "type": "video",
            "title": "Manage Branches easily using Git Worktree",
            "url": "https://www.youtube.com/watch?v=cRunWRC8ye0"
          }
        ]
      }
    },
    {
      "id": "CGj_UX5JMOOCKinedsNRc",
      "name": "Git Attributes",
      "resources": {
        "description": "# Git Attributes\n\nGit attributes are settings stored in the .gitattributes file, controlling how Git handles files in your repository. They can influence filtering (e.g., ignoring specific files), conversion (formatting or transforming files during Git operations), and formatting (applying consistent styles). These settings can be applied to specific file types (like *.txt) or filter files based on content patterns. Attributes also define smudge patterns (highlighting differences) and ignore patterns, helping maintain a clean repository by automatically applying intended settings for certain file types.",
        "resources": [
          {
            "type": "course",
            "title": "Customizing Git - Git Attributes",
            "url": "https://git-scm.com/book/en/v2/Customizing-Git-Git-Attributes"
          },
          {
            "type": "tutorial",
            "title": "gitattributes/gitattributes",
            "url": "https://github.com/gitattributes/gitattributes"
          },
          {
            "type": "article",
            "title": "The benefits of git attributes and how to set them up",
            "url": "https://medium.com/@cloudwala/the-benefits-of-git-attributes-and-how-to-set-them-up-87f90251b8e0"
          }
        ]
      }
    },
    {
      "id": "zdunaucVe8J1tKf_z-NQo",
      "name": "Git LFS",
      "resources": {
        "description": "# Git LFS\n\nGit Large File Storage (LFS) is an extension that helps manage large files by tracking metadata, not storing entire files. It allows storing and tracking binary assets like images, videos, audio files separately from your regular Git repository. By storing only metadata in your Git repository, you improve clone and push times, reducing storage usage. This approach is particularly useful for media repositories, large dataset storage, and binary asset management in game development. Note that Git LFS requires a separate server or storage system to store actual file content.",
        "resources": [
          {
            "type": "article",
            "title": "Learning About Git Large File System (LFS)",
            "url": "https://medium.com/swlh/learning-about-git-large-file-system-lfs-72e0c86cfbaf"
          },
          {
            "type": "video",
            "title": "Git LFS (Large File Storage) | Learn Git",
            "url": "https://www.youtube.com/watch?v=jXsvFfksvd0"
          }
        ]
      }
    },
    {
      "id": "NV2HAXLEN7tskfgyFrbaf",
      "name": "GitHub API",
      "resources": {
        "description": "# GitHub API\n\nThe GitHub API is a powerful tool that allows developers to interact with the GitHub platform programmatically. It provides access to various GitHub features, such as user data, repository information, and commit history, through both REST and GraphQL interfaces. The API supports authentication, implements rate limiting, and offers webhooks for real-time notifications, enabling developers to automate tasks, create custom integrations, and build applications that leverage GitHub's functionality.",
        "resources": [
          {
            "type": "course",
            "title": "GitHub API Docs",
            "url": "https://docs.github.com/en/rest?apiVersion=2022-11-28"
          },
          {
            "type": "article",
            "title": "Getting Started",
            "url": "https://docs.github.com/en/rest/using-the-rest-api/getting-started-with-the-rest-api?apiVersion=2022-11-28"
          }
        ]
      }
    },
    {
      "id": "lSCnKhmRr6xrKVYxO8idD",
      "name": "REST API",
      "resources": {
        "description": "# REST API\n\nThe GitHub REST API is a set of APIs that provide access to various GitHub features, such as user data, repository information, and commit history. It allows developers to interact with the GitHub platform programmatically.",
        "resources": [
          {
            "type": "course",
            "title": "GitHub REST API documentation",
            "url": "https://docs.github.com/en/rest?apiVersion=2022-11-28"
          },
          {
            "type": "course",
            "title": "Quickstart for GitHub REST API",
            "url": "https://docs.github.com/en/rest/quickstart?apiVersion=2022-11-28"
          }
        ]
      }
    },
    {
      "id": "KlXPt-K6br8PtpLgELaCj",
      "name": "GraphQL API",
      "resources": {
        "description": "# GraphQL API\n\nThe GitHub GraphQL API is a set of APIs that provides access to various GitHub features, such as user data, repository information, and commit history. It allows developers to interact with the GitHub platform programmatically using GraphQL queries.",
        "resources": [
          {
            "type": "course",
            "title": "GitHub GraphQL API documentation",
            "url": "https://docs.github.com/en/graphql"
          },
          {
            "type": "course",
            "title": "Forming calls with GraphQL",
            "url": "https://docs.github.com/en/graphql/guides/forming-calls-with-graphql"
          }
        ]
      }
    },
    {
      "id": "5Oax1p7zIZ9HD2hmENPof",
      "name": "Creating Apps",
      "resources": {
        "description": "# Creating Apps\n\nGitHub Apps are a way to integrate with the GitHub platform programmatically, using either the REST API or GraphQL API. They allow developers to create custom integrations that can automate tasks, provide real-time notifications, and build custom workflows.",
        "resources": [
          {
            "type": "course",
            "title": "Creating GitHub Apps",
            "url": "https://docs.github.com/en/apps/creating-github-apps"
          }
        ]
      }
    },
    {
      "id": "560GJXFTt7DPdJjKtSDOo",
      "name": "GitHub Apps",
      "resources": {
        "description": "# GitHub Apps\n\nA GitHub App is a way to integrate with the GitHub platform programmatically, using either the REST API or GraphQL API. It allows developers to create custom integrations that can automate tasks, provide real-time notifications, and build custom workflows.",
        "resources": [
          {
            "type": "course",
            "title": "GitHub Apps Documentation",
            "url": "https://docs.github.com/en/apps"
          }
        ]
      }
    },
    {
      "id": "qrdOARfqGPF9xhF6snbAn",
      "name": "OAuth Apps",
      "resources": {
        "description": "# OAuth Apps\n\nGitHub OAuth Apps allow developers to integrate with GitHub using OAuth 2.0 authentication. They enable secure, token-based access to specific GitHub resources like repositories, issues, and pull requests. OAuth Apps can automate tasks, personalize interactions, and provide real-time notifications through webhooks, all while allowing users to approve only the necessary permissions without sharing their credentials.",
        "resources": [
          {
            "type": "course",
            "title": "Creating an OAuth app",
            "url": "https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/creating-an-oauth-app"
          },
          {
            "type": "video",
            "title": "GitHub Login With React (GitHub APIs, GitHub OAuth 2.0 Authentication)",
            "url": "https://www.youtube.com/watch?v=rRn2EisxPl4"
          }
        ]
      }
    },
    {
      "id": "MoG7D9kqPuA6o52-z_WDN",
      "name": "Webhooks",
      "resources": {
        "description": "# Webhooks\n\nGitHub Webhooks allow developers to receive real-time notifications about events happening within their repository, such as commits, pull requests, and issues. These webhooks enable users to automate tasks, integrate with other services, and build custom workflows.",
        "resources": [
          {
            "type": "course",
            "title": "About webhooks",
            "url": "https://docs.github.com/en/webhooks/about-webhooks"
          },
          {
            "type": "course",
            "title": "Webhooks documentation",
            "url": "https://docs.github.com/en/webhooks"
          },
          {
            "type": "video",
            "title": "How to use GitHub Webhooks with Discord",
            "url": "https://www.youtube.com/watch?v=-gyEHj0CVx0&"
          }
        ]
      }
    },
    {
      "id": "vhdGUhMAyre_Xya6IxZ-t",
      "name": "GitHub Sponsors",
      "resources": {
        "description": "# GitHub Sponsors\n\nA GitHub Sponsor is a way to support and fund open-source projects on GitHub. It allows maintainers of public repositories to receive financial support from users who value their work. Sponsors can contribute funds to help with expenses, development time, or other project-related costs. In return, sponsors are recognized as supporters in the repository's README file and on the project's website. This feature promotes transparency, accountability, and appreciation within open-source communities, making it easier for maintainers to focus on their projects.",
        "resources": [
          {
            "type": "course",
            "title": "Sponsoring an open source contributor through GitHub",
            "url": "https://docs.github.com/en/sponsors/sponsoring-open-source-contributors/sponsoring-an-open-source-contributor-through-github"
          },
          {
            "type": "course",
            "title": "Receiving sponsorships through GitHub Sponsors",
            "url": "https://docs.github.com/en/sponsors/receiving-sponsorships-through-github-sponsors"
          }
        ]
      }
    },
    {
      "id": "bnai6R6pOq_L5CPdbVwMW",
      "name": "GitHub Pages",
      "resources": {
        "description": "# GitHub Pages\n\nGitHub Pages is a feature that allows users to host and publish web content directly from their GitHub repositories. It provides a simple way to create and deploy websites, blogs, or projects without the need for manual configuration or maintenance. Users can upload custom themes, add plugins, and use various tools to customize their pages.",
        "resources": [
          {
            "type": "course",
            "title": "About GitHub Pages",
            "url": "https://docs.github.com/en/pages/getting-started-with-github-pages/about-github-pages"
          },
          {
            "type": "course",
            "title": "Creating a GitHub Pages site",
            "url": "https://docs.github.com/en/pages/getting-started-with-github-pages/creating-a-github-pages-site"
          },
          {
            "type": "course",
            "title": "GitHub Pages examples",
            "url": "https://github.com/collections/github-pages-examples"
          }
        ]
      }
    },
    {
      "id": "M2_hBvXou7cCNqsMnexCt",
      "name": "GitHub Gists",
      "resources": {
        "description": "# GitHub Gists\n\nA GitHub Gist is a small code or text snippet that can be shared with others. It is a simple way to share code, configuration files, or other snippets of text without creating a full-fledged repository. Gists are useful for sharing examples, demos, or tutorials, and they can also serve as a starting point for larger projects. Each gist has a unique URL that can be shared with others, allowing them to view and edit the content. Gists support various file types, including code files, text files, and even images. They also provide features like syntax highlighting, line numbers, and commit history.",
        "resources": [
          {
            "type": "course",
            "title": "Creating Gists",
            "url": "https://docs.github.com/en/get-started/writing-on-github/editing-and-sharing-content-with-gists/creating-gists"
          },
          {
            "type": "course",
            "title": "REST API endpoints for Gists",
            "url": "https://docs.github.com/en/rest/gists/gists?apiVersion=2022-11-28"
          }
        ]
      }
    },
    {
      "id": "rqPCHh25xX_ROMr-ULpaw",
      "name": "GitHub Packages",
      "resources": {
        "description": "# GitHub Packages\n\nGitHub Packages is a package repository service that allows developers to store and share packages, containers, and other software artifacts. It provides a central location for sharing packages with teams, organizations, or the wider developer community. GitHub Packages supports popular package managers like npm, Maven, and Gradle, as well as container registries like Docker Hub. This feature enables seamless integration of packages into development workflows, making it easier to share dependencies, libraries, and frameworks within and across projects. By using GitHub Packages, developers can simplify dependency management, reduce errors, and improve overall collaboration.",
        "resources": [
          {
            "type": "course",
            "title": "Introduction to GitHub Packages",
            "url": "https://docs.github.com/en/packages/learn-github-packages/introduction-to-github-packages"
          },
          {
            "type": "course",
            "title": "GitHub Packages documentation",
            "url": "https://docs.github.com/en/packages"
          }
        ]
      }
    },
    {
      "id": "ZHplGidvhxEIC3HN8KqRa",
      "name": "Deploying Static Websites",
      "resources": {
        "description": "# Deploying Static Websites\n\nDeploying static websites on GitHub Pages involves uploading and serving website content that is generated beforehand, without dynamic functionality. This approach allows for fast deployment, low maintenance, and improved security.",
        "resources": [
          {
            "type": "article",
            "title": "How to Deploy a Static Website for Free Using GitHub Pages",
            "url": "https://medium.com/flycode/how-to-deploy-a-static-website-for-free-using-github-pages-8eddc194853b"
          },
          {
            "type": "video",
            "title": "How to Host a Website on GitHub Pages Free (Custom Domain Setup Included)",
            "url": "https://www.youtube.com/watch?v=e5AwNU3Y2es"
          }
        ]
      }
    },
    {
      "id": "VdoxEWaU56-QCbHFRw649",
      "name": "Custom Domains",
      "resources": {
        "description": "# Custom Domains\n\nOn GitHub Pages, users can customize their site's URL by connecting a custom domain to their repository. This feature allows users to use their own domain name instead of the default GitHub.io subdomain, giving their site a more professional and personalized look.",
        "resources": [
          {
            "type": "course",
            "title": "Configuring a Custom Domain for Your GitHub Pages Site",
            "url": "https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site"
          },
          {
            "type": "video",
            "title": "How to Host a Website on GitHub Pages Free (Custom Domain Setup Included)",
            "url": "https://www.youtube.com/watch?v=e5AwNU3Y2es&t=156s"
          }
        ]
      }
    },
    {
      "id": "iwfNYDlAgbA_rpWYcoHCC",
      "name": "Static Site Generators",
      "resources": {
        "description": "# Static Site Generators\n\nGitHub offers a set of static site generators (SSGs) that allow users to create and deploy websites directly from their GitHub repositories. These SSGs include `Jekyll`, `Hugo`, and `Middleman`, among others. They provide a simple way to build websites without the need for manual configuration or maintenance.",
        "resources": [
          {
            "type": "course",
            "title": "Static Site Generators",
            "url": "https://github.com/collections/static-site-generators"
          },
          {
            "type": "course",
            "title": "About GitHub Pages and Jekyll",
            "url": "https://docs.github.com/en/pages/setting-up-a-github-pages-site-with-jekyll/about-github-pages-and-jekyll"
          }
        ]
      }
    },
    {
      "id": "NdfwgwMOewiyEAFyC2l7U",
      "name": "GitHub Codespaces",
      "resources": {
        "description": "# GitHub Codespaces\n\nGitHub Codespaces is a cloud-based development environment that allows developers to create, access, and use pre-configured, ready-to-use environments for coding. It provides a seamless way to develop, test, and debug applications in a virtual machine or container, eliminating the need for local setup and configuration. With GitHub Codespaces, users can spin up a new environment with their desired configuration, tools, and dependencies in just a few clicks. This feature streamlines development workflows, reduces friction, and increases productivity by providing instant access to a tailored coding environment for each project.",
        "resources": [
          {
            "type": "course",
            "title": "GitHub Codespaces Overview",
            "url": "https://docs.github.com/en/codespaces/overview"
          },
          {
            "type": "video",
            "title": "How to Deploy a GitHub Codespace",
            "url": "https://www.youtube.com/watch?v=_01iCF9sO1c"
          }
        ]
      }
    },
    {
      "id": "pFyMiyNQ16-kP7jKaKKEU",
      "name": "GitHub Education",
      "resources": {
        "description": "# GitHub Education\n\nGitHub Education is a program that provides free and discounted access to GitHub's developer tools, services, and resources for students, teachers, and researchers. This program aims to support education and research in software development, by making it easier for students and educators to learn, collaborate, and build projects on GitHub. By using GitHub Education, students can gain hands-on experience with real-world coding challenges, while educators can create a more engaging and interactive learning environment.",
        "resources": [
          {
            "type": "course",
            "title": "official GitHub Education Docs",
            "url": "https://education.github.com/"
          },
          {
            "type": "video",
            "title": "GitHub GitHub Education: free programs, technology, and opportunities available for Students",
            "url": "https://www.youtube.com/watch?v=HIVFdN9VGgw"
          }
        ]
      }
    },
    {
      "id": "XRSVRl6iHncMmgSXoB7Lq",
      "name": "Student Developer Pack",
      "resources": {
        "description": "# Student Developer Pack\n\nThe GitHub Student Developer Pack is a collection of developer tools and resources that are offered free or at a discounted price to students through the GitHub Education program. This pack includes access to GitHub, GitHub Desktop, GitHub Classroom, GitHub Student Developer Kit, and other benefits. By using the Student Developer Pack, students can gain hands-on experience with professional developer tools, while also getting access to a wide range of educational resources.\n\nVisit the following resource to learn more:\n\n- [@official@Apply to GitHub Education as a student](https://docs.github.com/en/education/explore-the-benefits-of-teaching-and-learning-with-github-education/github-education-for-students/apply-to-github-education-as-a-student)",
        "resources": [
          {
            "type": "course",
            "title": "Apply to GitHub Education as a student",
            "url": "https://docs.github.com/en/education/explore-the-benefits-of-teaching-and-learning-with-github-education/github-education-for-students/apply-to-github-education-as-a-student"
          }
        ]
      }
    },
    {
      "id": "Pg6G4fzYb_RUhANeRKlRX",
      "name": "GitHub Classroom",
      "resources": {
        "description": "# GitHub Classroom\n\nGitHub Classroom is an integrated feature within GitHub that allows educators to create and assign homework assignments, projects, or quizzes directly to students. This feature streamlines the process of teaching and learning by making it easy for instructors to share code, provide feedback, and track student progress all in one place. By using GitHub Classroom, teachers can focus on high-level instruction and student engagement, while also promoting collaboration and hands-on learning experiences.",
        "resources": [
          {
            "type": "course",
            "title": "About GitHub Classroom",
            "url": "https://docs.github.com/en/education/manage-coursework-with-github-classroom/get-started-with-github-classroom/about-github-classroom"
          },
          {
            "type": "video",
            "title": "GitHub Classroom - Getting Started Guide",
            "url": "https://www.youtube.com/watch?v=xVVeqIDgCvM&list=PLIRjfNq867bewk3ZGV6Z7a16YDNRCpK3u"
          }
        ]
      }
    },
    {
      "id": "B1KiSOt2b8t8FYD7Jxw2A",
      "name": "Campus Program",
      "resources": {
        "description": "# Campus Program\n\nThe GitHub Campus Program offers GitHub Enterprise Cloud and GitHub Enterprise Server free-of-charge for schools that want to make the most of GitHub for their community. This program provides access to a comprehensive set of developer tools, as well as resources and support to help students and educators build projects, collaborate, and develop skills in software development.\n\nVisit the following resource to learn more:\n\n- [@official@About GitHub Campus Program](https://docs.github.com/en/education/explore-the-benefits-of-teaching-and-learning-with-github-education/use-github-at-your-educational-institution/about-github-campus-program)",
        "resources": [
          {
            "type": "course",
            "title": "About GitHub Campus Program",
            "url": "https://docs.github.com/en/education/explore-the-benefits-of-teaching-and-learning-with-github-education/use-github-at-your-educational-institution/about-github-campus-program"
          }
        ]
      }
    },
    {
      "id": "R20LXLLEzNn-SpyFDMRXj",
      "name": "GitHub Marketplace",
      "resources": {
        "description": "# GitHub Marketplace\n\nGitHub Marketplace is a platform that allows developers to discover, install, and manage third-party tools and services directly within their GitHub environment. These tools can provide a range of features, such as code analysis, project management, or collaboration, making it easier for developers to work efficiently and effectively. By using the GitHub Marketplace, developers can streamline their workflow, reduce friction, and focus on writing code.",
        "resources": [
          {
            "type": "course",
            "title": "GitHub Marketplace",
            "url": "https://github.com/marketplace"
          },
          {
            "type": "course",
            "title": "About GitHub Marketplace for apps",
            "url": "https://docs.github.com/en/apps/github-marketplace/github-marketplace-overview/about-github-marketplace-for-apps"
          }
        ]
      }
    },
    {
      "id": "f2PG4t6iVtfIH8BVe5H7f",
      "name": "GitHub Security",
      "resources": {
        "description": "# GitHub Security\n\nGitHub Security is a suite of features and tools that help developers identify, fix, and prevent security vulnerabilities in their code. It provides a comprehensive approach to secure coding practices by integrating with the developer's workflow. The main components of GitHub Security include: `Code Scanning`, which uses AI-powered analysis to detect potential vulnerabilities; `Dependabot`, which automates dependency updates to prevent attacks via vulnerable dependencies; `Secret scanning`, which detects and flags secrets like API keys or credentials; and `GitHub Advanced Security`, which offers more advanced security features for larger teams. By using these tools, developers can ensure their code is secure, and identify potential issues before they become serious problems.",
        "resources": [
          {
            "type": "course",
            "title": "GitHub security features",
            "url": "https://docs.github.com/en/code-security/getting-started/github-security-features"
          },
          {
            "type": "course",
            "title": "Dependabot Quick-start Guide",
            "url": "https://docs.github.com/en/code-security/getting-started/dependabot-quickstart-guide"
          },
          {
            "type": "course",
            "title": "About user alerts",
            "url": "https://docs.github.com/en/code-security/secret-scanning/managing-alerts-from-secret-scanning/about-alerts#about-user-alerts"
          }
        ]
      }
    },
    {
      "id": "4slyjdk2Eeg5VYY6gCDG6",
      "name": "GitHub Models",
      "resources": {
        "description": "# GitHub Models\n\nGitHub Models is a feature that allows developers to search, explore, and use pre-trained AI models from various sources. This platform provides a way to discover and experiment with these models, making it easier to integrate AI capabilities into software projects. By using GitHub Models, developers can quickly find and try out different models, without having to train them from scratch.",
        "resources": [
          {
            "type": "course",
            "title": "Prototyping with AI models",
            "url": "https://docs.github.com/en/github-models/prototyping-with-ai-models"
          },
          {
            "type": "video",
            "title": "GitHub Models DEMO | AI models for developers on GitHub",
            "url": "https://www.youtube.com/watch?v=WiBB8Lsgl7I"
          }
        ]
      }
    },
    {
      "id": "iWn3zDMOfLLjSp6f1jQoE",
      "name": "GitHub Copilot",
      "resources": {
        "description": "# GitHub Copilot\n\nGitHub Copilot is an AI-powered code-completion tool that helps developers write code faster and with less errors. It uses a combination of machine learning algorithms and access to GitHub's vast repository of open-source code to provide context-aware suggestions for coding tasks. Copilot can generate entire functions, methods, or even entire classes based on the context of the code being written. This feature aims to reduce the time spent on coding by providing immediate and relevant suggestions, allowing developers to focus more on high-level design and problem-solving.",
        "resources": [
          {
            "type": "course",
            "title": "Quickstart for GitHub Copilot",
            "url": "https://docs.github.com/en/copilot/quickstart"
          },
          {
            "type": "video",
            "title": "Intro to GitHob Copilot in Visual Studio",
            "url": "https://www.youtube.com/watch?v=z1ycDvspv8U"
          },
          {
            "type": "video",
            "title": "GitHub Copilot in VSCode: Top 10 Features Explained",
            "url": "https://www.youtube.com/watch?v=2nPoiUJpDaU"
          }
        ]
      }
    },
    {
      "id": "Ddkss13_qDJTquDHbVTVs",
      "name": "CITATION files",
      "resources": {
        "description": "# CITATION files\n\nYou can add a CITATION.cff file to the root of a repository to let others know how you would like them to cite your work. The citation file format is plain text with human- and machine-readable citation information.",
        "resources": [
          {
            "type": "course",
            "title": "CITATION Files Documentation",
            "url": "https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-citation-files"
          }
        ]
      }
    }
  ],
  "edges": [
    {
      "source": "iogwMmOvub2ZF4zgg6WyF",
      "target": "_hYN0gEi9BL24nptEtXWU"
    },
    {
      "source": "_hYN0gEi9BL24nptEtXWU",
      "target": "idLHBxhvcIqZTqmh_E8Az"
    },
    {
      "source": "_hYN0gEi9BL24nptEtXWU",
      "target": "os3Pa6W9SSNEzgmlBbglQ"
    },
    {
      "source": "_hYN0gEi9BL24nptEtXWU",
      "target": "3oInpqvTSSC5_K6i7j8N7"
    },
    {
      "source": "_hYN0gEi9BL24nptEtXWU",
      "target": "YKhuRbcUFzo0hTvuTq-Yl"
    },
    {
      "source": "jZ67HhVRelJaxjsCckSSI",
      "target": "hWA7RtuqltMTmHdcCnmES"
    },
    {
      "source": "",
      "target": "NMznG9mo2wzNFnjhg990f"
    },
    {
      "source": "",
      "target": "gc_7cuIO2_joKlQRAPDfX"
    },
    {
      "source": "rrrvATyhXqRgJGWI3z0WF",
      "target": "AvbMQ5vY3ip1oX_6Yq4ie"
    },
    {
      "source": "hWA7RtuqltMTmHdcCnmES",
      "target": "1AJv95mTLpR7L8KBoGym8"
    },
    {
      "source": "hWA7RtuqltMTmHdcCnmES",
      "target": "0etAs56EeBfh_0IlAaSra"
    },
    {
      "source": "jZ67HhVRelJaxjsCckSSI",
      "target": "h6ceO0kiBIxNRkPzN3hBY"
    },
    {
      "source": "jZ67HhVRelJaxjsCckSSI",
      "target": "_JlT9oKQ6Yu4UX6l19G8P"
    },
    {
      "source": "_hYN0gEi9BL24nptEtXWU",
      "target": "jZ67HhVRelJaxjsCckSSI"
    },
    {
      "source": "5Z9o-b3vBA-ITFg86zzYM",
      "target": "HlUUGj3dOZ68t4gIjerXh"
    },
    {
      "source": "HlUUGj3dOZ68t4gIjerXh",
      "target": "bY6b1GV2XQQ52NOx8gWFj"
    },
    {
      "source": "HlUUGj3dOZ68t4gIjerXh",
      "target": "dhIx1GnynvbSUriqYLUt0"
    },
    {
      "source": "HlUUGj3dOZ68t4gIjerXh",
      "target": "_jSTrYN9G8EsGHkbusKPU"
    },
    {
      "source": "HlUUGj3dOZ68t4gIjerXh",
      "target": "v7hCNbgPByi3YiLSs46BK"
    },
    {
      "source": "HlUUGj3dOZ68t4gIjerXh",
      "target": "PtU5Qwfzn3N1i3oRlCGoR"
    },
    {
      "source": "PtU5Qwfzn3N1i3oRlCGoR",
      "target": "bXfCUG3h1TIFPgD4WUDph"
    },
    {
      "source": "bXfCUG3h1TIFPgD4WUDph",
      "target": "OegitQ5Ngjvd3ZfMpfrkM"
    },
    {
      "source": "fIfmS6BkkOFWzCB1RqrhK",
      "target": "NeSvgS2yA5x8qbcJHrV__"
    },
    {
      "source": "NeSvgS2yA5x8qbcJHrV__",
      "target": "i7fIIHcBEk473te8bniJ5"
    },
    {
      "source": "GS3f1FKFVKT0-GJQrgCm8",
      "target": "KbVvFVQ4k77R2_ddsc7WT"
    },
    {
      "source": "c_FO6xMixrrMo6iisfsvl",
      "target": "HEqBbw_A4ZbJI5zEy8ViN"
    },
    {
      "source": "bXfCUG3h1TIFPgD4WUDph",
      "target": "fIfmS6BkkOFWzCB1RqrhK"
    },
    {
      "source": "NeSvgS2yA5x8qbcJHrV__",
      "target": "aWx9WHUrgofcTr8B-fQYe"
    },
    {
      "source": "0rHDUbAdXqH9zQW2VfJ8v",
      "target": "agtPWS8j6i6wQPk10cy8E"
    },
    {
      "source": "0rHDUbAdXqH9zQW2VfJ8v",
      "target": "Z-srOhYFGVEKDexlJ6cjt"
    },
    {
      "source": "0rHDUbAdXqH9zQW2VfJ8v",
      "target": "9Dt4Gyiiq5jteWSKxsRMK"
    },
    {
      "source": "0rHDUbAdXqH9zQW2VfJ8v",
      "target": "eFf2fesrs-1aVM5tH3ORQ"
    },
    {
      "source": "d_GNnB6PBINz1jxGNWAE-",
      "target": "C1ai9r31b7HPySw0o9tyT"
    },
    {
      "source": "C1ai9r31b7HPySw0o9tyT",
      "target": "xLB2fhsOm0Vu3xg_PusJB"
    },
    {
      "source": "C1ai9r31b7HPySw0o9tyT",
      "target": "pJ-najh7dXhhYA_0bDiR5"
    },
    {
      "source": "x6eILrLCQrVpz4j8uOuy6",
      "target": "8lXXVFkgK6n5IHaYkYe3l"
    },
    {
      "source": "x6eILrLCQrVpz4j8uOuy6",
      "target": "r-u1vTpUyuvsB0revOU0C"
    },
    {
      "source": "C1ai9r31b7HPySw0o9tyT",
      "target": "D2WIExwfSnkAPIa5O-Hp5"
    },
    {
      "source": "D2WIExwfSnkAPIa5O-Hp5",
      "target": "yMx3LdadPz4g25CL3N8da"
    },
    {
      "source": "yMx3LdadPz4g25CL3N8da",
      "target": "DzFJDdqnSy5GeGHWOpcVo"
    },
    {
      "source": "DzFJDdqnSy5GeGHWOpcVo",
      "target": "q0zy_hXav5iXw8LpGVJVd"
    },
    {
      "source": "DzFJDdqnSy5GeGHWOpcVo",
      "target": "hes8XQqAvpxWITcbU9tiH"
    },
    {
      "source": "hes8XQqAvpxWITcbU9tiH",
      "target": "X9K3PBpGsMoXkJsKdJPI7"
    },
    {
      "source": "hes8XQqAvpxWITcbU9tiH",
      "target": "zen3RRdK9_nPAYgicRoHk"
    },
    {
      "source": "zen3RRdK9_nPAYgicRoHk",
      "target": "lXC07j6dOa3rQixY1P-Ob"
    },
    {
      "source": "zen3RRdK9_nPAYgicRoHk",
      "target": "V8nLIvddyOKTzEjOJX5GW"
    },
    {
      "source": "zen3RRdK9_nPAYgicRoHk",
      "target": "0cLf7FiI9CX--UX45sm2f"
    },
    {
      "source": "zen3RRdK9_nPAYgicRoHk",
      "target": "qFEonbCMLri8iA0yONwuf"
    },
    {
      "source": "zen3RRdK9_nPAYgicRoHk",
      "target": "0Yi4cryT2v2SGBjouOas3"
    },
    {
      "source": "0Yi4cryT2v2SGBjouOas3",
      "target": "igrR7LguU1jemg_mf_AD6"
    },
    {
      "source": "igrR7LguU1jemg_mf_AD6",
      "target": "V_joZNpQsS9G9PI-o-GmC"
    },
    {
      "source": "igrR7LguU1jemg_mf_AD6",
      "target": "qis7Z5VRxMcOmbesQlegZ"
    },
    {
      "source": "igrR7LguU1jemg_mf_AD6",
      "target": "Uc7FyfAKpDFRGRNHwztFo"
    },
    {
      "source": "0Yi4cryT2v2SGBjouOas3",
      "target": "-0zQvCHG8jS_ghSjmTeIx"
    },
    {
      "source": "-0zQvCHG8jS_ghSjmTeIx",
      "target": "Rwpeltygwzcf6hnuZNURE"
    },
    {
      "source": "-0zQvCHG8jS_ghSjmTeIx",
      "target": "O-zoAWkDvyn7B8_TmY257"
    },
    {
      "source": "-0zQvCHG8jS_ghSjmTeIx",
      "target": "mzjtCdpke1ayHcEuS-YUS"
    },
    {
      "source": "-0zQvCHG8jS_ghSjmTeIx",
      "target": "uxqJzQFRcALqatNRIWR0w"
    },
    {
      "source": "-0zQvCHG8jS_ghSjmTeIx",
      "target": "sOoC-XxEoIvwKct00oKlX"
    },
    {
      "source": "sOoC-XxEoIvwKct00oKlX",
      "target": "NjPnEXLf1Lt9qzgxccogv"
    },
    {
      "source": "sOoC-XxEoIvwKct00oKlX",
      "target": "HMEfUFNu_Wp_Pac7VWHr-"
    },
    {
      "source": "sOoC-XxEoIvwKct00oKlX",
      "target": "BKVA6Q7DXemAYjyQOA0nh"
    },
    {
      "source": "sOoC-XxEoIvwKct00oKlX",
      "target": "OQOmxg9mCfcjt80hpvXkA"
    },
    {
      "source": "sOoC-XxEoIvwKct00oKlX",
      "target": "iFJBF-EEnLjQVsFSXjo_i"
    },
    {
      "source": "iFJBF-EEnLjQVsFSXjo_i",
      "target": "NeU38WPbEphJuJ_AMkH82"
    },
    {
      "source": "iFJBF-EEnLjQVsFSXjo_i",
      "target": "E3HAGNM-kXLL4Oci5JzpQ"
    },
    {
      "source": "iFJBF-EEnLjQVsFSXjo_i",
      "target": "62E1tDMXB6K74OEN0WsS0"
    },
    {
      "source": "iFJBF-EEnLjQVsFSXjo_i",
      "target": "YmnTrjJtqHPXbEVrP8vd7"
    },
    {
      "source": "iFJBF-EEnLjQVsFSXjo_i",
      "target": "pqBV7BMAs0z6qpfZeW2XP"
    },
    {
      "source": "pqBV7BMAs0z6qpfZeW2XP",
      "target": "e5O8lUSSEOEFR-dlZV5wN"
    },
    {
      "source": "pqBV7BMAs0z6qpfZeW2XP",
      "target": "v7uabKuMQPOD_hBIaHOVT"
    },
    {
      "source": "fjAFNjNNbPOzme9Uk_fDV",
      "target": "x4bnsPVTiX2xOCSyrgWpF"
    },
    {
      "source": "h9cf_dh_pwjialOXOlNW-",
      "target": "AmetdCURXXob5TUsikAab"
    },
    {
      "source": "AmetdCURXXob5TUsikAab",
      "target": "PUnYNBrAZWoZiopjtNgnA"
    },
    {
      "source": "Q7BSE-ueezjXkYluzMecJ",
      "target": "hru0sL1-D4bJSQI1efEyU"
    },
    {
      "source": "Q7BSE-ueezjXkYluzMecJ",
      "target": "ExXuwTQSI_lg4SRGW3Iu1"
    },
    {
      "source": "Q7BSE-ueezjXkYluzMecJ",
      "target": "4dxVN81rXWn6VZqK99yq0"
    },
    {
      "source": "Q7BSE-ueezjXkYluzMecJ",
      "target": "CGj_UX5JMOOCKinedsNRc"
    },
    {
      "source": "Q7BSE-ueezjXkYluzMecJ",
      "target": "zdunaucVe8J1tKf_z-NQo"
    },
    {
      "source": "xK8mSkkxTABUZV9zZjDPH",
      "target": "NV2HAXLEN7tskfgyFrbaf"
    },
    {
      "source": "NV2HAXLEN7tskfgyFrbaf",
      "target": "KlXPt-K6br8PtpLgELaCj"
    },
    {
      "source": "5Oax1p7zIZ9HD2hmENPof",
      "target": "qrdOARfqGPF9xhF6snbAn"
    },
    {
      "source": "NV2HAXLEN7tskfgyFrbaf",
      "target": "5Oax1p7zIZ9HD2hmENPof"
    },
    {
      "source": "xK8mSkkxTABUZV9zZjDPH",
      "target": "MoG7D9kqPuA6o52-z_WDN"
    },
    {
      "source": "RvqrjCowu0YK5QWK2ZVyg",
      "target": "bnai6R6pOq_L5CPdbVwMW"
    },
    {
      "source": "pFyMiyNQ16-kP7jKaKKEU",
      "target": "XRSVRl6iHncMmgSXoB7Lq"
    },
    {
      "source": "RvqrjCowu0YK5QWK2ZVyg",
      "target": "M2_hBvXou7cCNqsMnexCt"
    },
    {
      "source": "RvqrjCowu0YK5QWK2ZVyg",
      "target": "rqPCHh25xX_ROMr-ULpaw"
    },
    {
      "source": "RvqrjCowu0YK5QWK2ZVyg",
      "target": "NdfwgwMOewiyEAFyC2l7U"
    },
    {
      "source": "RvqrjCowu0YK5QWK2ZVyg",
      "target": "f2PG4t6iVtfIH8BVe5H7f"
    },
    {
      "source": "KMA7NkxFbPoUDtFnGBFnj",
      "target": "0vLaVNJaJSHZ_bHli6Qzs"
    },
    {
      "source": "wBKp8Q5D6WhjVVsD89UHl",
      "target": "0vLaVNJaJSHZ_bHli6Qzs"
    },
    {
      "source": "D2WIExwfSnkAPIa5O-Hp5",
      "target": "Ddkss13_qDJTquDHbVTVs"
    }
  ]
}